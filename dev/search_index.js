var documenterSearchIndex = {"docs":
[{"location":"nav/#Navigation-Algorithms","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"The following are key functions related to navigation algorithms.","category":"page"},{"location":"nav/#Cramér–Rao-Lower-Bound","page":"Navigation Algorithms","title":"Cramér–Rao Lower Bound","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"crlb","category":"page"},{"location":"nav/#MagNav.crlb","page":"Navigation Algorithms","title":"MagNav.crlb","text":"crlb(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, dt, itp_mapS;\n     P0         = create_P0(),\n     Qd         = create_Qd(),\n     R          = 1.0,\n     baro_tau   = 3600.0,\n     acc_tau    = 3600.0,\n     gyro_tau   = 3600.0,\n     fogm_tau   = 600.0,\n     date       = get_years(2020,185),\n     core::Bool = false)\n\nCramér–Rao lower bound (CRLB) computed with classic Kalman Filter. Equations evaluated about true trajectory.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\ndt:       measurement time step [s]\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nP: non-linear covariance matrix\n\n\n\n\n\ncrlb(traj::Traj, itp_mapS;\n     P0         = create_P0(),\n     Qd         = create_Qd(),\n     R          = 1.0,\n     baro_tau   = 3600.0,\n     acc_tau    = 3600.0,\n     gyro_tau   = 3600.0,\n     fogm_tau   = 600.0,\n     date       = get_years(2020,185),\n     core::Bool = false)\n\nCramér–Rao lower bound (CRLB) computed with classic Kalman Filter. Equations evaluated about true trajectory.\n\nArguments:\n\ntraj:     Traj trajectory struct\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nP: non-linear covariance matrix\n\n\n\n\n\n","category":"function"},{"location":"nav/#Extended-Kalman-Filter","page":"Navigation Algorithms","title":"Extended Kalman Filter","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"ekf","category":"page"},{"location":"nav/#MagNav.ekf","page":"Navigation Algorithms","title":"MagNav.ekf","text":"ekf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = get_years(2020,185),\n    core::Bool = false,\n    der_mapS   = nothing,\n    map_alt    = 0)\n\nExtended Kalman filter (EKF) for airborne magnetic anomaly navigation.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\nmeas:     scalar magnetometer measurement [nT]\ndt:       measurement time step [s]\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\nder_mapS: (optional) scalar map vertical derivative grid interpolation\nmap_alt:  (optional) map altitude [m]\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\nekf(ins::INS, meas, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = get_years(2020,185),\n    core::Bool = false,\n    der_mapS   = map_itp(zeros(2,2),[-pi,pi],[-pi/2,pi/2]),\n    map_alt    = 0)\n\nExtended Kalman filter (EKF) for airborne magnetic anomaly navigation.\n\nArguments:\n\nins:      INS inertial navigation system struct\nmeas:     scalar magnetometer measurement [nT]\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\nder_mapS: (optional) scalar map vertical derivative grid interpolation\nmap_alt:  (optional) map altitude [m]\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\n","category":"function"},{"location":"nav/#Rao-Blackwellized-(Marginalized)-Particle-Filter","page":"Navigation Algorithms","title":"Rao-Blackwellized (Marginalized) Particle Filter","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"mpf","category":"page"},{"location":"nav/#MagNav.mpf","page":"Navigation Algorithms","title":"MagNav.mpf","text":"mpf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    num_part   = 1000,\n    thresh     = 0.8,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = get_years(2020,185),\n    core::Bool = false)\n\nRao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic  anomaly navigation. This simplified MPF works only with LINEAR dynamics.  This allows the same Kalman filter covariance matrices to be used with  each particle, simplifying the filter and reducing the computational load.  It is especially suited for map-matching navigation in which there is a  highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics.  The filter also assumes NON-correlated measurements to speed up computation.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\nmeas:     scalar magnetometer measurement [nT]\ndt:       measurement time step [s]\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nnum_part: (optional) number of particles\nthresh:   (optional) resampling threshold fraction {0:1}\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\nmpf(ins::INS, meas, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    num_part   = 1000,\n    thresh     = 0.8,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = get_years(2020,185),\n    core::Bool = false)\n\nRao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic  anomaly navigation. This simplified MPF works only with LINEAR dynamics.  This allows the same Kalman filter covariance matrices to be used with  each particle, simplifying the filter and reducing the computational load.  It is especially suited for map-matching navigation in which there is a  highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics.  The filter also assumes NON-correlated measurements to speed up computation.\n\nArguments:\n\nins:      INS inertial navigation system struct\nmeas:     scalar magnetometer measurement [nT]\nitp_mapS: scalar map interpolation function\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nnum_part: (optional) number of particles\nthresh:   (optional) resampling threshold fraction {0:1}\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\n","category":"function"},{"location":"nav/#Run-Filter-(with-additional-options)","page":"Navigation Algorithms","title":"Run Filter (with additional options)","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"run_filt","category":"page"},{"location":"nav/#MagNav.run_filt","page":"Navigation Algorithms","title":"MagNav.run_filt","text":"run_filt(traj::Traj, ins::INS, meas, itp_mapS, filt_type::Symbol = :ekf;\n         P0             = create_P0(),\n         Qd             = create_Qd(),\n         R              = 1.0,\n         num_part       = 1000,\n         thresh         = 0.8,\n         baro_tau       = 3600.0,\n         acc_tau        = 3600.0,\n         gyro_tau       = 3600.0,\n         fogm_tau       = 600.0,\n         date           = get_years(2020,185),\n         core::Bool     = false,\n         map_alt        = 0,\n         nn_x           = nothing,\n         m              = nothing,\n         y_norms        = nothing,\n         terms          = [:permanent,:induced,:eddy,:bias],\n         flux::MagV     = MagV([0.0],[0.0],[0.0],[0.0]),\n         x0_TL          = ones(eltype(P0),19),\n         extract::Bool  = true,\n         run_crlb::Bool = true)\n\nRun navigation filter and optionally compute Cramér–Rao lower bound (CRLB).\n\nArguments:\n\ntraj:      Traj trajectory struct\nins:       INS inertial navigation system struct\nmeas:      scalar magnetometer measurement [nT]\nitp_mapS:  scalar map interpolation function\nfilt_type: (optional) filter type {:ekf,:mpf}\nP0:        (optional) initial covariance matrix\nQd:        (optional) discrete time process/system noise matrix\nR:         (optional) measurement (white) noise variance\nnum_part:  (optional) number of particles (:mpf only)\nthresh:    (optional) resampling threshold fraction {0:1} (:mpf only)\nbaro_tau:  (optional) barometer time constant [s]\nacc_tau:   (optional) accelerometer time constant [s]\ngyro_tau:  (optional) gyroscope time constant [s]\nfogm_tau:  (optional) FOGM catch-all time constant [s]\ndate:      (optional) measurement date for IGRF [yr]\ncore:      (optional) if true, include core magnetic field in measurement\nmap_alt:   (optional) map altitude [m]\nnn_x:      (optional) x matrix for neural network\nm:         (optional) neural network model\ny_norms:   (optional) Tuple of y normalizations, i.e., (y_bias,y_scale)\nterms:     (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nflux:      (optional) MagV vector magnetometer measurement struct\nx0_TL:     (optional) initial Tolles-Lawson coefficient states\nextract:   (optional) if true, extract output structs\nrun_crlb:  (optional) if true, compute the Cramér–Rao lower bound (CRLB)\n\nReturns:\n\nif extract = true  & run_crlb = true\ncrlb_out: CRLBout Cramér–Rao lower bound extracted output struct\nins_out:  INSout  inertial navigation system extracted output struct\nfilt_out: FILTout filter extracted output struct\nif extract = true  & run_crlb = false\nfilt_out: FILTout filter extracted output struct\nif extract = false & run_crlb = true\nfilt_res: FILTres filter results struct\ncrlb_P:   Cramér–Rao lower bound non-linear covariance matrix\nif extract = false & run_crlb = false\nfilt_res: FILTres filter results struct\n\n\n\n\n\nrun_filt(traj::Traj, ins::INS, meas, itp_mapS,\n         filt_type::Vector{Symbol}; ...)\n\nRun multiple filter models and print results (nothing returned).\n\nArguments:\n\nfilt_type: multiple filter types, e.g., [:ekf,:ekf_online_nn]\n\n\n\n\n\n","category":"function"},{"location":"maps/#Magnetic-Anomaly-Maps","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"The following are key functions related to magnetic anomaly maps.","category":"page"},{"location":"maps/#Load-Map-Data","page":"Magnetic Anomaly Maps","title":"Load Map Data","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"get_map","category":"page"},{"location":"maps/#MagNav.get_map","page":"Magnetic Anomaly Maps","title":"MagNav.get_map","text":"get_map(map_file::String   = namad;\n        map_units::Symbol  = :rad,\n        file_units::Symbol = :deg)\n\nGet map data from saved HDF5 or MAT file. Maps are typically saved in :deg units, while :rad is used internally.\n\nArguments:\n\nmap_file:   path/name of map data HDF5 or MAT file (.h5 or .mat extension required)\nmap_units:  (optional) map xx/yy units to use in map_map {:rad,:deg}\nfile_units: (optional) map xx/yy units used in map_file {:rad,:deg}\n\nReturns:\n\nmap_map: Map magnetic anomaly map struct\n\n\n\n\n\nget_map(map_name::Symbol, df_map::DataFrame;\n        map_units::Symbol  = :rad,\n        file_units::Symbol = :deg)\n\nGet map data from saved HDF5 or MAT file via DataFrame lookup. Maps are typically saved in :deg units, while :rad is used internally.\n\nArguments:\n\nmap_name:   name of magnetic anomaly map\ndf_map:     lookup table (DataFrame) of map data HDF5 and/or MAT files\nmap_units:  (optional) map xx/yy units to use in map_map {:rad,:deg}\nfile_units: (optional) map xx/yy units used in files within df_map {:rad,:deg}\n\nReturns:\n\nmap_map: Map magnetic anomaly map struct\n\n\n\n\n\n","category":"function"},{"location":"maps/#Upward-Continue-Map","page":"Magnetic Anomaly Maps","title":"Upward Continue Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"upward_fft","category":"page"},{"location":"maps/#MagNav.upward_fft","page":"Magnetic Anomaly Maps","title":"MagNav.upward_fft","text":"upward_fft(map_map::Matrix, dx, dy, dz; expand::Bool=true, α=0)\n\nUpward continuation of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform (FFT) to convert the map to the frequency domain, applies an upward continuation filter, and uses the inverse FFT to convert the map back to the spatial domain. Optionally expands the map temporarily with periodic padding. Downward continuation may be performed to a limited degree as well, but be careful, as this is generally unstable and amplify high frequencies (i.e., noise).\n\nReference: Blakely, Potential Theory in Gravity and Magnetic Applications, 2009, Chapter 12 & Appendix B (pg. 315-317 & 402).\n\nArguments:\n\nmap_map: ny x nx 2D gridded map data\ndx::     x-direction map step size [m]\ndy:      y-direction map step size [m]\ndz:      z-direction upward/downward continuation distance(s) [m]\nexpand:  (optional) if true, expand map temporarily to reduce edge effects\nα:       (optional) regularization parameter for downward continuation\n\nReturns:\n\nmap_map: ny x nx 2D gridded map data, upward/downward continued\n\n\n\n\n\nupward_fft(map_map::Map, alt; expand::Bool=true, α=0)\n\nUpward continuation of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform (FFT) to convert the map to the frequency domain, applies an upward continuation filter, and uses the inverse FFT to convert the map back to the spatial domain. Optionally expands the map temporarily with periodic padding. Downward continuation may be performed to a limited degree as well, but be careful, as this is generally unstable and amplify high frequencies (i.e., noise).\n\nReference: Blakely, Potential Theory in Gravity and Magnetic Applications, 2009, Chapter 12 & Appendix B (pg. 315-317 & 402).\n\nArguments:\n\nmap_map: Map magnetic anomaly map struct\nalt:     target upward continuation altitude(s) [m]\nexpand:  (optional) if true, expand map temporarily to reduce edge effects\nα:       (optional) regularization parameter for downward continuation\n\nReturns:\n\nmap_map: Map magnetic anomaly map struct, upward/downward continued (MapS with alt vector => MapS3D)\n\n\n\n\n\n","category":"function"},{"location":"maps/#Interpolate-Map","page":"Magnetic Anomaly Maps","title":"Interpolate Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"map_interpolate","category":"page"},{"location":"maps/#MagNav.map_interpolate","page":"Magnetic Anomaly Maps","title":"MagNav.map_interpolate","text":"map_interpolate(map_map, map_xx, map_yy, type::Symbol = :cubic, map_alt = [])\n\nCreate map interpolation function, equivalent of griddedInterpolant in MATLAB.\n\nArguments:\n\nmap_map: ny x nx (x nz) 2D or 3D gridded map data\nmap_xx:  nx map x-direction (longitude) coordinates\nmap_yy:  ny map y-direction (latitude)  coordinates\ntype:    (optional) type of interpolation {:linear,:quad,:cubic}\nmap_alt: (optional) map altitude levels\n\nReturns:\n\nitp_map: map interpolation function\n\n\n\n\n\nmap_interpolate(mapS::Union{MapS,MapSd,MapS3D}, type::Symbol = :cubic;\n                return_vert_deriv::Bool = false)\n\nCreate map interpolation function, equivalent of griddedInterpolant in MATLAB. Optionally return vertical derivative grid interpolation, which is calculated using finite differences between the map and a slightly upward continued map.\n\nArguments:\n\nmapS:              MapS, MapSd, or MapS3D scalar magnetic anomaly map struct\ntype:              (optional) type of interpolation {:linear,:quad,:cubic}\nreturn_vert_deriv: (optional) if true, also return der_map, only valid for MapS or MapSd\n\nReturns:\n\nitp_map: map interpolation function\nder_map: if return_vert_deriv = true, vertical derivative grid interpolation\n\n\n\n\n\nmap_interpolate(mapV::MapV, dim::Symbol = :X, type::Symbol = :cubic)\n\nCreate map interpolation function, equivalent of griddedInterpolant in MATLAB.\n\nArguments:\n\nmapV: MapV vector magnetic anomaly map struct\ndim:  map dimension to interpolate {:X,:Y,:Z}\ntype: (optional) type of interpolation {:linear,:quad,:cubic}\n\nReturns:\n\nitp_map: map interpolation function\n\n\n\n\n\n","category":"function"},{"location":"maps/#Plot-Map","page":"Magnetic Anomaly Maps","title":"Plot Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"plot_map","category":"page"},{"location":"maps/#MagNav.plot_map","page":"Magnetic Anomaly Maps","title":"MagNav.plot_map","text":"plot_map(map_map::Matrix,\n         map_xx::Vector     = [],\n         map_yy::Vector     = [];\n         clims::Tuple       = (0,0),\n         dpi::Int           = 200,\n         margin::Int        = 2,\n         Nmax::Int          = 6*dpi,\n         legend::Bool       = true,\n         axis::Bool         = true,\n         map_color::Symbol  = :usgs,\n         bg_color::Symbol   = :white,\n         map_units::Symbol  = :rad,\n         plot_units::Symbol = :deg,\n         b_e                = gr())\n\nPlot map.\n\nArguments:\n\nmap_map:    ny x nx 2D gridded map data\nmap_xx:     nx map x-direction (longitude) coordinates [rad] or [deg]\nmap_yy:     ny map y-direction (latitude)  coordinates [rad] or [deg]\nclims:      (optional) color scale limits\ndpi:        (optional) dots per inch (image resolution)\nmargin:     (optional) margin around plot [mm]\nNmax:       (optional) maximum number of data points plotted\nlegend:     (optional) if true, show legend\naxis:       (optional) if true, show axes\nmap_color:  (optional) filled contour color scheme {:usgs,:gray,:gray1,:gray2,:plasma,:magma}\nbg_color:   (optional) background color\nmap_units:  (optional) map  xx/yy units {:rad,:deg}\nplot_units: (optional) plot xx/yy units {:rad,:deg,:m}\nb_e:        (optional) plotting backend\n\nReturns:\n\np1: plot of map\n\n\n\n\n\nplot_map(map_map::Map;\n         clims::Tuple       = (0,0),\n         dpi::Int           = 200,\n         margin::Int        = 2,\n         Nmax::Int          = 6*dpi,\n         legend::Bool       = true,\n         axis::Bool         = true,\n         map_color::Symbol  = :usgs,\n         bg_color::Symbol   = :white,\n         map_units::Symbol  = :rad,\n         plot_units::Symbol = :deg,\n         b_e                = gr())\n\nPlot map.\n\nArguments:\n\nmap_map:    Map magnetic anomaly map struct\nclims:      (optional) color scale limits\ndpi:        (optional) dots per inch (image resolution)\nmargin:     (optional) margin around plot [mm]\nNmax:       (optional) maximum number of data points plotted\nlegend:     (optional) if true, show legend\naxis:       (optional) if true, show axes\nmap_color:  (optional) filled contour color scheme {:usgs,:gray,:gray1,:gray2,:plasma,:magma}\nbg_color:   (optional) background color\nmap_units:  (optional) map  xx/yy units {:rad,:deg}\nplot_units: (optional) plot xx/yy units {:rad,:deg,:m}\nb_e:        (optional) plotting backend\n\nReturns:\n\np1: plot of map (if typeof(map_map) = MapV, mapX)\np2: if typeof(map_map) = MapV, mapY\np3: if typeof(map_map) = MapV, mapZ\n\n\n\n\n\n","category":"function"},{"location":"comp/#Aeromagnetic-Compensation","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"The following are key functions related to aeromagnetic compensation.","category":"page"},{"location":"comp/#Tolles-Lawson","page":"Aeromagnetic Compensation","title":"Tolles-Lawson","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"create_TL_A","category":"page"},{"location":"comp/#MagNav.create_TL_A","page":"Aeromagnetic Compensation","title":"MagNav.create_TL_A","text":"create_TL_A(Bx, By, Bz;\n            Bt       = sqrt.(Bx.^2+By.^2+Bz.^2),\n            terms    = [:permanent,:induced,:eddy],\n            Bt_scale = 50000,\n            return_B = false)\n\nCreate Tolles-Lawson A matrix using vector magnetometer measurements.  Optionally returns the magnitude and derivatives of total field.\n\nArguments:\n\nBx,By,Bz: vector magnetometer measurements [nT]\nBt:           (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nterms:        (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nBt_scale:     (optional) scaling factor for induced and eddy current terms [nT]\nreturn_B:     (optional) if true, also return Bt & B_dot\n\nReturns:\n\nA:     Tolles-Lawson A matrix\nBt:    if return_B = true, magnitude of total field measurements [nT]\nB_dot: if return_B = true, finite differences of total field vector [nT]\n\n\n\n\n\ncreate_TL_A(flux::MagV, ind=trues(length(flux.x));\n            Bt       = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],\n            terms    = [:permanent,:induced,:eddy],\n            Bt_scale = 50000,\n            return_B = false)\n\nCreate Tolles-Lawson A matrix using vector magnetometer measurements.  Optionally returns the magnitude and derivatives of total field.\n\nArguments:\n\nflux:     MagV vector magnetometer measurement struct\nind:      (optional) selected data indices\nBt:       (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nterms:    (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nBt_scale: (optional) scaling factor for induced and eddy current terms [nT]\nreturn_B: (optional) if true, also return Bt & B_dot\n\nReturns:\n\nA:     Tolles-Lawson A matrix\nBt:    if return_B = true, magnitude of total field measurements [nT]\nB_dot: if return_B = true, finite differences of total field vector [nT]\n\n\n\n\n\n","category":"function"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"create_TL_coef","category":"page"},{"location":"comp/#MagNav.create_TL_coef","page":"Aeromagnetic Compensation","title":"MagNav.create_TL_coef","text":"create_TL_coef(Bx, By, Bz, B;\n               Bt         = sqrt.(Bx.^2+By.^2+Bz.^2),\n               λ          = 0,\n               terms      = [:permanent,:induced,:eddy],\n               pass1      = 0.1,\n               pass2      = 0.9,\n               fs         = 10.0,\n               pole::Int  = 4,\n               trim::Int  = 20,\n               Bt_scale   = 50000,\n               return_var = false)\n\nCreate Tolles-Lawson coefficients using vector and scalar magnetometer  measurements and a bandpass, low-pass or high-pass filter.\n\nArguments:\n\nBx,By,Bz: vector magnetometer measurements [nT]\nB:            scalar magnetometer measurements [nT]\nBt:           (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nλ:            (optional) ridge parameter\nterms:        (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\npass1:        (optional) first passband frequency [Hz]\npass2:        (optional) second passband frequency [Hz]\nfs:           (optional) sampling frequency [Hz]\npole:         (optional) number of poles for Butterworth filter\ntrim:         (optional) number of elements to trim after filtering\nBt_scale:     (optional) scaling factor for induced and eddy current terms [nT]\nreturn_var:   (optional) if true, also return B_var\n\nReturns:\n\ncoef:  Tolles-Lawson coefficients\nB_var: if return_var = true, fit error variance\n\n\n\n\n\ncreate_TL_coef(flux::MagV, B, ind=trues(length(flux.x));\n               Bt         = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],\n               λ          = 0,\n               terms      = [:permanent,:induced,:eddy],\n               pass1      = 0.1,\n               pass2      = 0.9,\n               fs         = 10.0,\n               pole::Int  = 4,\n               trim::Int  = 20,\n               Bt_scale   = 50000,\n               return_var = false)\n\nCreate Tolles-Lawson coefficients using vector and scalar magnetometer  measurements and a bandpass, low-pass or high-pass filter.\n\nArguments:\n\nflux:       MagV vector magnetometer measurement struct\nB:          scalar magnetometer measurements [nT]\nind:        (optional) selected data indices\nBt:         (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nλ:          (optional) ridge parameter\nterms:      (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\npass1:      (optional) first passband frequency [Hz]\npass2:      (optional) second passband frequency [Hz]\nfs:         (optional) sampling frequency [Hz]\npole:       (optional) number of poles for Butterworth filter\ntrim:       (optional) number of elements to trim after filtering\nBt_scale:   (optional) scaling factor for induced and eddy current terms [nT]\nreturn_var: (optional) if true, also return B_var\n\nReturns:\n\ncoef:  Tolles-Lawson coefficients\nB_var: if return_var = true, fit error variance\n\n\n\n\n\n","category":"function"},{"location":"comp/#Model-Training/Fitting","page":"Aeromagnetic Compensation","title":"Model Training/Fitting","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"comp_train","category":"page"},{"location":"comp/#MagNav.comp_train","page":"Aeromagnetic Compensation","title":"MagNav.comp_train","text":"comp_train(xyz::XYZ, ind, mapS::Union{MapS,MapSd,MapS3D} = mapS_null;\n           comp_params::CompParams = NNCompParams(),\n           xyz_test::XYZ           = xyz,\n           ind_test::BitVector     = BitVector(),\n           silent::Bool            = true)\n\nTrain an aeromagnetic compensation model.\n\nArguments:\n\nxyz:         XYZ flight data struct\nind:         selected data indices\nmapS:        (optional) MapS, MapSd, or MapS3D scalar magnetic anomaly map struct, only used for y_type = :b, :c\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nxyz_test:    (optional) XYZ held-out test data struct\nind_test:    (optional) indices for test data struct\nsilent:      (optional) if true, no print outs\n\nReturns:\n\ncomp_params: CompParams aeromagnetic compensation parameters struct\ny:           observed data\ny_hat:       predicted data\nerr:         compensation error\nfeatures:    full list of features (including components of TL A, etc.)\n\n\n\n\n\ncomp_train(xyz_vec::Vector{XYZ20{Int64,Float64}},\n           ind_vec::Vector{BitVector},\n           mapS::Union{MapS,MapSd,MapS3D} = mapS_null;\n           comp_params::CompParams = NNCompParams(),\n           xyz_test::XYZ           = xyz_vec[1],\n           ind_test::BitVector     = BitVector(),\n           silent::Bool            = true)\n\nTrain an aeromagnetic compensation model.\n\nArguments:\n\nxyz_vec:     vector of XYZ flight data structs\nind_vec:     vector of selected data indices\nmapS:        (optional) MapS, MapSd, or MapS3D scalar magnetic anomaly map struct, only used for y_type = :b, :c\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nxyz_test:    (optional) XYZ held-out test data struct\nind_test:    (optional) indices for test data struct\nsilent:      (optional) if true, no print outs\n\nReturns:\n\ncomp_params: CompParams aeromagnetic compensation parameters struct\ny:           observed data\ny_hat:       predicted data\nerr:         compensation error\nfeatures:    full list of features (including components of TL A, etc.)\n\n\n\n\n\ncomp_train(lines, df_line::DataFrame, df_flight::DataFrame,\n           df_map::DataFrame, comp_params::CompParams=NNCompParams();\n           silent::Bool=true)\n\nTrain an aeromagnetic compensation model.\n\nArguments:\n\nlines:       selected line number(s)\ndf_line:     lookup table (DataFrame) of lines\ndf_flight:   lookup table (DataFrame) of flight data HDF5 files\ndf_map:      lookup table (DataFrame) of map data HDF5 files\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent:      (optional) if true, no print outs\n\nReturns:\n\ncomp_params: CompParams aeromagnetic compensation parameters struct\ny:           observed data\ny_hat:       predicted data\nerr:         mean-corrected (per line) compensation error\nfeatures:    full list of features (including components of TL A, etc.)\n\n\n\n\n\n","category":"function"},{"location":"comp/#Model-Testing","page":"Aeromagnetic Compensation","title":"Model Testing","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"comp_test","category":"page"},{"location":"comp/#MagNav.comp_test","page":"Aeromagnetic Compensation","title":"MagNav.comp_test","text":"comp_test(xyz::XYZ, ind, mapS::Union{MapS,MapSd,MapS3D} = mapS_null;\n          comp_params::CompParams=NNCompParams(), silent::Bool=false)\n\nEvaluate performance of an aeromagnetic compensation model.\n\nArguments:\n\nxyz:         XYZ flight data struct\nind:         selected data indices\nmapS:        (optional) MapS, MapSd, or MapS3D scalar magnetic anomaly map struct, only used for y_type = :b, :c\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent:      (optional) if true, no print outs\n\nReturns:\n\ny:        observed data\ny_hat:    predicted data\nerr:      compensation error\nfeatures: full list of features (including components of TL A, etc.)\n\n\n\n\n\ncomp_test(lines, df_line::DataFrame, df_flight::DataFrame,\n          df_map::DataFrame, comp_params::CompParams=NNCompParams();\n          silent::Bool=false)\n\nEvaluate performance of an aeromagnetic compensation model.\n\nArguments:\n\nlines:       selected line number(s)\ndf_line:     lookup table (DataFrame) of lines\ndf_flight:   lookup table (DataFrame) of flight data HDF5 files\ndf_map:      lookup table (DataFrame) of map data HDF5 files\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent:      (optional) if true, no print outs\n\nReturns:\n\ny:        observed data\ny_hat:    predicted data\nerr:      mean-corrected (per line) compensation error\nfeatures: full list of features (including components of TL A, etc.)\n\n\n\n\n\n","category":"function"},{"location":"structs/#Custom-Structs","page":"Custom Structs","title":"Custom Structs","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"The following are custom structs used within the package.","category":"page"},{"location":"structs/#Magnetic-Anomaly-Maps","page":"Custom Structs","title":"Magnetic Anomaly Maps","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.Map","category":"page"},{"location":"structs/#MagNav.Map","page":"Custom Structs","title":"MagNav.Map","text":"Map{T2 <: AbstractFloat}\n\nAbstract type Map for a magnetic anomaly map.\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.MapS","category":"page"},{"location":"structs/#MagNav.MapS","page":"Custom Structs","title":"MagNav.MapS","text":"MapS{T2 <: AbstractFloat} <: Map{T2}\n\nScalar magnetic anomaly map struct. Subtype of Map.\n\nField Type Description\nmap Matrix{T2} ny x nx scalar magnetic anomaly map [nT]\nxx Vector{T2} nx map x-direction (longitude) coordinates [rad]\nyy Vector{T2} ny map y-direction (latitude)  coordinates [rad]\nalt T2 map altitude [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.MapSd","category":"page"},{"location":"structs/#MagNav.MapSd","page":"Custom Structs","title":"MagNav.MapSd","text":"MapSd{T2 <: AbstractFloat} <: Map{T2}\n\nScalar magnetic anomaly map struct used to store an additional altitude map for drape maps. Subtype of Map.\n\nField Type Description\nmap Matrix{T2} ny x nx scalar magnetic anomaly map [nT]\nxx Vector{T2} nx map x-direction (longitude) coordinates [rad]\nyy Vector{T2} ny map y-direction (latitude)  coordinates [rad]\nalt Matrix{T2} ny x nx altitude map [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.MapS3D","category":"page"},{"location":"structs/#MagNav.MapS3D","page":"Custom Structs","title":"MagNav.MapS3D","text":"MapS3D{T2 <: AbstractFloat} <: Map{T2}\n\n3D (multi-level) scalar magnetic anomaly map struct. Subtype of Map.\n\nField Type Description\nmap Array{T2,3} ny x nx x nz 3D (multi-level) scalar magnetic anomaly map [nT]\nxx Vector{T2} nx map x-direction (longitude) coordinates [rad]\nyy Vector{T2} ny map y-direction (latitude)  coordinates [rad]\nalt Vector{T2} nz map altitude levels [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.MapV","category":"page"},{"location":"structs/#MagNav.MapV","page":"Custom Structs","title":"MagNav.MapV","text":"MapV{T2 <: AbstractFloat} <: Map{T2}\n\nVector magnetic anomaly map struct. Subtype of Map.\n\nField Type Description\nmapX Matrix{T2} ny x nx x-direction magnetic anomaly map [nT]\nmapY Matrix{T2} ny x nx y-direction magnetic anomaly map [nT]\nmapZ Matrix{T2} ny x nx z-direction magnetic anomaly map [nT]\nxx Vector{T2} nx map x-direction (longitude) coordinates [rad]\nyy Vector{T2} ny map y-direction (latitude)  coordinates [rad]\nalt T2 map altitude [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.Map_Cache","category":"page"},{"location":"structs/#MagNav.Map_Cache","page":"Custom Structs","title":"MagNav.Map_Cache","text":"Map_Cache\n\nMap cache struct, mutable.\n\nField Type Description\nmaps Vector{MapS{Float64}} vector of MapS scalar magnetic anomaly map structs, not filled-in\nmaps_filled Vector{MapS{Float64}} vector of MapS scalar magnetic anomaly map structs, filled-in\nmap_sort_ind Vector{Int64} maps indices sorted by altitude\nfallback MapS{Float64} fallback MapS scalar magnetic anomaly map struct, filled-in\nmap_cache Dict maps     cache of scalar map interpolation functions at multiple altitudes\nfallback_cache Dict fallback cache of scalar map interpolation functions at multiple altitudes\ndz Real step size between map altitude levels [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/#Vector-Magnetometer","page":"Custom Structs","title":"Vector Magnetometer","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.MagV","category":"page"},{"location":"structs/#MagNav.MagV","page":"Custom Structs","title":"MagNav.MagV","text":"MagV{T2 <: AbstractFloat}\n\nVector magnetometer measurement struct.\n\nField Type Description\nx Vector{T2} x-direction magnetic field [nT]\ny Vector{T2} y-direction magnetic field [nT]\nz Vector{T2} z-direction magnetic field [nT]\nt Vector{T2} total magnetic field [nT]\n\n\n\n\n\n","category":"type"},{"location":"structs/#Flight-Paths","page":"Custom Structs","title":"Flight Paths","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.Path","category":"page"},{"location":"structs/#MagNav.Path","page":"Custom Structs","title":"MagNav.Path","text":"Path{T1 <: Signed, T2 <: AbstractFloat} <: Path{T1, T2}\n\nAbstract type Path for a flight path.\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.Traj","category":"page"},{"location":"structs/#MagNav.Traj","page":"Custom Structs","title":"MagNav.Traj","text":"Traj{T1 <: Signed, T2 <: AbstractFloat}\n\nTrajectory struct, i.e., GPS or other truth flight data. Subtype of Path.\n\nField Type Description\nN T1 number of samples (instances)\ndt T2 measurement time step [s]\ntt Vector{T2} time [s]\nlat Vector{T2} latitude  [rad]\nlon Vector{T2} longitude [rad]\nalt Vector{T2} altitude  [m]\nvn Vector{T2} north velocity [m/s]\nve Vector{T2} east  velocity [m/s]\nvd Vector{T2} down  velocity [m/s]\nfn Vector{T2} north specific force [m/s]\nfe Vector{T2} east  specific force [m/s]\nfd Vector{T2} down  specific force [m/s]\nCnb Array{T2,3} 3 x 3 x N direction cosine matrix (body to navigation) [-]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.INS","category":"page"},{"location":"structs/#MagNav.INS","page":"Custom Structs","title":"MagNav.INS","text":"INS{T1 <: Signed, T2 <: AbstractFloat} <: Path{T1, T2}\n\nInertial navigation system (INS) struct. Subtype of Path.\n\nField Type Description\nN T1 number of samples (instances)\ndt T2 measurement time step [s]\ntt Vector{T2} time [s]\nlat Vector{T2} latitude  [rad]\nlon Vector{T2} longitude [rad]\nalt Vector{T2} altitude  [m]\nvn Vector{T2} north velocity [m/s]\nve Vector{T2} east  velocity [m/s]\nvd Vector{T2} down  velocity [m/s]\nfn Vector{T2} north specific force [m/s]\nfe Vector{T2} east  specific force [m/s]\nfd Vector{T2} down  specific force [m/s]\nCnb Array{T2,3} 3 x 3 x N direction cosine matrix (body to navigation) [-]\nP Array{T2,3} 17 x 17 x N covariance matrix, only relevant for simulated data, otherwise zeros [-]\n\n\n\n\n\n","category":"type"},{"location":"structs/#Flight-Data","page":"Custom Structs","title":"Flight Data","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.XYZ","category":"page"},{"location":"structs/#MagNav.XYZ","page":"Custom Structs","title":"MagNav.XYZ","text":"XYZ{T1 <: Signed, T2 <: AbstractFloat}\n\nAbstract type XYZ for flight data. Simplest subtype is XYZ0.\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.XYZ0","category":"page"},{"location":"structs/#MagNav.XYZ0","page":"Custom Structs","title":"MagNav.XYZ0","text":"XYZ0{T1 <: Signed, T2 <: AbstractFloat} <: XYZ{T1, T2}\n\nSubtype of XYZ containing the minimum dataset required for MagNav.\n\nField Type Description\ntraj Traj{T1,T2} trajectory struct\nins INS{T1,T2} inertial navigation system struct\nflux_a MagV{T2} Flux A vector magnetometer measurement struct\nflight Vector{T2} flight number(s)\nline Vector{T2} line number(s), i.e., segments within flight\nmag_1_c Vector{T2} Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nmag_1_uc Vector{T2} Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.XYZ1","category":"page"},{"location":"structs/#MagNav.XYZ1","page":"Custom Structs","title":"MagNav.XYZ1","text":"XYZ1{T1 <: Signed, T2 <: AbstractFloat} <: XYZ{T1, T2}\n\nSubtype of XYZ containing a flexible dataset for future use. Feed in NaNs for any unused fields (e.g., aux_3) when creating struct.\n\nField Type Description\ntraj Traj{T1,T2} trajectory struct\nins INS{T1,T2} inertial navigation system struct\nflux_a MagV{T2} Flux A vector magnetometer measurement struct\nflux_b MagV{T2} Flux B vector magnetometer measurement struct\nflight Vector{T2} flight number(s)\nline Vector{T2} line number(s), i.e., segments within flight\nyear Vector{T2} year\ndoy Vector{T2} day of year\ndiurnal Vector{T2} measured diurnal, i.e., temporal variations or space weather effects [nT]\nigrf Vector{T2} International Geomagnetic Reference Field (IGRF), i.e., core field [nT]\nmag_1_c Vector{T2} Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nmag_2_c Vector{T2} Mag 2 compensated (clean) scalar magnetometer measurements [nT]\nmag_3_c Vector{T2} Mag 3 compensated (clean) scalar magnetometer measurements [nT]\nmag_1_uc Vector{T2} Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_2_uc Vector{T2} Mag 2 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_3_uc Vector{T2} Mag 3 uncompensated (corrupted) scalar magnetometer measurements [nT]\naux_1 Vector{T2} flexible-use auxiliary data 1\naux_2 Vector{T2} flexible-use auxiliary data 2\naux_3 Vector{T2} flexible-use auxiliary data 3\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.XYZ20","category":"page"},{"location":"structs/#MagNav.XYZ20","page":"Custom Structs","title":"MagNav.XYZ20","text":"XYZ20{T1 <: Signed, T2 <: AbstractFloat} <: XYZ{T1, T2}\n\nSubtype of XYZ for SGL 2020 datasets.\n\nField Type Description\ntraj Traj{T1,T2} trajectory struct\nins INS{T1,T2} inertial navigation system struct\nflux_a MagV{T2} Flux A vector magnetometer measurement struct\nflux_b MagV{T2} Flux B vector magnetometer measurement struct\nflux_c MagV{T2} Flux C vector magnetometer measurement struct\nflux_d MagV{T2} Flux D vector magnetometer measurement struct\nflight Vector{T2} flight number(s)\nline Vector{T2} line number(s), i.e., segments within flight\nyear Vector{T2} year\ndoy Vector{T2} day of year\nutm_x Vector{T2} x-coordinate, WGS-84 UTM zone 18N [m]\nutm_y Vector{T2} y-coordinate, WGS-84 UTM zone 18N [m]\nutm_z Vector{T2} z-coordinate, GPS altitude above WGS-84 ellipsoid [m]\nmsl Vector{T2} z-coordinate, GPS altitude above EGM2008 Geoid [m]\nbaro Vector{T2} barometric altimeter [m]\ndiurnal Vector{T2} measured diurnal, i.e., temporal variations or space weather effects [nT]\nigrf Vector{T2} International Geomagnetic Reference Field (IGRF), i.e., core field [nT]\nmag_1_c Vector{T2} Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nmag_1_lag Vector{T2} Mag 1 lag-corrected scalar magnetometer measurements [nT]\nmag_1_dc Vector{T2} Mag 1 diurnal-corrected scalar magnetometer measurements [nT]\nmag_1_igrf Vector{T2} Mag 1 IGRF & diurnal-corrected scalar magnetometer measurements [nT]\nmag_1_uc Vector{T2} Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_2_uc Vector{T2} Mag 2 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_3_uc Vector{T2} Mag 3 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_4_uc Vector{T2} Mag 4 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_5_uc Vector{T2} Mag 5 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_6_uc Vector{T2} Mag 6 uncompensated (corrupted) scalar magnetometer measurements [nT]\nogs_mag Vector{T2} OGS survey diurnal-corrected, levelled, magnetic field [nT]\nogs_alt Vector{T2} OGS survey, GPS altitude (WGS-84) [m]\nins_wander Vector{T2} INS-computed wander angle (ccw from north) [rad]\nins_roll Vector{T2} INS-computed aircraft roll [deg]\nins_pitch Vector{T2} INS-computed aircraft pitch [deg]\nins_yaw Vector{T2} INS-computed aircraft yaw [deg]\nroll_rate Vector{T2} avionics-computed roll rate [deg/s]\npitch_rate Vector{T2} avionics-computed pitch rate [deg/s]\nyaw_rate Vector{T2} avionics-computed yaw rate [deg/s]\nins_acc_x Vector{T2} INS x-acceleration [m/s^2]\nins_acc_y Vector{T2} INS y-acceleration [m/s^2]\nins_acc_z Vector{T2} INS z-acceleration [m/s^2]\nlgtl_acc Vector{T2} avionics-computed longitudinal (forward) acceleration [g]\nltrl_acc Vector{T2} avionics-computed lateral (starboard) acceleration [g]\nnrml_acc Vector{T2} avionics-computed normal (vertical) acceleration [g]\npitot_p Vector{T2} avionics-computed pitot pressure [kPa]\nstatic_p Vector{T2} avionics-computed static pressure [kPa]\ntotal_p Vector{T2} avionics-computed total pressure [kPa]\ncur_com_1 Vector{T2} current sensor: aircraft radio 1 [A]\ncur_ac_hi Vector{T2} current sensor: air conditioner fan high [A]\ncur_ac_lo Vector{T2} current sensor: air conditioner fan low [A]\ncur_tank Vector{T2} current sensor: cabin fuel pump [A]\ncur_flap Vector{T2} current sensor: flap motor [A]\ncur_strb Vector{T2} current sensor: strobe lights [A]\ncur_srvo_o Vector{T2} current sensor: INS outer servo [A]\ncur_srvo_m Vector{T2} current sensor: INS middle servo [A]\ncur_srvo_i Vector{T2} current sensor: INS inner servo [A]\ncur_heat Vector{T2} current sensor: INS heater [A]\ncur_acpwr Vector{T2} current sensor: aircraft power [A]\ncur_outpwr Vector{T2} current sensor: system output power [A]\ncur_bat_1 Vector{T2} current sensor: battery 1 [A]\ncur_bat_2 Vector{T2} current sensor: battery 2 [A]\nvol_acpwr Vector{T2} voltage sensor: aircraft power [V]\nvol_outpwr Vector{T2} voltage sensor: system output power [V]\nvol_bat_1 Vector{T2} voltage sensor: battery 1 [V]\nvol_bat_2 Vector{T2} voltage sensor: battery 2 [V]\nvol_res_p Vector{T2} voltage sensor: resolver board (+) [V]\nvol_res_n Vector{T2} voltage sensor: resolver board (-) [V]\nvol_back_p Vector{T2} voltage sensor: backplane (+) [V]\nvol_back_n Vector{T2} voltage sensor: backplane (-) [V]\nvol_gyro_1 Vector{T2} voltage sensor: gyroscope 1 [V]\nvol_gyro_2 Vector{T2} voltage sensor: gyroscope 2 [V]\nvol_acc_p Vector{T2} voltage sensor: INS accelerometers (+) [V]\nvol_acc_n Vector{T2} voltage sensor: INS accelerometers (-) [V]\nvol_block Vector{T2} voltage sensor: block [V]\nvol_back Vector{T2} voltage sensor: backplane [V]\nvol_srvo Vector{T2} voltage sensor: servos [V]\nvol_cabt Vector{T2} voltage sensor: cabinet [V]\nvol_fan Vector{T2} voltage sensor: cooling fan [V]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.XYZ21","category":"page"},{"location":"structs/#MagNav.XYZ21","page":"Custom Structs","title":"MagNav.XYZ21","text":"XYZ21{T1 <: Signed, T2 <: AbstractFloat} <: XYZ{T1, T2}\n\nSubtype of XYZ for SGL 2021 datasets.\n\nField Type Description\ntraj Traj{T1,T2} trajectory struct\nins INS{T1,T2} inertial navigation system struct\nflux_a MagV{T2} Flux A vector magnetometer measurement struct\nflux_b MagV{T2} Flux B vector magnetometer measurement struct\nflux_c MagV{T2} Flux C vector magnetometer measurement struct\nflux_d MagV{T2} Flux D vector magnetometer measurement struct\nflight Vector{T2} flight number(s)\nline Vector{T2} line number(s), i.e., segments within flight\nyear Vector{T2} year\ndoy Vector{T2} day of year\nutm_x Vector{T2} x-coordinate, WGS-84 UTM zone 18N [m]\nutm_y Vector{T2} y-coordinate, WGS-84 UTM zone 18N [m]\nutm_z Vector{T2} z-coordinate, GPS altitude above WGS-84 ellipsoid [m]\nmsl Vector{T2} z-coordinate, GPS altitude above EGM2008 Geoid [m]\nbaro Vector{T2} barometric altimeter [m]\ndiurnal Vector{T2} measured diurnal, i.e., temporal variations or space weather effects [nT]\nigrf Vector{T2} International Geomagnetic Reference Field (IGRF), i.e., core field [nT]\nmag_1_c Vector{T2} Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nmag_1_uc Vector{T2} Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_2_uc Vector{T2} Mag 2 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_3_uc Vector{T2} Mag 3 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_4_uc Vector{T2} Mag 4 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_5_uc Vector{T2} Mag 5 uncompensated (corrupted) scalar magnetometer measurements [nT]\ncur_com_1 Vector{T2} current sensor: aircraft radio 1 [A]\ncur_ac_hi Vector{T2} current sensor: air conditioner fan high [A]\ncur_ac_lo Vector{T2} current sensor: air conditioner fan low [A]\ncur_tank Vector{T2} current sensor: cabin fuel pump [A]\ncur_flap Vector{T2} current sensor: flap motor [A]\ncur_strb Vector{T2} current sensor: strobe lights [A]\nvol_block Vector{T2} voltage sensor: block [V]\nvol_back Vector{T2} voltage sensor: backplane [V]\nvol_cabt Vector{T2} voltage sensor: cabinet [V]\nvol_fan Vector{T2} voltage sensor: cooling fan [V]\n\n\n\n\n\n","category":"type"},{"location":"structs/#Output-Wrappers","page":"Custom Structs","title":"Output Wrappers","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.FILTres","category":"page"},{"location":"structs/#MagNav.FILTres","page":"Custom Structs","title":"MagNav.FILTres","text":"FILTres{T2 <: AbstractFloat}\n\nFilter results struct.\n\nField Type Description\nx Matrix{T2} filtered states, i.e., E(xt   y1,..,y_t)\nP Array{T2,3} non-linear covariance matrix\nr Matrix{T2} measurement residuals [nT]\nc Bool if true, filter converged\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.CRLBout","category":"page"},{"location":"structs/#MagNav.CRLBout","page":"Custom Structs","title":"MagNav.CRLBout","text":"CRLBout{T2 <: AbstractFloat}\n\nCramér–Rao lower bound extracted output struct.\n\nField Type Description\nlat_std Vector{T2} latitude  1-σ [rad]\nlon_std Vector{T2} longitude 1-σ [rad]\nalt_std Vector{T2} altitude  1-σ [m]\nvn_std Vector{T2} north velocity 1-σ [m/s]\nve_std Vector{T2} east  velocity 1-σ [m/s]\nvd_std Vector{T2} down  velocity 1-σ [m/s]\ntn_std Vector{T2} north tilt (attitude) 1-σ [rad]\nte_std Vector{T2} east  tilt (attitude) 1-σ [rad]\ntd_std Vector{T2} down  tilt (attitude) 1-σ [rad]\nfogm_std Vector{T2} FOGM 1-σ [nT]\nn_std Vector{T2} northing 1-σ [m]\ne_std Vector{T2} easting  1-σ [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.INSout","category":"page"},{"location":"structs/#MagNav.INSout","page":"Custom Structs","title":"MagNav.INSout","text":"INSout{T2 <: AbstractFloat}\n\nInertial navigation system extracted output struct.\n\nField Type Description\nlat_std Vector{T2} latitude  1-σ [rad]\nlon_std Vector{T2} longitude 1-σ [rad]\nalt_std Vector{T2} altitude  1-σ [m]\nn_std Vector{T2} northing  1-σ [m]\ne_std Vector{T2} easting   1-σ [m]\nlat_err Vector{T2} latitude  error [rad]\nlon_err Vector{T2} longitude error [rad]\nalt_err Vector{T2} altitude  error [m]\nn_err Vector{T2} northing  error [m]\ne_err Vector{T2} easting   error [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.FILTout","category":"page"},{"location":"structs/#MagNav.FILTout","page":"Custom Structs","title":"MagNav.FILTout","text":"FILTout{T1 <: Signed, T2 <: AbstractFloat} <: Path{T1, T2}\n\nFilter extracted output struct. Subtype of Path.\n\nField Type Description\nN T1 number of samples (instances)\ndt T2 measurement time step [s]\ntt Vector{T2} time [s]\nlat Vector{T2} latitude  [rad]\nlon Vector{T2} longitude [rad]\nalt Vector{T2} altitude  [m]\nvn Vector{T2} north velocity [m/s]\nve Vector{T2} east  velocity [m/s]\nvd Vector{T2} down  velocity [m/s]\ntn Vector{T2} north tilt (attitude) [rad]\nte Vector{T2} east  tilt (attitude) [rad]\ntd Vector{T2} down  tilt (attitude) [rad]\nha Vector{T2} barometer aiding altitude [m]\nah Vector{T2} barometer aiding vertical acceleration [m/s^2]\nax Vector{T2} x accelerometer [m/s^2]\nay Vector{T2} y accelerometer [m/s^2]\naz Vector{T2} z accelerometer [m/s^2]\ngx Vector{T2} x gyroscope [rad/s]\ngy Vector{T2} y gyroscope [rad/s]\ngz Vector{T2} z gyroscope [rad/s]\nfogm Vector{T2} FOGM catch-all [nT]\nlat_std Vector{T2} latitude  1-σ [rad]\nlon_std Vector{T2} longitude 1-σ [rad]\nalt_std Vector{T2} altitude  1-σ [m]\nvn_std Vector{T2} north velocity 1-σ [m/s]\nve_std Vector{T2} east  velocity 1-σ [m/s]\nvd_std Vector{T2} down  velocity 1-σ [m/s]\ntn_std Vector{T2} north tilt (attitude) 1-σ [rad]\nte_std Vector{T2} east  tilt (attitude) 1-σ [rad]\ntd_std Vector{T2} down  tilt (attitude) 1-σ [rad]\nha_std Vector{T2} barometer aiding altitude 1-σ [m]\nah_std Vector{T2} barometer aiding vertical acceleration 1-σ [m/s^2]\nax_std Vector{T2} x accelerometer 1-σ [m/s^2]\nay_std Vector{T2} y accelerometer 1-σ [m/s^2]\naz_std Vector{T2} z accelerometer 1-σ [m/s^2]\ngx_std Vector{T2} x gyroscope 1-σ [rad/s]\ngy_std Vector{T2} y gyroscope 1-σ [rad/s]\ngz_std Vector{T2} z gyroscope 1-σ [rad/s]\nfogm_std Vector{T2} FOGM catch-all 1-σ [nT]\nn_std Vector{T2} northing 1-σ [m]\ne_std Vector{T2} easting  1-σ [m]\nlat_err Vector{T2} latitude  error [rad]\nlon_err Vector{T2} longitude error [rad]\nalt_err Vector{T2} altitude  error [m]\nvn_err Vector{T2} north velocity error [m/s]\nve_err Vector{T2} east  velocity error [m/s]\nvd_err Vector{T2} down  velocity error [m/s]\ntn_err Vector{T2} north tilt (attitude) error [rad]\nte_err Vector{T2} east  tilt (attitude) error [rad]\ntd_err Vector{T2} down  tilt (attitude) error [rad]\nn_err Vector{T2} northing error [m]\ne_err Vector{T2} easting  error [m]\n\n\n\n\n\n","category":"type"},{"location":"structs/#Real-time-EKF","page":"Custom Structs","title":"Real-time EKF","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.EKF_RT","category":"page"},{"location":"structs/#MagNav.EKF_RT","page":"Custom Structs","title":"MagNav.EKF_RT","text":"EKF_RT\n\nReal-time (RT) extended Kalman filter (EKF) struct, mutable.\n\nField Type Description\nP Matrix{Float64} non-linear covariance matrix\nQd Matrix{Float64} discrete time process/system noise matrix\nR Float64 measurement (white) noise variance\nbaro_tau Float64 barometer time constant [s]\nacc_tau Float64 accelerometer time constant [s]\ngyro_tau Float64 gyroscope time constant [s]\nfogm_tau Float64 FOGM catch-all time constant [s]\ndate Float64 measurement date for IGRF [yr]\ncore Bool if true, include core magnetic field in measurement\nnx Int64 total state dimension\nny Int64 measurement dimension\nt Float64 time [s]\nx Vector{Float64} filtered states, i.e., E(xt   y1,..,y_t)\nr Vector{Float64} measurement residual\n\n\n\n\n\n","category":"type"},{"location":"structs/#Compensation-Parameters","page":"Custom Structs","title":"Compensation Parameters","text":"","category":"section"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.CompParams","category":"page"},{"location":"structs/#MagNav.CompParams","page":"Custom Structs","title":"MagNav.CompParams","text":"CompParams\n\nAbstract type CompParams for aeromagnetic compensation parameters.\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.LinCompParams","category":"page"},{"location":"structs/#MagNav.LinCompParams","page":"Custom Structs","title":"MagNav.LinCompParams","text":"LinCompParams <: CompParams\n\nLinear aeromagnetic compensation parameters struct. Subtype of CompParams.\n\nTo see default parameters, type LinCompParams().\n\nGeneral Parameters:\n\nParameter Description\nversion MagNav.jl version used to generate this struct\nfeatures_setup list of features to include\nfeatures_no_norm list of features to not normalize\nmodel_type aeromagnetic compensation model type (see below)\ny_type y target type (see below)\nuse_mag scalar magnetometer to use {:mag_1_uc, etc.}, only used for y_type = :c, :d, :e\nuse_vec vector magnetometer (fluxgate) to use for \"external\" Tolles-Lawson A matrix {:flux_a, etc.}, not used for model_type = :elasticnet, :plsr\ndata_norms Tuple of data normalizations, e.g., (A_bias,A_scale,x_bias,x_scale,y_bias,y_scale)\nmodel linear model coefficients\nterms Tolles-Lawson terms to use for Tolles-Lawson A matrix (or matrices) within x matrix {:permanent,:induced,:eddy}\nterms_A Tolles-Lawson terms to use for \"external\" Tolles-Lawson A matrix {:permanent,:induced,:eddy,:bias}, not used for model_type = :elasticnet, :plsr\nsub_diurnal if true, subtract diurnal from scalar magnetometer measurements\nsub_igrf if true, subtract IGRF from scalar magnetometer measurements\nbpf_mag if true, bpf scalar magnetometer measurements in x matrix\nreorient_vec if true, align vector magnetometers (fluxgates) with body frame\nnorm_type_A normalization for \"external\" Tolles-Lawson A matrix, not used for model_type = :elasticnet, :plsr (see below)\nnorm_type_x normalization for x matrix (see below)\nnorm_type_y normalization for y target vector (see below)\n\nmodel_type options:\n:TL         = classical Tolles-Lawson\n:mod_TL     = modified  Tolles-Lawson\n:map_TL     = map-based Tolles-Lawson\n:elasticnet = elastic net (ridge regression and/or Lasso)\n:plsr:      = partial least squares regression (PLSR)\ny_type options:\n:a = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements\n:b = anomaly field  #2, interpolated magnetic anomaly map values\n:c = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated magnetic anomaly map values\n:d = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements\n:e = BPF'd total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements\nnorm_type options:\n:standardize = Z-score normalization\n:normalize   = min-max normalization\n:scale       = scale by maximum absolute value, bias = 0\n:none        = scale by 1, bias = 0\n\nLinear Model-Specific Parameters:\n\nParameter Description\nk_plsr number of components, only used for model_type = :plsr\nλ_TL ridge parameter, only used for model_type = :TL, :mod_TL, :map_TL\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Custom Structs","title":"Custom Structs","text":"MagNav.NNCompParams","category":"page"},{"location":"structs/#MagNav.NNCompParams","page":"Custom Structs","title":"MagNav.NNCompParams","text":"NNCompParams <: CompParams\n\nNeural network-based aeromagnetic compensation parameters struct. Subtype of CompParams.\n\nTo see default parameters, type NNCompParams().\n\nGeneral Parameters:\n\nParameter Description\nversion MagNav.jl version used to generate this struct\nfeatures_setup list of features to include\nfeatures_no_norm list of features to not normalize\nmodel_type aeromagnetic compensation model type (see below)\ny_type y target type (see below)\nuse_mag scalar magnetometer to use {:mag_1_uc, etc.}, only used for y_type = :c, :d, :e\nuse_vec vector magnetometer (fluxgate) to use for \"external\" Tolles-Lawson A matrix {:flux_a, etc.}, not used for model_type = :m1\ndata_norms Tuple of data normalizations, e.g., (A_bias,A_scale,v_scale,x_bias,x_scale,y_bias,y_scale)\nmodel neural network model\nterms Tolles-Lawson terms to use for Tolles-Lawson A matrix (or matrices) within x matrix {:permanent,:induced,:eddy}\nterms_A Tolles-Lawson terms to use for \"external\" Tolles-Lawson A matrix {:permanent,:induced,:eddy,:bias}, not used for model_type = :m1\nsub_diurnal if true, subtract diurnal from scalar magnetometer measurements\nsub_igrf if true, subtract IGRF from scalar magnetometer measurements\nbpf_mag if true, bpf scalar magnetometer measurements in x matrix\nreorient_vec if true, align vector magnetometers (fluxgates) with body frame\nnorm_type_A normalization for \"external\" Tolles-Lawson A matrix, only used for model_type = :m2* (see below)\nnorm_type_x normalization for x matrix (see below)\nnorm_type_y normalization for y target vector (see below)\n\nmodel_type options are broken into 3 architectures, with 1 being a standard feedforward neural network and 2,3 being used in conjunction with Tolles-Lawson\n:m1   = standard feedforward neural network (NN)\n:m2a  = NN determines Tolles-Lawson (TL) coefficients\n:m2b  = NN determines additive correction to classical TL\n:m2c  = NN determines additive correction to classical TL, TL coefficients tuned as well\n:m2d  = NN determines additive correction to each TL coefficient\n:m3tl = no NN, TL coefficients fine-tuned via SGD, without Taylor expansion for y_type :b and :c (for testing)\n:m3s  = NN determines scalar correction to TL, using expanded TL vector terms for explainability\n:m3v  = NN determines vector correction to TL, using expanded TL vector terms for explainability\n:m3sc = :m3s with curriculum learning based on TL error\n:m3vc = :m3v with curriculum learning based on TL error\ny_type options:\n:a = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements\n:b = anomaly field  #2, interpolated magnetic anomaly map values\n:c = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated magnetic anomaly map values\n:d = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements\n:e = BPF'd total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements\nnorm_type options:\n:standardize = Z-score normalization\n:normalize   = min-max normalization\n:scale       = scale by maximum absolute value, bias = 0\n:none        = scale by 1, bias = 0\n\nNeural Network-Based Model-Specific Parameters:\n\nParameter Description\nTL_coef Tolles-Lawson coefficients, not used for model_type = :m1, :m2a\nη_adam learning rate for Adam optimizer\nepoch_adam number of epochs for Adam optimizer\nepoch_lbfgs number of epochs for LBFGS optimizer\nhidden hidden layers & nodes (e.g., [8,8] for 2 hidden layers, 8 nodes each)\nactivation activation function (see below)\nbatchsize mini-batch size\nfrac_train fraction of training data used for training (remainder for validation), only used for Adam optimizer\nα_sgl Lasso (α_sgl=0) vs group Lasso (α_sgl=1) balancing parameter {0:1}\nλ_sgl sparse group Lasso parameter, typically ~1e-5 (if nonzero)\nk_pca number of components for pre-processing with PCA + whitening, -1 to ignore\ndrop_fi if true, perform drop-column feature importance\ndrop_fi_bson path/name of drop-column feature importance data BSON file to save/load (.bson extension optional)\ndrop_fi_csv path/name of drop-column feature importance data CSV file to save (.csv extension optional)\nperm_fi if true, perform permutation feature importance\nperm_fi_csv path/name of permutation feature importance data CSV file to save (.csv extension optional)\n\nactivation options can be visualized by running plot_activation()\nrelu  = rectified linear unit\nσ     = sigmoid (logistic function)\nswish = self-gated\ntanh  = hyperbolic tan\n\n\n\n\n\n","category":"type"},{"location":"data/#Flight-Path-and-INS-Data","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"The following are key functions related to obtaining flight path & INS data.","category":"page"},{"location":"data/#Load-Flight-Data","page":"Flight Path & INS Data","title":"Load Flight Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ0","category":"page"},{"location":"data/#MagNav.get_XYZ0","page":"Flight Path & INS Data","title":"MagNav.get_XYZ0","text":"get_XYZ0(xyz_file::String,\n         traj_field::Symbol = :traj,\n         ins_field::Symbol  = :ins_data;\n         flight             = 1,\n         line               = 1,\n         dt                 = 0.1,\n         silent::Bool       = false)\n\nGet the minimum dataset required for MagNav from saved HDF5 or MAT file. Not all fields within the XYZ0 flight data struct are required. The minimum data required in the HDF5 or MAT file includes:\n\nlat, lon, alt (position)\nmag_1_uc OR mag_1_c (scalar magnetometer measurements)\n\nIf an HDF5 file is provided, the possible fields in the file are:\n\nField Type Description\ndt scalar measurement time step [s]\ntt vector time [s]\nlat vector latitude  [deg]\nlon vector longitude [deg]\nalt vector altitude  [m]\nvn vector north velocity [m/s]\nve vector east  velocity [m/s]\nvd vector down  velocity [m/s]\nfn vector north specific force [m/s]\nfe vector east  specific force [m/s]\nfd vector down  specific force [m/s]\nCnb 3x3xN direction cosine matrix (body to navigation) [-]\nroll vector roll [deg]\npitch vector pitch [deg]\nyaw vector yaw [deg]\nins_dt scalar INS measurement time step [s]\nins_tt vector INS time [s]\nins_lat vector INS latitude  [deg]\nins_lon vector INS longitude [deg]\nins_alt vector INS altitude  [m]\nins_vn vector INS north velocity [m/s]\nins_ve vector INS east  velocity [m/s]\nins_vd vector INS down  velocity [m/s]\nins_fn vector INS north specific force [m/s]\nins_fe vector INS east  specific force [m/s]\nins_fd vector INS down  specific force [m/s]\nins_Cnb 3x3xN INS direction cosine matrix (body to navigation) [-]\nins_roll vector INS roll [deg]\nins_pitch vector INS pitch [deg]\nins_yaw vector INS yaw [deg]\nins_P 17x17xN INS covariance matrix, only relevant for simulated data, otherwise zeros [-]\nflux_a_x vector Flux A x-direction magnetic field [nT]\nflux_a_y vector Flux A y-direction magnetic field [nT]\nflux_a_z vector Flux A z-direction magnetic field [nT]\nflux_a_t vector Flux A total magnetic field [nT]\nflight vector flight number(s)\nline vector line number(s), i.e., segments within flight\nmag_1_c vector Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nmag_1_uc vector Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\n\nIf a MAT file is provided, the above fields may also be provided, but the non-INS fields should be within the specified traj_field MAT struct and the INS fields should be within the specified ins_field MAT struct and without ins_ prefixes. This is the standard way the MATLAB-companion outputs data.\n\nArguments:\n\nxyz_file:   path/name of flight data HDF5 or MAT file (.h5 or .mat extension required)\ntraj_field: (optional) trajectory struct field within MAT file to use, not relevant for HDF5 file\nins_field:  (optional) INS struct field within MAT file to use, :none if unavailable, not relevant for HDF5 file\nflight:     (optional) flight number, only used if not in file\nline:       (optional) line number, i.e., segment within flight, only used if not in file\ndt:         (optional) measurement time step [s], only used if not in file\nsilent:     (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ0 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ20","category":"page"},{"location":"data/#MagNav.get_XYZ20","page":"Flight Path & INS Data","title":"MagNav.get_XYZ20","text":"get_XYZ20(xyz_h5::String; tt_sort::Bool=true, silent::Bool=false)\n\nGet XYZ20 flight data from saved HDF5 file. Based on SGL 2020 data fields.\n\nArguments:\n\nxyz_h5:  path/name of flight data HDF5 file (.h5 extension optional)\ntt_sort: (optional) if true, sort data by time (instead of line)\nsilent:  (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ20 flight data struct\n\n\n\n\n\nget_XYZ20(xyz_160_h5::String, xyz_h5::String; silent::Bool=false)\n\nGet 160 Hz (partial) XYZ20 flight data from saved HDF5 file and  combine with 10 Hz XYZ20 flight data from another saved HDF5 file.  Data is time sorted to ensure data is aligned.\n\nArguments:\n\nxyz_160_h5: path/name of 160 Hz flight data HDF5 file (.h5 extension optional)\nxyz_h5:     path/name of 10  Hz flight data HDF5 file (.h5 extension optional)\nsilent:     (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ20 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ","category":"page"},{"location":"data/#MagNav.get_XYZ","page":"Flight Path & INS Data","title":"MagNav.get_XYZ","text":"get_XYZ(flight::Symbol, df_flight::DataFrame; tt_sort::Bool=true,\n        reorient_vec::Bool=false, silent::Bool=false)\n\nGet XYZ flight data from saved HDF5 file via DataFrame lookup.\n\nArguments:\n\nflight:       flight name (e.g., :Flt1001)\ndf_flight:    lookup table (DataFrame) of flight data HDF5 files\ntt_sort:      (optional) if true, sort data by time (instead of line)\nreorient_vec: (optional) if true, align vector magnetometer with body frame\nsilent:       (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/#Create-Flight-Data","page":"Flight Path & INS Data","title":"Create Flight Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"create_XYZ0","category":"page"},{"location":"data/#MagNav.create_XYZ0","page":"Flight Path & INS Data","title":"MagNav.create_XYZ0","text":"create_XYZ0(mapS::Union{MapS,MapSd,MapS3D} = get_map(namad);\n            alt            = 1000,\n            dt             = 0.1,\n            t              = 300,\n            v              = 68,\n            ll1            = (),\n            ll2            = (),\n            N_waves        = 1,\n            flight         = 1,\n            line           = 1,\n            attempts::Int  = 10,\n            mapV::MapV     = get_map(emm720),\n            cor_sigma      = 1.0,\n            cor_tau        = 600.0,\n            cor_var        = 1.0^2,\n            cor_drift      = 0.001,\n            cor_perm_mag   = 5.0,\n            cor_ind_mag    = 5.0,\n            cor_eddy_mag   = 0.5,\n            init_pos_sigma = 3.0,\n            init_alt_sigma = 0.001,\n            init_vel_sigma = 0.01,\n            init_att_sigma = deg2rad(0.01),\n            VRW_sigma      = 0.000238,\n            ARW_sigma      = 0.000000581,\n            baro_sigma     = 1.0,\n            ha_sigma       = 0.001,\n            a_hat_sigma    = 0.01,\n            acc_sigma      = 0.000245,\n            gyro_sigma     = 0.00000000727,\n            fogm_sigma     = 1.0,\n            baro_tau       = 3600.0,\n            acc_tau        = 3600.0,\n            gyro_tau       = 3600.0,\n            fogm_tau       = 600.0,\n            save_h5::Bool  = false,\n            xyz_h5::String = \"xyz_data.h5\")\n\nCreate basic flight data. Assumes constant altitude (2D flight). May create a trajectory that passes over map areas that are missing map data. No required arguments, though many are available to create custom data.\n\nTrajectory Arguments:\n\nmapS:     (optional) MapS, MapSd, or MapS3D scalar magnetic anomaly map struct\nalt:      (optional) altitude  [m]\ndt:       (optional) measurement time step [s]\nt:        (optional) total flight time, ignored if ll2 is set [s]\nv:        (optional) approximate aircraft velocity [m/s]\nll1:      (optional) inital (lat,lon) point [deg]\nll2:      (optional) final  (lat,lon) point [deg]\nN_waves:  (optional) number of sine waves along path\nmapV:     (optional) MapV vector magnetic anomaly map struct\nflight:   (optional) flight number\nline:     (optional) line number, i.e., segment within flight\nattempts: (optional) maximum attempts at creating flight path on mapS\nsave_h5:  (optional) if true, save xyz to xyz_h5\nxyz_h5:   (optional) path/name of flight data HDF5 file to save (.h5 extension optional)\n\nCompensated Measurement Corruption Arguments:\n\ncor_var:        (optional) corruption measurement (white) noise variance [nT^2]\nfogm_sigma:     (optional) FOGM catch-all bias [nT]\nfogm_tau:       (optional) FOGM catch-all time constant [s]\n\nUncompensated Measurement Corruption Arguments:\n\ncor_sigma:      (optional) corruption FOGM catch-all bias [nT]\ncor_tau:        (optional) corruption FOGM catch-all time constant [s]\ncor_var:        (optional) corruption measurement (white) noise variance [nT^2]\ncor_drift:      (optional) corruption measurement linear drift [nT/s]\ncor_perm_mag:   (optional) corruption permanent field TL coef std dev\ncor_ind_mag:    (optional) corruption induced field TL coef std dev\ncor_eddy_mag:   (optional) corruption eddy current TL coef std dev\n\nINS Arguments:\n\ninit_pos_sigma: (optional) initial position uncertainty [m]\ninit_alt_sigma: (optional) initial altitude uncertainty [m]\ninit_vel_sigma: (optional) initial velocity uncertainty [m/s]\ninit_att_sigma: (optional) initial attitude uncertainty [rad]\nVRW_sigma:      (optional) velocity random walk [m/s^2 /sqrt(Hz)]\nARW_sigma:      (optional) angular random walk [rad/s /sqrt(Hz)]\nbaro_sigma:     (optional) barometer bias [m]\nha_sigma:       (optional) barometer aiding altitude bias [m]\na_hat_sigma:    (optional) barometer aiding vertical accel bias [m/s^2]\nacc_sigma:      (optional) accelerometer bias [m/s^2]\ngyro_sigma:     (optional) gyroscope bias [rad/s]\nbaro_tau:       (optional) barometer time constant [s]\nacc_tau:        (optional) accelerometer time constant [s]\ngyro_tau:       (optional) gyroscope time constant [s]\n\nReturns:\n\nxyz: XYZ0 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"nncomp/#NN-Based-Model-Diagrams","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"The goal of neural network-based aeromagnetic compensation is to use machine learning in order to create a nonlinear aeromagnetic compensation model. It may be possible to use additional sensors, beyond a single scalar and vector magnetometer, to improve compensation performance. Shown on this page are diagrams for each of the neural network-based aeromagnetic compensation models available within the package.","category":"page"},{"location":"nncomp/#Model-1","page":"NN-Based Model Diagrams","title":"Model 1","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m1   = standard feedforward neural network (NN)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m1)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"The approach taken here is to include additional data along with the typical magnetometer data. An example of possible data fields is provided in the Appendix of Gnadt, 2022. The idea here is that this additional data allows for greater observability of the aircraft magnetic field, and machine learning can learn the relationship between the data and aircraft field. A baseline model for this approach is to use a standard neural network to represent the compensation model in a pure data-driven approach, as shown above.","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"Here, the input data boldsymboldata_mathrmaux, also known as features, can be raw measurements and/or the Tolles-Lawson boldsymbolA matrix terms. Using the Tolles-Lawson terms is a form of scientific machine learning (SciML), as these terms represent prior scientific knowledge. This can potentially reduce the amount of data required for training. Note that during training, the mean squared error (MSE) of the aeromagnetic compensation output is compared with the output target. During testing (evaluation), the aeromagnetic compensation output just prior to the \"loss MSE\" in the figure is used for navigation.","category":"page"},{"location":"nncomp/#Model-2","page":"NN-Based Model Diagrams","title":"Model 2","text":"","category":"section"},{"location":"nncomp/#Model-2a","page":"NN-Based Model Diagrams","title":"Model 2a","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m2a  = NN determines Tolles-Lawson (TL) coefficients","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m2a)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"Model 1 can be extended into even more of a SciML approach using the physics of aeromagnetic compensation. Model 2a, shown above, more closely resembles the classical Tolles-Lawson model, now with ","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"B_mathrmtarget = boldsymbolAboldsymbolbeta_mathrmNN","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"where B_mathrmtarget is some target magnetic value, boldsymbolA is the Tolles-Lawson boldsymbolA matrix, and boldsymbolbeta_mathrmNN is a vector of varying coefficients.","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"Rather than directly determining some magnetic value, the output of the neural network is instead a set of varying coefficients. These are then multiplied by the Tolles-Lawson boldsymbolA matrix to produce a magnetic value. The general idea here is that this model is easier to train and more interpretable, since the coefficients have meaning related to the permanent, induced, and eddy-current terms in the Tolles-Lawson model. This model uses the same input data boldsymboldata_mathrmaux as previously described, but also separately requires vector magnetometer measurements (B_x, B_y, B_z).","category":"page"},{"location":"nncomp/#Model-2b","page":"NN-Based Model Diagrams","title":"Model 2b","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m2b  = NN determines additive correction to classical TL","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m2b)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"Another SciML approach that uses the physics of aeromagnetic compensation is model 2b, which is shown above. Rather than predicting the Tolles-Lawson coefficients with a neural network, the Tolles-Lawson coefficients for this approach are pre-determined, using any of the classical, modified, or map-based Tolles-Lawson models. Tolles-Lawson aeromagnetic compensation is then carried out, but large errors still remain for compensation of in-cabin magnetometers. An additive correction is then made to the Tolles-Lawson compensated value to further reduce the errors. This additive correction is the output of a neural network, similar to model 1, except now the neural network does not need to learn the Tolles-Lawson (linear) portion of the desired compensation and instead primarily learns the higher-order nonlinear portion.","category":"page"},{"location":"nncomp/#Model-2c","page":"NN-Based Model Diagrams","title":"Model 2c","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m2c  = NN determines additive correction to classical TL, TL coefficients tuned as well","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m2c)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"An immediate extension of model 2b is model 2c, which is shown above. These models look very similar, but there is one key, subtle difference. In model 2c, the Tolles-Lawson coefficients are updated by including them as parameters during training of the neural network, rather leaving them as static values. The Tolles-Lawson coefficients are not actually part of the neural network, but the Flux machine learning library and Julia programming language provide the flexibility to backpropagate the error to the Tolles-Lawson coefficients just as with the weights of the neural network.","category":"page"},{"location":"nncomp/#Model-2d","page":"NN-Based Model Diagrams","title":"Model 2d","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m2d  = NN determines additive correction to each TL coefficient","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m2d)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"Model 2d combines the general idea behind models 2a and 2b. An additive correction is now made to each individual (static) Tolles-Lawson coefficient. This model was developed as it was thought that making the additive correction in a higher dimensional space may improve performance further.","category":"page"},{"location":"nncomp/#Model-3","page":"NN-Based Model Diagrams","title":"Model 3","text":"","category":"section"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":":m3tl = no NN, TL coefficients fine-tuned via SGD, without Taylor expansion for training target\n:m3s  = NN determines scalar correction to TL, using expanded TL vector terms for explainability\n:m3v  = NN determines vector correction to TL, using expanded TL vector terms for explainability\n:m3sc = :m3s with curriculum learning based on TL error\n:m3vc = :m3v with curriculum learning based on TL error","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m3s)","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"The various forms of model 3 use a NN to determine an additive correction to the expanded vector form of Tolles-Lawson. This is the newest model under development. Shown above is the scalar correction version, and shown below is the vector correction version.","category":"page"},{"location":"nncomp/","page":"NN-Based Model Diagrams","title":"NN-Based Model Diagrams","text":"(Image: m3v)","category":"page"},{"location":"#MagNav.jl","page":"MagNav.jl","title":"MagNav.jl","text":"","category":"section"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"MagNav.jl contains a full suite of tools for airborne Magnetic anomaly Navigation (MagNav). This documentation is separated into four main functionalities:","category":"page"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"Pages = [\n    \"data.md\",\n    \"maps.md\",\n    \"comp.md\",\n    \"nav.md\",\n]\nDepth = 1","category":"page"},{"location":"#Version","page":"MagNav.jl","title":"Version","text":"","category":"section"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"VERSION","category":"page"}]
}
