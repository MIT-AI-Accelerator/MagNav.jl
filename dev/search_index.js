var documenterSearchIndex = {"docs":
[{"location":"nav/#Navigation-Algorithms","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"Placeholder page for navigation algorithms documentation.","category":"page"},{"location":"nav/#Cramér–Rao-Lower-Bound","page":"Navigation Algorithms","title":"Cramér–Rao Lower Bound","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"crlb","category":"page"},{"location":"nav/#MagNav.crlb","page":"Navigation Algorithms","title":"MagNav.crlb","text":"crlb(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, dt, itp_mapS;\n     P0         = create_P0(),\n     Qd         = create_Qd(),\n     R          = 1.0,\n     baro_tau   = 3600.0,\n     acc_tau    = 3600.0,\n     gyro_tau   = 3600.0,\n     fogm_tau   = 600.0,\n     date       = 2020+185/366,\n     core::Bool = false)\n\nCramér–Rao lower bound (CRLB) computed with classic Kalman Filter.  Equations evaluated about true trajectory.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\ndt:       measurement time step [s]\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nP_out: non-linear covariance matrix\n\n\n\n\n\ncrlb(traj::Traj, itp_mapS;\n     P0         = create_P0(),\n     Qd         = create_Qd(),\n     R          = 1.0,\n     baro_tau   = 3600.0,\n     acc_tau    = 3600.0,\n     gyro_tau   = 3600.0,\n     fogm_tau   = 600.0,\n     date       = 2020+185/366,\n     core::Bool = false)\n\nCramér–Rao lower bound (CRLB) computed with classic Kalman Filter.  Equations evaluated about true trajectory.\n\nArguments:\n\ntraj:     Traj trajectory struct\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nP_out: non-linear covariance matrix\n\n\n\n\n\n","category":"function"},{"location":"nav/#Extended-Kalman-Filter","page":"Navigation Algorithms","title":"Extended Kalman Filter","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"ekf","category":"page"},{"location":"nav/#MagNav.ekf","page":"Navigation Algorithms","title":"MagNav.ekf","text":"ekf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = 2020+185/366,\n    core::Bool = false,\n    der_mapS   = nothing,\n    map_alt    = 0)\n\nExtended Kalman filter (EKF) for airborne magnetic anomaly navigation.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\nmeas:     scalar magnetometer measurement [nT]\ndt:       measurement time step [s]\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\nder_mapS: (optional) scalar map vertical derivative grid interpolation\nmap_alt:  (optional) map altitude [m]\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\nekf(ins::INS, meas, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = 2020+185/366,\n    core::Bool = false,\n    der_mapS   = map_itp(zeros(2,2),[-pi,pi],[-pi/2,pi/2]),\n    map_alt    = 0)\n\nExtended Kalman filter (EKF) for airborne magnetic anomaly navigation.\n\nArguments:\n\nins:      INS inertial navigation system struct\nmeas:     scalar magnetometer measurement [nT]\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\nder_mapS: (optional) scalar map vertical derivative grid interpolation\nmap_alt:  (optional) map altitude [m]\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\n","category":"function"},{"location":"nav/#Rao-Blackwellized-(Marginalized)-Particle-Filter","page":"Navigation Algorithms","title":"Rao-Blackwellized (Marginalized) Particle Filter","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"mpf","category":"page"},{"location":"nav/#MagNav.mpf","page":"Navigation Algorithms","title":"MagNav.mpf","text":"mpf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    num_part   = 1000,\n    thresh     = 0.8,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = 2020+185/366,\n    core::Bool = false)\n\nRao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic  anomaly navigation. This simplified MPF works only with LINEAR dynamics.  This allows the same Kalman filter covariance matrices to be used with  each particle, simplifying the filter and reducing the computational load.  It is especially suited for map-matching navigation in which there is a  highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics.  The filter also assumes NON-correlated measurements to speed up computation.\n\nArguments:\n\nlat:      latitude  [rad]\nlon:      longitude [rad]\nalt:      altitude  [m]\nvn:       north velocity [m/s]\nve:       east  velocity [m/s]\nvd:       down  velocity [m/s]\nfn:       north specific force [m/s^2]\nfe:       east  specific force [m/s^2]\nfd:       down  specific force [m/s^2]\nCnb:      direction cosine matrix (body to navigation) [-]\nmeas:     scalar magnetometer measurement [nT]\ndt:       measurement time step [s]\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nnum_part: (optional) number of particles\nthresh:   (optional) resampling threshold fraction {0:1}\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\nmpf(ins::INS, meas, itp_mapS;\n    P0         = create_P0(),\n    Qd         = create_Qd(),\n    R          = 1.0,\n    num_part   = 1000,\n    thresh     = 0.8,\n    baro_tau   = 3600.0,\n    acc_tau    = 3600.0,\n    gyro_tau   = 3600.0,\n    fogm_tau   = 600.0,\n    date       = 2020+185/366,\n    core::Bool = false)\n\nRao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic  anomaly navigation. This simplified MPF works only with LINEAR dynamics.  This allows the same Kalman filter covariance matrices to be used with  each particle, simplifying the filter and reducing the computational load.  It is especially suited for map-matching navigation in which there is a  highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics.  The filter also assumes NON-correlated measurements to speed up computation.\n\nArguments:\n\nins:      INS inertial navigation system struct\nmeas:     scalar magnetometer measurement [nT]\nitp_mapS: scalar map grid interpolation\nP0:       (optional) initial covariance matrix\nQd:       (optional) discrete time process/system noise matrix\nR:        (optional) measurement (white) noise variance\nnum_part: (optional) number of particles\nthresh:   (optional) resampling threshold fraction {0:1}\nbaro_tau: (optional) barometer time constant [s]\nacc_tau:  (optional) accelerometer time constant [s]\ngyro_tau: (optional) gyroscope time constant [s]\nfogm_tau: (optional) FOGM catch-all time constant [s]\ndate:     (optional) measurement date for IGRF [yr]\ncore:     (optional) if true, include core magnetic field in measurement\n\nReturns:\n\nfilt_res: FILTres filter results struct\n\n\n\n\n\n","category":"function"},{"location":"nav/#Run-Filter-(with-additional-options)","page":"Navigation Algorithms","title":"Run Filter (with additional options)","text":"","category":"section"},{"location":"nav/","page":"Navigation Algorithms","title":"Navigation Algorithms","text":"run_filt","category":"page"},{"location":"nav/#MagNav.run_filt","page":"Navigation Algorithms","title":"MagNav.run_filt","text":"run_filt(traj::Traj, ins::INS, meas, itp_mapS, filt_type::Symbol = :ekf;\n         P0             = create_P0(),\n         Qd             = create_Qd(),\n         R              = 1.0,\n         num_part       = 1000,\n         thresh         = 0.8,\n         baro_tau       = 3600.0,\n         acc_tau        = 3600.0,\n         gyro_tau       = 3600.0,\n         fogm_tau       = 600.0,\n         date           = 2020+185/366,\n         core::Bool     = false,\n         map_alt        = 0,\n         nn_x           = nothing,\n         m              = nothing,\n         y_norms        = nothing,\n         terms          = [:permanent,:induced,:eddy,:bias],\n         flux::MagV     = MagV([0.0],[0.0],[0.0],[0.0]),\n         x0_TL          = ones(eltype(P0),19),\n         extract::Bool  = true,\n         run_crlb::Bool = true)\n\nRun navigation filter and optionally compute Cramér–Rao lower bound (CRLB).\n\nArguments:\n\ntraj:      Traj trajectory struct\nins:       INS inertial navigation system struct\nmeas:      scalar magnetometer measurement [nT]\nitp_mapS:  scalar map grid interpolation\nfilt_type: (optional) filter type {:ekf,:mpf}\nP0:        (optional) initial covariance matrix\nQd:        (optional) discrete time process/system noise matrix\nR:         (optional) measurement (white) noise variance\nnum_part:  (optional) number of particles (:mpf only)\nthresh:    (optional) resampling threshold fraction {0:1} (:mpf only)\nbaro_tau:  (optional) barometer time constant [s]\nacc_tau:   (optional) accelerometer time constant [s]\ngyro_tau:  (optional) gyroscope time constant [s]\nfogm_tau:  (optional) FOGM catch-all time constant [s]\ndate:      (optional) measurement date for IGRF [yr]\ncore:      (optional) if true, include core magnetic field in measurement\nmap_alt:   (optional) map altitude [m]\nnn_x:      (optional) x matrix for neural network\nm:         (optional) neural network model\ny_norms:   (optional) Tuple of y normalizations, i.e. (y_bias,y_scale)\nterms:     (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nflux:      (optional) MagV vector magnetometer measurement struct\nx0_TL:     (optional) initial Tolles-Lawson coefficient states\nextract:   (optional) if true, extract output structs\nrun_crlb:  (optional) if true, compute the Cramér–Rao lower bound (CRLB)\n\nReturns:\n\nif extract == true  & run_crlb = true\ncrlb_out: CRLBout Cramér–Rao lower bound extracted output struct\nins_out:  INSout  inertial navigation system extracted output struct\nfilt_out: FILTout filter extracted output struct\nif extract == true  & run_crlb = false\nfilt_out: FILTout filter extracted output struct\nif extract == false & run_crlb = true\nfilt_res: FILTres filter results struct\ncrlb_P:   Cramér–Rao lower bound non-linear covariance matrix\nif extract == false & run_crlb = false\nfilt_res: FILTres filter results struct\n\n\n\n\n\nrun_filt(traj::Traj, ins::INS, meas, itp_mapS,\n         filt_type::Vector{Symbol}; ...)\n\nRun multiple filter models and print results (nothing returned.)\n\nArguments:\n\nfilt_type: multiple filter types, e.g. [:ekf,:ekf_online_nn]\n\n\n\n\n\n","category":"function"},{"location":"maps/#Magnetic-Anomaly-Maps","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"Placeholder page for magnetic anomaly maps documentation.","category":"page"},{"location":"maps/#Load-Map-Data","page":"Magnetic Anomaly Maps","title":"Load Map Data","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"get_map","category":"page"},{"location":"maps/#MagNav.get_map","page":"Magnetic Anomaly Maps","title":"MagNav.get_map","text":"get_map(map_file::String; map_units::Symbol=:deg)\n\nGet map data from saved file. Map files are typically saved with :deg units.\n\nArguments:\n\nmap_file:  path/name of magnetic anomaly map HDF5 or MAT file\nmap_units: (optional) map xx/yy units used in HDF5 file {:deg,:rad}\n\nReturns:\n\nmapS or mapV: MapS scalar or MapV vector magnetic anomaly map struct\n\n\n\n\n\nget_map(map_name::Symbol, df_map::DataFrame; map_units::Symbol=:deg)\n\nGet map data from saved file via DataFrame lookup.  Map files are typically saved with :deg units.\n\nArguments:\n\nmap_name:  name of magnetic anomaly map\ndf_map:    lookup table (DataFrame) of map files\nmap_units: (optional) map xx/yy units used in HDF5 file {:deg,:rad}\n\nReturns:\n\nmapS or mapV: MapS scalar or MapV vector magnetic anomaly map struct\n\n\n\n\n\n","category":"function"},{"location":"maps/#Upward-Continue-Map","page":"Magnetic Anomaly Maps","title":"Upward Continue Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"upward_fft","category":"page"},{"location":"maps/#MagNav.upward_fft","page":"Magnetic Anomaly Maps","title":"MagNav.upward_fft","text":"upward_fft(map_map, dx, dy, dz; expand::Bool=true, α=0)\n\nUpward continuation of a potential field (i.e. magnetic anomaly field) map.  Uses the Fast Fourier Transform to convert the map to the frequency domain,  applies an upward continuation filter, and converts back to the spatial domain.  Optionally expands the map temporarily with periodic padding. Downward  continuation can be done to a limited degree as well, but be careful as this  can be unstable and amplify high frequencies (i.e. noise).\n\nReference: Blakely, Potential Theory in Gravity and Magnetic Applications,  2009, Chapter 12 & Appendix B (pg. 315-317 & 402).\n\nArguments\n\nmap_map: ny x nx 2D gridded map data\ndx:      x-direction map sample interval [m]\ndy:      y-direction map sample interval [m]\ndz:      z-direction upward continuation distance [m]\nexpand:  (optional) if true, expand map temporarily to limit edge effects\nα:       (optional) regularization parameter for downward continuation\n\nReturns\n\nmap_out: ny x nx upward continued 2D gridded map data\n\n\n\n\n\nupward_fft(map_map::Union{MapS,MapV}, alt; expand::Bool=true, α=0)\n\nArguments\n\nmap_map: MapS scalar or MapV vector magnetic anomaly map struct\nalt:     target upward continuation altitude [m]\nexpand:  (optional) if true, expand map temporarily to limit edge effects\nα:       (optional) regularization parameter for downward continuation\n\nReturns\n\nmap_out: MapS scalar or MapV vector magnetic anomaly map struct with upward continued map\n\n\n\n\n\n","category":"function"},{"location":"maps/#Interpolate-Map","page":"Magnetic Anomaly Maps","title":"Interpolate Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"map_interpolate","category":"page"},{"location":"maps/#MagNav.map_interpolate","page":"Magnetic Anomaly Maps","title":"MagNav.map_interpolate","text":"map_interpolate(map_map, map_xx, map_yy, type::Symbol = :cubic)\n\nCreate map grid interpolation, equivalent of griddedInterpolant in MATLAB.  Uses the Interpolations package rather than Dierckx or GridInterpolations, as  Interpolations was found to be fastest for MagNav use cases.\n\nArguments:\n\nmap_map: ny x nx 2D gridded map data\nmap_xx:  nx x-direction map coordinates\nmap_yy:  ny y-direction map coordinates\ntype:    (optional) type of interpolation {:linear,:quad,:cubic}\n\nReturns:\n\nitp_map: map grid interpolation\n\n\n\n\n\nmap_interpolate(mapS::MapS, type::Symbol = :cubic; vert::Bool = false)\n\nCreate map grid interpolation, equivalent of griddedInterpolant in MATLAB. Optionally return vertical derivative grid interpolation, which is calculated using finite differences between the map and a slightly upward continued map.\n\nArguments:\n\nmapS: MapS scalar magnetic anomaly map struct\ntype: (optional) type of interpolation {:linear,:quad,:cubic}\nvert: (optional) if true, also return vertical derivative grid interpolation\n\nReturns:\n\nitp_map: map grid interpolation\n\n\n\n\n\nmap_interpolate(mapV::MapV, dim::Symbol = :X, type::Symbol = :cubic)\n\nCreate map grid interpolation, equivalent of griddedInterpolant in MATLAB.\n\nArguments:\n\nmapV: MapV vector magnetic anomaly map struct\ndim:  map dimension to interpolate {:X,:Y,:Z}\ntype: (optional) type of interpolation {:linear,:quad,:cubic}\n\nReturns:\n\nitp_map: map grid interpolation\n\n\n\n\n\n","category":"function"},{"location":"maps/#Plot-Map","page":"Magnetic Anomaly Maps","title":"Plot Map","text":"","category":"section"},{"location":"maps/","page":"Magnetic Anomaly Maps","title":"Magnetic Anomaly Maps","text":"plot_map","category":"page"},{"location":"maps/#MagNav.plot_map","page":"Magnetic Anomaly Maps","title":"MagNav.plot_map","text":"plot_map(map_map::Matrix,\n         map_xx::Vector     = [],\n         map_yy::Vector     = [];\n         clims::Tuple       = (0,0),\n         dpi::Int           = 200,\n         margin::Int        = 2,\n         legend::Bool       = true,\n         axis::Bool         = true,\n         fewer_pts::Bool    = true,\n         map_color::Symbol  = :usgs,\n         bg_color::Symbol   = :white,\n         map_units::Symbol  = :rad,\n         plot_units::Symbol = :deg,\n         b_e                = gr())\n\nPlot map.\n\nArguments:\n\nmap_map:    ny x nx 2D gridded map data\nmap_xx:     nx x-direction (longitude) map coordinates [rad] or [deg]\nmap_yy:     ny y-direction (latitude)  map coordinates [rad] or [deg]\nclims:      (optional) color scale limits\ndpi:        (optional) dots per inch (image resolution)\nmargin:     (optional) margin around plot [mm]\nlegend:     (optional) if true, show legend\naxis:       (optional) if true, show axes\nfewer_pts:  (optional) if true, reduce number of data points plotted\nmap_color:  (optional) filled contour color scheme {:usgs,:gray,:gray1,:gray2,:plasma,:magma}\nbg_color:   (optional) background color\nmap_units:  (optional) map  xx/yy units {:rad,:deg}\nplot_units: (optional) plot xx/yy units {:rad,:deg,:m}\nb_e:        (optional) plotting backend\n\nReturns:\n\np1: plot with map\n\n\n\n\n\nplot_map(mapS::Union{MapS,MapSd};\n         clims::Tuple       = (0,0),\n         dpi::Int           = 200,\n         margin::Int        = 2,\n         legend::Bool       = true,\n         axis::Bool         = true,\n         fewer_pts::Bool    = true,\n         map_color::Symbol  = :usgs,\n         bg_color::Symbol   = :white,\n         map_units::Symbol  = :rad,\n         plot_units::Symbol = :deg,\n         b_e                = gr())\n\nPlot map.\n\nArguments:\n\nmapS:       MapS or MapSd scalar magnetic anomaly map struct\nclims:      (optional) color scale limits\ndpi:        (optional) dots per inch (image resolution)\nmargin:     (optional) margin around plot [mm]\nlegend:     (optional) if true, show legend\naxis:       (optional) if true, show axes\nfewer_pts:  (optional) if true, reduce number of data points plotted\nmap_color:  (optional) filled contour color scheme {:usgs,:gray,:gray1,:gray2,:plasma,:magma}\nbg_color:   (optional) background color\nmap_units:  (optional) map  xx/yy units {:rad,:deg}\nplot_units: (optional) plot xx/yy units {:rad,:deg,:m}\nb_e:        (optional) plotting backend\n\nReturns:\n\np1: plot with map\n\n\n\n\n\n","category":"function"},{"location":"comp/#Aeromagnetic-Compensation","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"Placeholder page for aeromagnetic compensation documentation.","category":"page"},{"location":"comp/#Tolles-Lawson","page":"Aeromagnetic Compensation","title":"Tolles-Lawson","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"create_TL_A","category":"page"},{"location":"comp/#MagNav.create_TL_A","page":"Aeromagnetic Compensation","title":"MagNav.create_TL_A","text":"create_TL_A(Bx, By, Bz;\n            Bt       = sqrt.(Bx.^2+By.^2+Bz.^2),\n            terms    = [:permanent,:induced,:eddy],\n            Bt_scale = 50000)\n\nCreate Tolles-Lawson A matrix using vector magnetometer measurements.\n\nArguments:\n\nBx,By,Bz: vector magnetometer measurements [nT]\nBt:       (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nterms:    (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nBt_scale: (optional) scaling factor for induced and eddy current terms [nT]\n\nReturns:\n\nA: Tolles-Lawson A matrix\n\n\n\n\n\ncreate_TL_A(flux::MagV, ind=trues(length(flux.x));\n            Bt       = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],\n            terms    = [:permanent,:induced,:eddy],\n            Bt_scale = 50000)\n\nCreate Tolles-Lawson A matrix using vector magnetometer measurements.\n\nArguments:\n\nflux:     MagV vector magnetometer measurement struct\nind:      (optional) selected data indices\nBt:       (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nterms:    (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\nBt_scale: (optional) scaling factor for induced and eddy current terms [nT]\n\nReturns:\n\nA: Tolles-Lawson A matrix\n\n\n\n\n\n","category":"function"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"create_TL_coef","category":"page"},{"location":"comp/#MagNav.create_TL_coef","page":"Aeromagnetic Compensation","title":"MagNav.create_TL_coef","text":"create_TL_coef(Bx, By, Bz, B;\n               Bt         = sqrt.(Bx.^2+By.^2+Bz.^2),\n               λ          = 0,\n               terms      = [:permanent,:induced,:eddy],\n               pass1      = 0.1,\n               pass2      = 0.9,\n               fs         = 10.0,\n               pole::Int  = 4,\n               trim::Int  = 20,\n               Bt_scale   = 50000,\n               return_var = false)\n\nCreate Tolles-Lawson coefficients using vector and scalar magnetometer  measurements and a bandpass, low-pass or high-pass filter.\n\nArguments:\n\nBx,By,Bz:   vector magnetometer measurements [nT]\nB:          scalar magnetometer measurements [nT]\nBt:         (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nλ:          (optional) ridge parameter\nterms:      (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\npass1:      (optional) first passband frequency [Hz]\npass2:      (optional) second passband frequency [Hz]\nfs:         (optional) sampling frequency [Hz]\npole:       (optional) number of poles for Butterworth filter\ntrim        (optional) number of elements to trim after filtering\nBt_scale:   (optional) scaling factor for induced and eddy current terms [nT]\nreturn_var: (optional) return B_var fit error variance along with coef\n\nReturns:\n\ncoef:  Tolles-Lawson coefficients\nB_var: if return_var=true, also return fit error variance\n\n\n\n\n\ncreate_TL_coef(flux::MagV, B, ind=trues(length(flux.x));\n               Bt         = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],\n               λ          = 0,\n               terms      = [:permanent,:induced,:eddy],\n               pass1      = 0.1,\n               pass2      = 0.9,\n               fs         = 10.0,\n               pole::Int  = 4,\n               trim::Int  = 20,\n               Bt_scale   = 50000,\n               return_var = false)\n\nCreate Tolles-Lawson coefficients using vector and scalar magnetometer  measurements and a bandpass, low-pass or high-pass filter.\n\nArguments:\n\nflux:       MagV vector magnetometer measurement struct\nB:          scalar magnetometer measurements [nT]\nind:        (optional) selected data indices\nBt:         (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]\nλ:          (optional) ridge parameter\nterms:      (optional) Tolles-Lawson terms to use {:permanent,:induced,:eddy,:bias}\npass1:      (optional) first passband frequency [Hz]\npass2:      (optional) second passband frequency [Hz]\nfs:         (optional) sampling frequency [Hz]\npole:       (optional) number of poles for Butterworth filter\ntrim        (optional) number of elements to trim after filtering\nBt_scale:   (optional) scaling factor for induced and eddy current terms [nT]\nreturn_var: (optional) return B_var fit error variance along with coef\n\nReturns:\n\ncoef:  Tolles-Lawson coefficients\nB_var: fit error variance\n\n\n\n\n\n","category":"function"},{"location":"comp/#Linear-Model-Parameters","page":"Aeromagnetic Compensation","title":"Linear Model Parameters","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"LinCompParams","category":"page"},{"location":"comp/#MagNav.LinCompParams","page":"Aeromagnetic Compensation","title":"MagNav.LinCompParams","text":"struct LinCompParams <: CompParams\n\nLinear aeromagnetic compensation parameters struct. Subtype of CompParams.\n\nTo see default parameters, type LinCompParams().\n\nGeneral Parameters:\n\nParameter Description\nfeatures_setup list of features to include\nfeatures_no_norm list of features to not normalize\nmodel_type aeromagnetic compensation model type (see below)\ny_type y target type (see below)\nuse_mag scalar magnetometer to use {:mag_1_uc, etc.}, only used for y_type = :c, :d, :e\nuse_vec vector magnetometer (fluxgate) to use for Tolles-Lawson A matrix {:flux_a, etc.}, not used for model_type = :elasticnet, :plsr\ndata_norms Tuple of data normalizations, e.g. (A_bias,A_scale,x_bias,x_scale,y_bias,y_scale)\nweights linear model coefficients\nterms Tolles-Lawson terms to use for Tolles-Lawson A matrix (or matrices) within x matrix {:permanent,:induced,:eddy}\nterms_A Tolles-Lawson terms to use for \"external\" Tolles-Lawson A matrix {:permanent,:induced,:eddy,:bias}, not used for model_type = :elasticnet, :plsr\nsub_diurnal if true, subtract diurnal from scalar magnetometer measurements\nsub_igrf if true, subtract IGRF from scalar magnetometer measurements\nbpf_mag if true, bpf scalar magnetometer measurements in x matrix\nnorm_type_A normalization for Tolles-Lawson A matrix, not used for model_type = :elasticnet, :plsr (see below)\nnorm_type_x normalization for x matrix (see below)\nnorm_type_y normalization for y target vector (see below)\n\nmodel_type options:\n:TL         = classical Tolles-Lawson\n:mod_TL     = modified  Tolles-Lawson\n:map_TL     = map-based Tolles-Lawson\n:elasticnet = elastic net (ridge regression and/or Lasso)\n:plsr:      = partial least squares regression (PLSR)\ny_type options:\n:a = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements\n:b = anomaly field  #2, interpolated magnetic anomaly map values\n:c = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated magnetic anomaly map values\n:d = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements\n:e = BPF'd total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements\nnorm_type options:\n:standardize = Z-score normalization\n:normalize   = min-max normalization\n:scale       = scale by maximum absolute value, bias = 0\n:none        = scale by 1, bias = 0\n\nLinear Model-Specific Parameters:\n\nParameter Description\nk_plsr number of components, only used for model_type = :plsr\nλ_TL ridge parameter, only used for model_type = :TL, :mod_TL, :map_TL\n\n\n\n\n\n","category":"type"},{"location":"comp/#Neural-Network-Model-Parameters","page":"Aeromagnetic Compensation","title":"Neural Network Model Parameters","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"NNCompParams","category":"page"},{"location":"comp/#MagNav.NNCompParams","page":"Aeromagnetic Compensation","title":"MagNav.NNCompParams","text":"struct NNCompParams <: CompParams\n\nNeural network-based aeromagnetic compensation parameters struct.  Subtype of CompParams.\n\nTo see default parameters, type NNCompParams().\n\nGeneral Parameters:\n\nParameter Description\nfeatures_setup list of features to include\nfeatures_no_norm list of features to not normalize\nmodel_type aeromagnetic compensation model type (see below)\ny_type y target type (see below)\nuse_mag scalar magnetometer to use {:mag_1_uc, etc.}, only used for y_type = :c, :d, :e\nuse_vec vector magnetometer (fluxgate) to use for Tolles-Lawson A matrix {:flux_a, etc.}, not used for model_type = :m1\ndata_norms Tuple of data normalizations, e.g. (A_bias,A_scale,v_scale,x_bias,x_scale,y_bias,y_scale)\nweights neural network model weights\nterms Tolles-Lawson terms to use for Tolles-Lawson A matrix (or matrices) within x matrix {:permanent,:induced,:eddy}\nterms_A Tolles-Lawson terms to use for \"external\" Tolles-Lawson A matrix {:permanent,:induced,:eddy,:bias}, not used for model_type = :m1\nsub_diurnal if true, subtract diurnal from scalar magnetometer measurements\nsub_igrf if true, subtract IGRF from scalar magnetometer measurements\nbpf_mag if true, bpf scalar magnetometer measurements in x matrix\nnorm_type_A normalization for Tolles-Lawson A matrix, not used for model_type = :m1 (see below)\nnorm_type_x normalization for x matrix (see below)\nnorm_type_y normalization for y target vector (see below)\n\nmodel_type options:\n:m1  = standard NN\n:m2a = NN determines Tolles-Lawson coefficients\n:m2b = NN determines additive correction to classical Tolles-Lawson\n:m2c = NN determines additive correction to classical Tolles-Lawson, Tolles-Lawson coefficients tuned as well\n:m2d = NN determines additive correction to each Tolles-Lawson coefficient\ny_type options:\n:a = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements\n:b = anomaly field  #2, interpolated magnetic anomaly map values\n:c = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated magnetic anomaly map values\n:d = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements\n:e = BPF'd total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements\nnorm_type options:\n:standardize = Z-score normalization\n:normalize   = min-max normalization\n:scale       = scale by maximum absolute value, bias = 0\n:none        = scale by 1, bias = 0\n\nNeural Network-Based Model-Specific Parameters:\n\nParameter Description\nTL_coef Tolles-Lawson coefficients, only used for model_type = :m2b, :m2d (and :m2c initial TL_coef)\nη_adam learning rate for Adam optimizer\nepoch_adam number of epochs for Adam optimizer\nepoch_lbfgs number of epochs for LBFGS optimizer\nhidden hidden layers & nodes, e.g. [8,8] for 2 hidden layers, 8 nodes each\nactivation activation function (see below)\nbatchsize mini-batch size\nfrac_train fraction of training data used for training (remainder for validation), only used for Adam optimizer\nα_sgl Lasso (α_sgl=0) vs group Lasso (α_sgl=1) balancing parameter {0:1}\nλ_sgl sparse group Lasso parameter, typically ~1e-5 (if nonzero)\nk_pca number of components for pre-processing with PCA + whitening, -1 to ignore\ndrop_fi if true, perform drop-column feature importance\ndrop_fi_bson file name (without extension) to save/load drop-column feature importance data\ndrop_fi_csv file name to save drop-column feature importance data\nperm_fi if true, perform permutation feature importance\nperm_fi_csv file name to save permutation feature importance data\n\nactivation options:\nrelu  = rectified linear unit\nσ     = sigmoid (logistic function)\nswish = self-gated\ntanh  = hyperbolic tan\nrun plot_activation() for a visual\n\n\n\n\n\n","category":"type"},{"location":"comp/#Model-Training/Fitting","page":"Aeromagnetic Compensation","title":"Model Training/Fitting","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"comp_train","category":"page"},{"location":"comp/#MagNav.comp_train","page":"Aeromagnetic Compensation","title":"MagNav.comp_train","text":"comp_train(xyz::XYZ, ind, mapS::MapS=MapS(zeros(1,1),[0.0],[0.0],0.0);\n           comp_params::CompParams=NNCompParams(), silent::Bool=true)\n\nTrain an aeromagnetic compensation model.\n\nArguments:\n\nxyz:         XYZ flight data struct\nind:         selected data indices\nmapS:        (optional) MapS scalar magnetic anomaly map struct, only used for y_type = :b, :c\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent       (optional) if true, no print outs\n\nReturns:\n\ncomp_params: CompParams aeromagnetic compensation parameters struct\ny:           observed data\ny_hat:       predicted data\nerr:         compensation error\n\n\n\n\n\ncomp_train(lines, df_line::DataFrame, df_flight::DataFrame,\n           df_map::DataFrame, comp_params::CompParams=NNCompParams();\n           silent::Bool=true)\n\nTrain an aeromagnetic compensation model.\n\nArguments:\n\nlines:       selected line number(s)\ndf_line:     lookup table (DataFrame) of lines\ndf_flight:   lookup table (DataFrame) of flight files\ndf_map:      lookup table (DataFrame) of map files\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent       (optional) if true, no print outs\n\nReturns:\n\ncomp_params: CompParams aeromagnetic compensation parameters struct\ny:           observed data\ny_hat:       predicted data\nerr:         mean-corrected (per line) compensation error\n\n\n\n\n\n","category":"function"},{"location":"comp/#Model-Testing","page":"Aeromagnetic Compensation","title":"Model Testing","text":"","category":"section"},{"location":"comp/","page":"Aeromagnetic Compensation","title":"Aeromagnetic Compensation","text":"comp_test","category":"page"},{"location":"comp/#MagNav.comp_test","page":"Aeromagnetic Compensation","title":"MagNav.comp_test","text":"comp_test(xyz::XYZ, ind, mapS::MapS=MapS(zeros(1,1),[0.0],[0.0],0.0);\n          comp_params::CompParams=NNCompParams(), silent::Bool=false)\n\nEvaluate aeromagnetic compensation model performance.\n\nArguments:\n\nxyz:  XYZ flight data struct\nind:  selected data indices\nmapS: (optional) MapS scalar magnetic anomaly map struct, only used for y_type = :b, :c\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent       (optional) if true, no print outs\n\nReturns:\n\ny:     observed data\ny_hat: predicted data\nerr:   compensation error\n\n\n\n\n\ncomp_test(lines, df_line::DataFrame, df_flight::DataFrame,\n          df_map::DataFrame, comp_params::CompParams=NNCompParams();\n          silent::Bool=false)\n\nEvaluate aeromagnetic compensation model performance.\n\nArguments:\n\nlines:       selected line number(s)\ndf_line:     lookup table (DataFrame) of lines\ndf_flight:   lookup table (DataFrame) of flight files\ndf_map:      lookup table (DataFrame) of map files\ncomp_params: CompParams aeromagnetic compensation parameters struct\ncomp_params: CompParams aeromagnetic compensation parameters struct, either:\nNNCompParams:  neural network-based aeromagnetic compensation parameters struct\nLinCompParams: linear aeromagnetic compensation parameters struct\nsilent       (optional) if true, no print outs\n\nReturns:\n\ny:     observed data\ny_hat: predicted data\nerr:   mean-corrected (per line) compensation error\n\n\n\n\n\n","category":"function"},{"location":"data/#Flight-Path-and-INS-Data","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"Placeholder page for flight path & INS data documentation.","category":"page"},{"location":"data/#Load-Flight-Data","page":"Flight Path & INS Data","title":"Load Flight Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ0","category":"page"},{"location":"data/#MagNav.get_XYZ0","page":"Flight Path & INS Data","title":"MagNav.get_XYZ0","text":"get_XYZ0(xyz_file::String,\n         traj_field::Symbol = :traj,\n         ins_field::Symbol  = :ins_data;\n         flight             = 1,\n         line               = 1,\n         dt                 = 0.1,\n         silent::Bool       = false)\n\nGet the minimum dataset required for MagNav from saved HDF5 or MAT file.  Not all fields within the XYZ0 flight data struct are required. The minimum  data required in the HDF5 or MAT file includes: \n\nlat, lon, alt (position)\nmag_1_uc OR mag_1_c (scalar magnetometer measurements)\n\nIf an HDF5 file is provided, the possible fields in the file are: \n\nField Type Description\ndt scalar measurement time step [s]\ntt vector time [s]\nlat vector latitude  [deg]\nlon vector longitude [deg]\nalt vector altitude  [m]\nvn vector north velocity [m/s]\nve vector east  velocity [m/s]\nvd vector down  velocity [m/s]\nfn vector north specific force [m/s]\nfe vector east  specific force [m/s]\nfd vector down  specific force [m/s]\nCnb 3x3xN direction cosine matrix (body to navigation) [-]\nroll vector roll [deg]\npitch vector pitch [deg]\nyaw vector yaw [deg]\nflux_a_x vector x-direction magnetic field [nT]\nflux_a_y vector y-direction magnetic field [nT]\nflux_a_z vector z-direction magnetic field [nT]\nflux_a_t vector total magnetic field [nT]\nmag_1_uc vector Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]\nmag_1_c vector Mag 1 compensated (clean) scalar magnetometer measurements [nT]\nflight vector flight number(s)\nline vector line number(s), i.e. segments within flight\nins_dt scalar INS measurement time step [s]\nins_tt vector INS time [s]\nins_lat vector INS latitude  [deg]\nins_lon vector INS longitude [deg]\nins_alt vector INS altitude  [m]\nins_vn vector INS north velocity [m/s]\nins_ve vector INS east  velocity [m/s]\nins_vd vector INS down  velocity [m/s]\nins_fn vector INS north specific force [m/s]\nins_fe vector INS east  specific force [m/s]\nins_fd vector INS down  specific force [m/s]\nins_Cnb 3x3xN INS direction cosine matrix (body to navigation) [-]\nins_roll vector INS roll [deg]\nins_pitch vector INS pitch [deg]\nins_yaw vector INS yaw [deg]\nins_P 17x17xN INS covariance matrix, only relevant for simulated data, otherwise zeros [-]\n\nIf a MAT file is provided, the above fields may also be provided, but the  non-INS fields should be within a traj_field struct and the INS fields should  be within an ins_field struct and without ins_ prefixes. This is the  standard way the MATLAB-companion produces data.\n\nArguments:\n\nxyz_file:   path/name of HDF5 or MAT file containing flight data\ntraj_field: (optional) trajectory struct field within MAT file to use, not relevant for HDF5 file\nins_field:  (optional) INS struct field within MAT file to use, :none if unavailable, not relevant for HDF5 file\nflight:     (optional) flight number, only used if not in file\nline:       (optional) line number, i.e. segment within flight, only used if not in file\ndt:         (optional) measurement time step [s], only used if not in file\nsilent:     (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ0 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ20","category":"page"},{"location":"data/#MagNav.get_XYZ20","page":"Flight Path & INS Data","title":"MagNav.get_XYZ20","text":"get_XYZ20(xyz_h5::String; tt_sort::Bool=true, silent::Bool=false)\n\nGet XYZ20 flight data from saved HDF5 file. Based on SGL 2020 data fields.\n\nArguments:\n\nxyz_h5:  path/name of HDF5 file containing flight data\ntt_sort: (optional) if true, sort data by time (instead of line)\nsilent:  (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ20 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"get_XYZ","category":"page"},{"location":"data/#MagNav.get_XYZ","page":"Flight Path & INS Data","title":"MagNav.get_XYZ","text":"get_XYZ(flight::Symbol, df_flight::DataFrame;\n        tt_sort::Bool=true, silent::Bool=false)\n\nGet XYZ flight data from saved HDF5 file via DataFrame lookup.\n\nArguments:\n\nflight: name of flight data\ndf_flight: lookup table (DataFrame) of flight files\ntt_sort: (optional) if true, sort data by time (instead of line)\nsilent:  (optional) if true, no print outs\n\nReturns:\n\nxyz: XYZ flight data struct\n\n\n\n\n\n","category":"function"},{"location":"data/#Create-Flight-Data","page":"Flight Path & INS Data","title":"Create Flight Data","text":"","category":"section"},{"location":"data/","page":"Flight Path & INS Data","title":"Flight Path & INS Data","text":"create_XYZ0","category":"page"},{"location":"data/#MagNav.create_XYZ0","page":"Flight Path & INS Data","title":"MagNav.create_XYZ0","text":"create_XYZ0(mapS::MapS=get_map(namad);\n            alt = 395,\n            dt  = 0.1,\n            t   = 300,\n            v   = 68,\n            ll1 = (),\n            ll2 = (),\n            N_waves        = 1,\n            flight         = 1,\n            line           = 1,\n            attempts::Int  = 10,\n            mapV::MapV     = get_map(emm720),\n            cor_sigma      = 1.0,\n            cor_tau        = 600.0,\n            cor_var        = 1.0^2,\n            cor_drift      = 0.001,\n            cor_perm_mag   = 5.0,\n            cor_ind_mag    = 5.0,\n            cor_eddy_mag   = 0.5,\n            init_pos_sigma = 3.0,\n            init_alt_sigma = 0.001,\n            init_vel_sigma = 0.01,\n            init_att_sigma = deg2rad(0.01),\n            VRW_sigma      = 0.000238,\n            ARW_sigma      = 0.000000581,\n            baro_sigma     = 1.0,\n            ha_sigma       = 0.001,\n            a_hat_sigma    = 0.01,\n            acc_sigma      = 0.000245,\n            gyro_sigma     = 0.00000000727,\n            fogm_sigma     = 1.0,\n            baro_tau       = 3600.0,\n            acc_tau        = 3600.0,\n            gyro_tau       = 3600.0,\n            fogm_tau       = 600.0,\n            save_h5::Bool  = false,\n            xyz_h5::String = \"xyz_data.h5\")\n\nCreate basic flight data. Assumes constant altitude (2D flight).  May create a trajectory that passes over map regions without magnetic data.  No required arguments, though many are available to create custom data.\n\nTrajectory Arguments:\n\nmapS:     (optional) MapS scalar magnetic anomaly map struct\nalt:      (optional) altitude  [m]\ndt:       (optional) measurement time step [s]\nt:        (optional) total flight time, ignored if ll2 is set [s]\nv:        (optional) approximate aircraft velocity [m/s]\nll1:      (optional) inital (lat,lon) point [deg]\nll2:      (optional) final  (lat,lon) point [deg]\nN_waves:  (optional) number of sine waves along path\nmapV:     (optional) MapV vector magnetic anomaly map struct\nflight:   (optional) flight number\nline:     (optional) line number, i.e. segment within flight\nattempts: (optional) maximum attempts at creating flight path on mapS\nsave_h5:  (optional) if true, save HDF5 file xyz_h5\nxyz_h5:   (optional) path/name of HDF5 file to save with flight data\n\nCompensated Measurement Corruption Arguments:\n\ncor_var:        (optional) corruption measurement (white) noise variance [nT^2]\nfogm_sigma:     (optional) FOGM catch-all bias [nT]\nfogm_tau:       (optional) FOGM catch-all time constant [s]\n\nUncompensated Measurement Corruption Arguments:\n\ncor_sigma:      (optional) corruption FOGM catch-all bias [nT]\ncor_tau:        (optional) corruption FOGM catch-all time constant [s]\ncor_var:        (optional) corruption measurement (white) noise variance [nT^2]\ncor_drift:      (optional) corruption measurement linear drift [nT/s]\ncor_perm_mag:   (optional) corruption permanent field TL coef std dev\ncor_ind_mag:    (optional) corruption induced field TL coef std dev\ncor_eddy_mag:   (optional) corruption eddy current TL coef std dev\n\nINS Arguments:\n\ninit_pos_sigma: (optional) initial position uncertainty [m]\ninit_alt_sigma: (optional) initial altitude uncertainty [m]\ninit_vel_sigma: (optional) initial velocity uncertainty [m/s]\ninit_att_sigma: (optional) initial attitude uncertainty [rad]\nVRW_sigma:      (optional) velocity random walk [m/s^2 /sqrt(Hz)]\nARW_sigma:      (optional) angular random walk [rad/s /sqrt(Hz)]\nbaro_sigma:     (optional) barometer bias [m]\nha_sigma:       (optional) barometer aiding altitude bias [m]\na_hat_sigma:    (optional) barometer aiding vertical accel bias [m/s^2]\nacc_sigma:      (optional) accelerometer bias [m/s^2]\ngyro_sigma:     (optional) gyroscope bias [rad/s]\nbaro_tau:       (optional) barometer time constant [s]\nacc_tau:        (optional) accelerometer time constant [s]\ngyro_tau:       (optional) gyroscope time constant [s]\n\nReturns:\n\nxyz: XYZ0 flight data struct\n\n\n\n\n\n","category":"function"},{"location":"#MagNav.jl","page":"MagNav.jl","title":"MagNav.jl","text":"","category":"section"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"MagNav.jl contains a full suite of tools for airborne Magnetic anomaly Navigation (MagNav). This documentation is separated into four main functionalities:","category":"page"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"Pages = [\n    \"data.md\",\n    \"maps.md\",\n    \"comp.md\",\n    \"nav.md\",\n]\nDepth = 1","category":"page"},{"location":"#Version","page":"MagNav.jl","title":"Version","text":"","category":"section"},{"location":"","page":"MagNav.jl","title":"MagNav.jl","text":"VERSION","category":"page"}]
}
