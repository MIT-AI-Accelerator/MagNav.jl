<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API: Functions · MagNav.jl</title><meta name="title" content="API: Functions · MagNav.jl"/><meta property="og:title" content="API: Functions · MagNav.jl"/><meta property="twitter:title" content="API: Functions · MagNav.jl"/><meta name="description" content="Documentation for MagNav.jl."/><meta property="og:description" content="Documentation for MagNav.jl."/><meta property="twitter:description" content="Documentation for MagNav.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MagNav.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MagNav.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API: Functions</a></li><li><a class="tocitem" href="../api_structs/">API: Structs</a></li><li><a class="tocitem" href="../data/">Flight Path &amp; INS Data</a></li><li><a class="tocitem" href="../maps/">Magnetic Anomaly Maps</a></li><li><a class="tocitem" href="../comp/">Aeromagnetic Compensation</a></li><li><a class="tocitem" href="../nncomp/">NN-Based Model Diagrams</a></li><li><a class="tocitem" href="../nav/">Navigation Algorithms</a></li><li><span class="tocitem">Example Pluto Notebooks</span><ul><li><a class="tocitem" href="../examples/pluto_fi/">Feature Importance</a></li><li><a class="tocitem" href="../examples/pluto_linear/">Linear Models</a></li><li><a class="tocitem" href="../examples/pluto_maps/">Magnetic Anomaly Maps</a></li><li><a class="tocitem" href="../examples/pluto_model3/">Model 3</a></li><li><a class="tocitem" href="../examples/pluto_sgl/">Using SGL Data</a></li><li><a class="tocitem" href="../examples/pluto_sim/">Using Simulated Data</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API: Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API: Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MIT-AI-Accelerator/MagNav.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/master/docs/src/api_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API:-Functions"><a class="docs-heading-anchor" href="#API:-Functions">API: Functions</a><a id="API:-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Functions" title="Permalink"></a></h1><p>The following is a full listing of the public functions within the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.TL_mat2vec-NTuple{4, Any}" href="#MagNav.TL_mat2vec-NTuple{4, Any}"><code>MagNav.TL_mat2vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TL_mat2vec(TL_coef_p, TL_coef_i, TL_coef_e, terms; Bt_scale = 50000f0)</code></pre><p>Extract the vector form of Tolles-Lawson coefficients from the matrix form.</p><p><strong>Arguments:</strong></p><ul><li><code>TL_coef_p</code>: length-<code>3</code> vector of permanent field coefficients</li><li><code>TL_coef_i</code>: <code>3</code> x <code>3</code>  symmetric matrix of induced field coefficients, denormalized</li><li><code>TL_coef_e</code>: <code>3</code> x <code>3</code>  matrix of eddy current coefficients, denormalized</li><li><code>terms</code>:     Tolles-Lawson terms used {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>}</li><li><code>Bt_scale</code>:  (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>TL_coef</code>: Tolles-Lawson coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L837-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.TL_vec2mat-Tuple{Vector, Any}" href="#MagNav.TL_vec2mat-Tuple{Vector, Any}"><code>MagNav.TL_vec2mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TL_vec2mat(TL_coef::Vector, terms; Bt_scale = 50000f0)</code></pre><p>Extract the matrix form of Tolles-Lawson coefficients from the vector form.</p><p><strong>Arguments:</strong></p><ul><li><code>TL_coef</code>:  Tolles-Lawson coefficients (must include <code>:permanent</code> &amp; <code>:induced</code>)</li><li><code>terms</code>:    Tolles-Lawson terms used {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>}</li><li><code>Bt_scale</code>: (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>TL_coef_p</code>: length-<code>3</code> vector of permanent field coefficients</li><li><code>TL_coef_i</code>: <code>3</code> x <code>3</code>  symmetric matrix of induced field coefficients, denormalized</li><li><code>TL_coef_e</code>: <code>3</code> x <code>3</code>  matrix of eddy current coefficients, denormalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L778-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.bpf_data!-Tuple{AbstractVecOrMat}" href="#MagNav.bpf_data!-Tuple{AbstractVecOrMat}"><code>MagNav.bpf_data!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bpf_data!(x::AbstractVecOrMat; bpf=get_bpf())</code></pre><p>Bandpass (or low-pass or high-pass) filter vector or columns of matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:   data vector or matrix</li><li><code>bpf</code>: (optional) filter object</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>x</code> is mutated with filtered data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.bpf_data-Tuple{AbstractMatrix}" href="#MagNav.bpf_data-Tuple{AbstractMatrix}"><code>MagNav.bpf_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bpf_data(x::AbstractMatrix; bpf=get_bpf())</code></pre><p>Bandpass (or low-pass or high-pass) filter columns of matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:   data matrix (e.g., Tolles-Lawson <code>A</code> matrix)</li><li><code>bpf</code>: (optional) filter object</li></ul><p><strong>Returns:</strong></p><ul><li><code>x_f</code>: data matrix, filtered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.bpf_data-Tuple{AbstractVector}" href="#MagNav.bpf_data-Tuple{AbstractVector}"><code>MagNav.bpf_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bpf_data(x::AbstractVector; bpf=get_bpf())</code></pre><p>Bandpass (or low-pass or high-pass) filter vector.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:   data vector (e.g., magnetometer measurements)</li><li><code>bpf</code>: (optional) filter object</li></ul><p><strong>Returns:</strong></p><ul><li><code>x_f</code>: data vector, filtered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L177-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.chunk_data-Tuple{Any, Any, Int64}" href="#MagNav.chunk_data-Tuple{Any, Any, Int64}"><code>MagNav.chunk_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chunk_data(x, y, l_window::Int)</code></pre><p>Break data into non-overlapping sequences (vectors).</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:        length-<code>N</code> target vector</li><li><code>l_window</code>: temporal window length</li></ul><p><strong>Returns:</strong></p><ul><li><code>x_seqs</code>: sequence (vector) of <code>Nf</code> x <code>l_window</code> data matrices</li><li><code>y_seqs</code>: sequence (vector) of length-<code>l_window</code> target vectors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1781-L1794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_m2bc_test-Tuple{NNCompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.comp_m2bc_test-Tuple{NNCompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.comp_m2bc_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_m2bc_test(comp_params::NNCompParams, lines,
               df_line::DataFrame, df_flight::DataFrame, df_map::DataFrame;
               silent::Bool = false)</code></pre><p>Evaluate performance of neural network-based aeromagnetic compensation, model 2b or 2c with additional outputs for explainability.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>NNCompParams</code> neural network-based aeromagnetic compensation parameters struct</li><li><code>lines</code>:       selected line number(s)</li><li><code>df_line</code>:     lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>silent</code>: (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_nn</code>:     length-<code>N</code> neural network compensation portion</li><li><code>y_TL</code>:     length-<code>N</code> Tolles-Lawson  compensation portion</li><li><code>y</code>:        length-<code>N</code> target vector</li><li><code>y_hat</code>:    length-<code>N</code> prediction vector</li><li><code>err</code>:      length-<code>N</code> mean-corrected (per line) compensation error</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L3814-L3854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_m3_test-Tuple{NNCompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.comp_m3_test-Tuple{NNCompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.comp_m3_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_m3_test(comp_params::NNCompParams, lines,
             df_line::DataFrame, df_flight::DataFrame, df_map::DataFrame;
             temp_params::TempParams = TempParams(),
             silent::Bool            = false)</code></pre><p>Evaluate performance of neural network-based aeromagnetic compensation, model 3 with additional outputs for explainability.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>NNCompParams</code> neural network-based aeromagnetic compensation parameters struct</li><li><code>lines</code>:       selected line number(s)</li><li><code>df_line</code>:     lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>TL_perm</code>:      <code>3</code> x <code>N</code> matrix of TL permanent vector field</li><li><code>TL_induced</code>:   <code>3</code> x <code>N</code> matrix of TL induced vector field</li><li><code>TL_eddy</code>:      <code>3</code> x <code>N</code> matrix of TL eddy current vector field</li><li><code>TL_aircraft</code>:  <code>3</code> x <code>N</code> matrix of TL aircraft vector field</li><li><code>B_unit</code>:       <code>3</code> x <code>N</code> matrix of normalized vector magnetometer measurements</li><li><code>B_vec</code>:        <code>3</code> x <code>N</code> matrix of vector magnetometer measurements</li><li><code>y_nn</code>:         <code>3</code> x <code>N</code> matrix of vector neural network correction (for scalar models, in direction of <code>Bt</code>)</li><li><code>vec_aircraft</code>: <code>3</code> x <code>N</code> matrix of predicted aircraft vector field</li><li><code>y</code>:            length-<code>N</code> target vector</li><li><code>y_hat</code>:        length-<code>N</code> prediction vector</li><li><code>err</code>:          length-<code>N</code> mean-corrected (per line) compensation error</li><li><code>features</code>:     length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L3921-L3969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_test" href="#MagNav.comp_test"><code>MagNav.comp_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_test(comp_params::CompParams, xyz::XYZ, ind,
          mapS::Union{MapS,MapSd,MapS3D} = mapS_null;
          temp_params::TempParams        = TempParams(),
          silent::Bool                   = false)</code></pre><p>Evaluate performance of an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>xyz</code>:         <code>XYZ</code> flight data struct</li><li><code>ind</code>:         selected data indices</li><li><code>mapS</code>:        (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct, only used for <code>y_type = :b, :c</code></li><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y</code>:        length-<code>N</code> target vector</li><li><code>y_hat</code>:    length-<code>N</code> prediction vector</li><li><code>err</code>:      length-<code>N</code> compensation error</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L3372-L3395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_test-Tuple{MagNav.CompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.comp_test-Tuple{MagNav.CompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.comp_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_test(comp_params::CompParams, lines,
          df_line::DataFrame, df_flight::DataFrame, df_map::DataFrame;
          temp_params::TempParams = TempParams(),
          silent::Bool            = false)</code></pre><p>Evaluate performance of an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y</code>:        length-<code>N</code> target vector</li><li><code>y_hat</code>:    length-<code>N</code> prediction vector</li><li><code>err</code>:      length-<code>N</code> mean-corrected (per line) compensation error</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L3580-L3621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_train" href="#MagNav.comp_train"><code>MagNav.comp_train</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_train(comp_params::CompParams, xyz::XYZ, ind,
           mapS::Union{MapS,MapSd,MapS3D} = mapS_null;
           temp_params::TempParams        = TempParams(),
           xyz_test::XYZ                  = xyz,
           ind_test                       = BitVector(),
           silent::Bool                   = false)</code></pre><p>Train an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>xyz</code>:         <code>XYZ</code> flight data struct</li><li><code>ind</code>:         selected data indices</li><li><code>mapS</code>:        (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct, only used for <code>y_type = :b, :c</code></li><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>xyz_test</code>:    (optional) <code>XYZ</code> held-out test data struct</li><li><code>ind_test</code>:    (optional) indices for test data struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>y_hat</code>:       length-<code>N</code> prediction vector</li><li><code>err</code>:         length-<code>N</code> compensation error</li><li><code>features</code>:    length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L2115-L2143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_train" href="#MagNav.comp_train"><code>MagNav.comp_train</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_train(comp_params::CompParams, xyz_vec::Vector, ind_vec::Vector,
           mapS::Union{MapS,MapSd,MapS3D} = mapS_null;
           temp_params::TempParams        = TempParams(),
           xyz_test::XYZ                  = xyz_vec[1],
           ind_test                       = BitVector(),
           silent::Bool                   = false)</code></pre><p>Train an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>xyz_vec</code>:     vector of <code>XYZ</code> flight data structs</li><li><code>ind_vec</code>:     vector of selected data indices</li><li><code>mapS</code>:        (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct, only used for <code>y_type = :b, :c</code></li><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>xyz_test</code>:    (optional) <code>XYZ</code> held-out test data struct</li><li><code>ind_test</code>:    (optional) indices for test data struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>y_hat</code>:       length-<code>N</code> prediction vector</li><li><code>err</code>:         length-<code>N</code> compensation error</li><li><code>features</code>:    length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L2525-L2553">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_train-Tuple{MagNav.CompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.comp_train-Tuple{MagNav.CompParams, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.comp_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_train(comp_params::CompParams, lines,
           df_line::DataFrame, df_flight::DataFrame, df_map::DataFrame;
           temp_params::TempParams = TempParams(),
           silent::Bool            = false)</code></pre><p>Train an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>y_hat</code>:       length-<code>N</code> prediction vector</li><li><code>err</code>:         length-<code>N</code> mean-corrected (per line) compensation error</li><li><code>features</code>:    length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L2986-L3028">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_train_test" href="#MagNav.comp_train_test"><code>MagNav.comp_train_test</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_train_test(comp_params::CompParams,
                xyz_train::XYZ, xyz_test::XYZ, ind_train, ind_test,
                mapS_train::Union{MapS,MapSd,MapS3D} = mapS_null,
                mapS_test::Union{MapS,MapSd,MapS3D}  = mapS_null;
                temp_params::TempParams = TempParams(),
                silent::Bool            = false)</code></pre><p>Train &amp; evaluate performance of an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>xyz_train</code>:   <code>XYZ</code> flight data struct for training</li><li><code>xyz_test</code>:    <code>XYZ</code> flight data struct for testing</li><li><code>ind_train</code>:   selected data indices for training</li><li><code>ind_test</code>:    selected data indices for testing</li><li><code>mapS_train</code>:  (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct for training, only used for <code>y_type = :b, :c</code></li><li><code>mapS_test</code>:   (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct for testing,  only used for <code>y_type = :b, :c</code></li><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct</li><li><code>y_train</code>:     length-<code>N_train</code> training target vector</li><li><code>y_train_hat</code>: length-<code>N_train</code> training prediction vector</li><li><code>err_train</code>:   length-<code>N_train</code> training compensation error</li><li><code>y_test</code>:      length-<code>N_test</code> testing target vector</li><li><code>y_test_hat</code>:  length-<code>N_test</code> testing prediction vector</li><li><code>err_test</code>:    length-<code>N_test</code> testing compensation error</li><li><code>features</code>:    length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L4072-L4104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.comp_train_test-Tuple{MagNav.CompParams, Any, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.comp_train_test-Tuple{MagNav.CompParams, Any, Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.comp_train_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_train_test(comp_params::CompParams, lines_train, lines_test,
                df_line::DataFrame, df_flight::DataFrame, df_map::DataFrame;
                temp_params::TempParams = TempParams(),
                silent::Bool            = false)</code></pre><p>Train &amp; evaluate performance of an aeromagnetic compensation model.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>lines_train</code>: selected line number(s) for training</li><li><code>lines_test</code>:  selected line number(s) for testing</li><li><code>df_line</code>:     lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>temp_params</code>: (optional) <code>TempParams</code> temporary temporal parameters struct</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct</li><li><code>y_train</code>:     length-<code>N_train</code> training target vector</li><li><code>y_train_hat</code>: length-<code>N_train</code> training prediction vector</li><li><code>err_train</code>:   length-<code>N_train</code> mean-corrected (per line) training compensation error</li><li><code>y_test</code>:      length-<code>N_test</code> testing target vector</li><li><code>y_test_hat</code>:  length-<code>N_test</code> testing prediction vector</li><li><code>err_test</code>:    length-<code>N_test</code> mean-corrected (per line) testing compensation error</li><li><code>features</code>:    length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L4128-L4174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.compare_fields-Tuple{Any, Any}" href="#MagNav.compare_fields-Tuple{Any, Any}"><code>MagNav.compare_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare_fields(s1, s2; silent::Bool = false)</code></pre><p>Compare data for each data field in 2 structs of the same type.</p><p><strong>Arguments:</strong></p><ul><li><code>s1</code>:     struct 1</li><li><code>s2</code>:     struct 2</li><li><code>silent</code>: (optional) if true, no summary print out</li></ul><p><strong>Returns:</strong></p><ul><li><code>N_dif</code>: if <code>silent = false</code>, number of different fields</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/xyz2h5.jl#L364-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.corrupt_mag-NTuple{4, Any}" href="#MagNav.corrupt_mag-NTuple{4, Any}"><code>MagNav.corrupt_mag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">corrupt_mag(mag_c, Bx, By, Bz;
            dt           = 0.1,
            cor_sigma    = 1.0,
            cor_tau      = 600.0,
            cor_var      = 1.0^2,
            cor_drift    = 0.001,
            cor_perm_mag = 5.0,
            cor_ind_mag  = 5.0,
            cor_eddy_mag = 0.5)</code></pre><p>Corrupt compensated (clean) magnetometer measurements with random, FOGM, drift, and Tolles-Lawson noise to create uncompensated (corrupted) scalar magnetometer measurements. FOGM is a First-order Gauss-Markov stochastic process.</p><p><strong>Arguments:</strong></p><ul><li><code>mag_c</code>:        compensated (clean) scalar magnetometer measurements [nT]</li><li><code>Bx</code>,<code>By</code>,<code>Bz</code>: vector magnetometer measurements [nT]</li><li><code>dt</code>:           (optional) measurement time step [s]</li><li><code>cor_sigma</code>:    (optional) corruption FOGM catch-all bias [nT]</li><li><code>cor_tau</code>:      (optional) corruption FOGM catch-all time constant [s]</li><li><code>cor_var</code>:      (optional) corruption measurement (white) noise variance [nT^2]</li><li><code>cor_drift</code>:    (optional) corruption measurement linear drift [nT/s]</li><li><code>cor_perm_mag</code>: (optional) corruption permanent field TL coef std dev</li><li><code>cor_ind_mag</code>:  (optional) corruption induced field TL coef std dev</li><li><code>cor_eddy_mag</code>: (optional) corruption eddy current TL coef std dev</li></ul><p><strong>Returns:</strong></p><ul><li><code>mag_uc</code>:   uncompensated (corrupted) scalar magnetometer measurements [nT]</li><li><code>TL_coef</code>:  Tolles-Lawson coefficients (partially) used to create <code>mag_uc</code></li><li><code>cor_fogm</code>: corruption FOGM portion [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L643-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.corrupt_mag-Tuple{Any, Any}" href="#MagNav.corrupt_mag-Tuple{Any, Any}"><code>MagNav.corrupt_mag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">corrupt_mag(mag_c, flux;
            dt           = 0.1,
            cor_sigma    = 1.0,
            cor_tau      = 600.0,
            cor_var      = 1.0^2,
            cor_drift    = 0.001,
            cor_perm_mag = 5.0,
            cor_ind_mag  = 5.0,
            cor_eddy_mag = 0.5)</code></pre><p>Corrupt compensated (clean) magnetometer measurements with random, FOGM, drift, and Tolles-Lawson noise to create uncompensated (corrupted) scalar magnetometer measurements. FOGM is a First-order Gauss-Markov stochastic process.</p><p><strong>Arguments:</strong></p><ul><li><code>mag_c</code>:        compensated (clean) scalar magnetometer measurements [nT]</li><li><code>flux</code>:         <code>MagV</code> vector magnetometer measurement struct</li><li><code>dt</code>:           (optional) measurement time step [s]</li><li><code>cor_sigma</code>:    (optional) corruption FOGM catch-all bias [nT]</li><li><code>cor_tau</code>:      (optional) corruption FOGM catch-all time constant [s]</li><li><code>cor_var</code>:      (optional) corruption measurement (white) noise variance [nT^2]</li><li><code>cor_drift</code>:    (optional) corruption measurement linear drift [nT/s]</li><li><code>cor_perm_mag</code>: (optional) corruption permanent field TL coef std dev</li><li><code>cor_ind_mag</code>:  (optional) corruption induced field TL coef std dev</li><li><code>cor_eddy_mag</code>: (optional) corruption eddy current TL coef std dev</li></ul><p><strong>Returns:</strong></p><ul><li><code>mag_uc</code>:   uncompensated (corrupted) scalar magnetometer measurements [nT]</li><li><code>TL_coef</code>:  Tolles-Lawson coefficients (partially) used to create <code>mag_uc</code></li><li><code>cor_fogm</code>: corruption FOGM portion [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L705-L736">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_P0" href="#MagNav.create_P0"><code>MagNav.create_P0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_P0(lat1 = deg2rad(45);
          init_pos_sigma   = 3.0,
          init_alt_sigma   = 0.001,
          init_vel_sigma   = 0.01,
          init_att_sigma   = deg2rad(0.01),
          ha_sigma         = 0.001,
          a_hat_sigma      = 0.01,
          acc_sigma        = 0.000245,
          gyro_sigma       = 0.00000000727,
          fogm_sigma       = 3.0,
          vec_sigma        = 1000.0,
          vec_states::Bool = false,
          fogm_state::Bool = true,
          P0_TL            = [])</code></pre><p>Create initial covariance matrix <code>P0</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>lat1</code>:           initial approximate latitude [rad]</li><li><code>init_pos_sigma</code>: (optional) initial position uncertainty [m]</li><li><code>init_alt_sigma</code>: (optional) initial altitude uncertainty [m]</li><li><code>init_vel_sigma</code>: (optional) initial velocity uncertainty [m/s]</li><li><code>init_att_sigma</code>: (optional) initial attitude uncertainty [rad]</li><li><code>ha_sigma</code>:       (optional) barometer aiding altitude bias [m]</li><li><code>a_hat_sigma</code>:    (optional) barometer aiding vertical accel bias [m/s^2]</li><li><code>acc_sigma</code>:      (optional) accelerometer bias [m/s^2]</li><li><code>gyro_sigma</code>:     (optional) gyroscope bias [rad/s]</li><li><code>fogm_sigma</code>:     (optional) FOGM catch-all bias [nT]</li><li><code>vec_sigma</code>:      (optional) vector magnetometer noise std dev</li><li><code>vec_states</code>:     (optional) if true, include vector magnetometer states</li><li><code>fogm_state</code>:     (optional) if true, include FOGM catch-all bias state</li><li><code>P0_TL</code>:          (optional) initial Tolles-Lawson covariance matrix</li></ul><p><strong>Returns:</strong></p><ul><li><code>P0</code>: initial covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/model_functions.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_Qd" href="#MagNav.create_Qd"><code>MagNav.create_Qd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_Qd(dt = 0.1;
          VRW_sigma        = 0.000238,
          ARW_sigma        = 0.000000581,
          baro_sigma       = 1.0,
          acc_sigma        = 0.000245,
          gyro_sigma       = 0.00000000727,
          fogm_sigma       = 3.0,
          vec_sigma        = 1000.0,
          TL_sigma         = [],
          baro_tau         = 3600.0,
          acc_tau          = 3600.0,
          gyro_tau         = 3600.0,
          fogm_tau         = 600.0,
          vec_states::Bool = false,
          fogm_state::Bool = true)</code></pre><p>Create the discrete time process/system noise matrix <code>Qd</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>dt</code>:         measurement time step [s]</li><li><code>VRW_sigma</code>:  (optional) velocity random walk [m/s^2 /sqrt(Hz)]</li><li><code>ARW_sigma</code>:  (optional) angular  random walk [rad/s /sqrt(Hz)]</li><li><code>baro_sigma</code>: (optional) barometer bias [m]</li><li><code>acc_sigma</code>:  (optional) accelerometer bias [m/s^2]</li><li><code>gyro_sigma</code>: (optional) gyroscope bias [rad/s]</li><li><code>fogm_sigma</code>: (optional) FOGM catch-all bias [nT]</li><li><code>vec_sigma</code>:  (optional) vector magnetometer noise std dev</li><li><code>TL_sigma</code>:   (optional) Tolles-Lawson coefficients estimate std dev</li><li><code>baro_tau</code>:   (optional) barometer time constant [s]</li><li><code>acc_tau</code>:    (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:   (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>vec_states</code>: (optional) if true, include vector magnetometer states</li><li><code>fogm_state</code>: (optional) if true, include FOGM catch-all bias state</li></ul><p><strong>Returns:</strong></p><ul><li><code>Qd</code>: discrete time process/system noise matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/model_functions.jl#L89-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_TL_A" href="#MagNav.create_TL_A"><code>MagNav.create_TL_A</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_TL_A(flux::MagV, ind = trues(length(flux.x));
            Bt       = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],
            terms    = [:permanent,:induced,:eddy],
            Bt_scale = 50000,
            return_B = false)</code></pre><p>Create Tolles-Lawson <code>A</code> matrix using vector magnetometer measurements. Optionally returns the magnitude &amp; derivatives of total field.</p><p><strong>Arguments:</strong></p><ul><li><code>flux</code>:     <code>MagV</code> vector magnetometer measurement struct</li><li><code>ind</code>:      (optional) selected data indices</li><li><code>Bt</code>:       (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]</li><li><code>terms</code>:    (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>Bt_scale</code>: (optional) scaling factor for induced &amp; eddy current terms [nT]</li><li><code>return_B</code>: (optional) if true, also return <code>Bt</code> &amp; <code>B_dot</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>A</code>:     Tolles-Lawson <code>A</code> matrix</li><li><code>Bt</code>:    if <code>return_B = true</code>, magnitude of total field measurements [nT]</li><li><code>B_dot</code>: if <code>return_B = true</code>, finite differences of total field vector [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/tolles_lawson.jl#L128-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_TL_A-Tuple{Any, Any, Any}" href="#MagNav.create_TL_A-Tuple{Any, Any, Any}"><code>MagNav.create_TL_A</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_TL_A(Bx, By, Bz;
            Bt       = sqrt.(Bx.^2+By.^2+Bz.^2),
            terms    = [:permanent,:induced,:eddy],
            Bt_scale = 50000,
            return_B = false)</code></pre><p>Create Tolles-Lawson <code>A</code> matrix using vector magnetometer measurements. Optionally returns the magnitude &amp; derivatives of total field.</p><p><strong>Arguments:</strong></p><ul><li><code>Bx</code>,<code>By</code>,<code>Bz</code>: vector magnetometer measurements [nT]</li><li><code>Bt</code>:           (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]</li><li><code>terms</code>:        (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>Bt_scale</code>:     (optional) scaling factor for induced &amp; eddy current terms [nT]</li><li><code>return_B</code>:     (optional) if true, also return <code>Bt</code> &amp; <code>B_dot</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>A</code>:     Tolles-Lawson <code>A</code> matrix</li><li><code>Bt</code>:    if <code>return_B = true</code>, magnitude of total field measurements [nT]</li><li><code>B_dot</code>: if <code>return_B = true</code>, finite differences of total field vector [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/tolles_lawson.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_TL_coef" href="#MagNav.create_TL_coef"><code>MagNav.create_TL_coef</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_TL_coef(flux::MagV, B, ind = trues(length(flux.x));
               Bt         = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],
               λ          = 0,
               terms      = [:permanent,:induced,:eddy],
               pass1      = 0.1,
               pass2      = 0.9,
               fs         = 10.0,
               pole::Int  = 4,
               trim::Int  = 20,
               Bt_scale   = 50000,
               return_var = false)</code></pre><p>Create Tolles-Lawson coefficients using vector &amp; scalar magnetometer measurements with a bandpass, low-pass, or high-pass filter.</p><p><strong>Arguments:</strong></p><ul><li><code>flux</code>:       <code>MagV</code> vector magnetometer measurement struct</li><li><code>B</code>:          scalar magnetometer measurements [nT]</li><li><code>ind</code>:        (optional) selected data indices</li><li><code>Bt</code>:         (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]</li><li><code>λ</code>:          (optional) ridge parameter</li><li><code>terms</code>:      (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>pass1</code>:      (optional) first passband frequency [Hz]</li><li><code>pass2</code>:      (optional) second passband frequency [Hz]</li><li><code>fs</code>:         (optional) sampling frequency [Hz]</li><li><code>pole</code>:       (optional) number of poles for Butterworth filter</li><li><code>trim</code>:       (optional) number of elements to trim after filtering</li><li><code>Bt_scale</code>:   (optional) scaling factor for induced &amp; eddy current terms [nT]</li><li><code>return_var</code>: (optional) if true, also return <code>B_var</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>coef</code>:  Tolles-Lawson coefficients</li><li><code>B_var</code>: if <code>return_var = true</code>, fit error variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/tolles_lawson.jl#L235-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_TL_coef-NTuple{4, Any}" href="#MagNav.create_TL_coef-NTuple{4, Any}"><code>MagNav.create_TL_coef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_TL_coef(Bx, By, Bz, B;
               Bt         = sqrt.(Bx.^2+By.^2+Bz.^2),
               λ          = 0,
               terms      = [:permanent,:induced,:eddy],
               pass1      = 0.1,
               pass2      = 0.9,
               fs         = 10.0,
               pole::Int  = 4,
               trim::Int  = 20,
               Bt_scale   = 50000,
               return_var = false)</code></pre><p>Create Tolles-Lawson coefficients using vector &amp; scalar magnetometer measurements with a bandpass, low-pass, or high-pass filter.</p><p><strong>Arguments:</strong></p><ul><li><code>Bx</code>,<code>By</code>,<code>Bz</code>: vector magnetometer measurements [nT]</li><li><code>B</code>:            scalar magnetometer measurements [nT]</li><li><code>Bt</code>:           (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]</li><li><code>λ</code>:            (optional) ridge parameter</li><li><code>terms</code>:        (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>pass1</code>:        (optional) first passband frequency [Hz]</li><li><code>pass2</code>:        (optional) second passband frequency [Hz]</li><li><code>fs</code>:           (optional) sampling frequency [Hz]</li><li><code>pole</code>:         (optional) number of poles for Butterworth filter</li><li><code>trim</code>:         (optional) number of elements to trim after filtering</li><li><code>Bt_scale</code>:     (optional) scaling factor for induced &amp; eddy current terms [nT]</li><li><code>return_var</code>:   (optional) if true, also return <code>B_var</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>coef</code>:  Tolles-Lawson coefficients</li><li><code>B_var</code>: if <code>return_var = true</code>, fit error variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/tolles_lawson.jl#L161-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_XYZ0" href="#MagNav.create_XYZ0"><code>MagNav.create_XYZ0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_XYZ0(mapS::Union{MapS,MapSd,MapS3D} = get_map(namad);
            alt            = 1000,
            dt             = 0.1,
            t              = 300,
            v              = 68,
            ll1::Tuple     = (),
            ll2::Tuple     = (),
            N_waves::Int   = 1,
            attempts::Int  = 10,
            info::String   = &quot;Simulated data&quot;,
            flight         = 1,
            line           = 1,
            year           = 2023,
            doy            = 154,
            mapV::MapV     = get_map(emm720),
            cor_sigma      = 1.0,
            cor_tau        = 600.0,
            cor_var        = 1.0^2,
            cor_drift      = 0.001,
            cor_perm_mag   = 5.0,
            cor_ind_mag    = 5.0,
            cor_eddy_mag   = 0.5,
            init_pos_sigma = 3.0,
            init_alt_sigma = 0.001,
            init_vel_sigma = 0.01,
            init_att_sigma = deg2rad(0.01),
            VRW_sigma      = 0.000238,
            ARW_sigma      = 0.000000581,
            baro_sigma     = 1.0,
            ha_sigma       = 0.001,
            a_hat_sigma    = 0.01,
            acc_sigma      = 0.000245,
            gyro_sigma     = 0.00000000727,
            fogm_sigma     = 1.0,
            baro_tau       = 3600.0,
            acc_tau        = 3600.0,
            gyro_tau       = 3600.0,
            fogm_tau       = 600.0,
            save_h5::Bool  = false,
            xyz_h5::String = &quot;xyz_data.h5&quot;,
            silent::Bool   = false)</code></pre><p>Create basic flight data. Assumes constant altitude (2D flight). No required arguments, though many are available to create custom data.</p><p><strong>Trajectory Arguments:</strong></p><ul><li><code>mapS</code>:     (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>alt</code>:      (optional) altitude  [m]</li><li><code>dt</code>:       (optional) measurement time step [s]</li><li><code>t</code>:        (optional) total flight time, ignored if <code>ll2</code> is set [s]</li><li><code>v</code>:        (optional) approximate aircraft velocity [m/s]</li><li><code>ll1</code>:      (optional) initial (lat,lon) point [deg]</li><li><code>ll2</code>:      (optional) final   (lat,lon) point [deg]</li><li><code>N_waves</code>:  (optional) number of sine waves along path</li><li><code>attempts</code>: (optional) maximum attempts at creating flight path on <code>mapS</code></li><li><code>info</code>:     (optional) flight data information</li><li><code>flight</code>:   (optional) flight number</li><li><code>line</code>:     (optional) line number, i.e., segment within <code>flight</code></li><li><code>year</code>:     (optional) year</li><li><code>doy</code>:      (optional) day of year</li><li><code>mapV</code>:     (optional) <code>MapV</code> vector magnetic anomaly map struct</li><li><code>save_h5</code>:  (optional) if true, save <code>xyz</code> to <code>xyz_h5</code></li><li><code>xyz_h5</code>:   (optional) path/name of flight data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Compensated Measurement Corruption Arguments:</strong></p><ul><li><code>cor_var</code>:        (optional) corruption measurement (white) noise variance [nT^2]</li><li><code>fogm_sigma</code>:     (optional) FOGM catch-all bias [nT]</li><li><code>fogm_tau</code>:       (optional) FOGM catch-all time constant [s]</li></ul><p><strong>Uncompensated Measurement Corruption Arguments:</strong></p><ul><li><code>cor_sigma</code>:      (optional) corruption FOGM catch-all bias [nT]</li><li><code>cor_tau</code>:        (optional) corruption FOGM catch-all time constant [s]</li><li><code>cor_var</code>:        (optional) corruption measurement (white) noise variance [nT^2]</li><li><code>cor_drift</code>:      (optional) corruption measurement linear drift [nT/s]</li><li><code>cor_perm_mag</code>:   (optional) corruption permanent field TL coef std dev</li><li><code>cor_ind_mag</code>:    (optional) corruption induced field TL coef std dev</li><li><code>cor_eddy_mag</code>:   (optional) corruption eddy current TL coef std dev</li></ul><p><strong>INS Arguments:</strong></p><ul><li><code>init_pos_sigma</code>: (optional) initial position uncertainty [m]</li><li><code>init_alt_sigma</code>: (optional) initial altitude uncertainty [m]</li><li><code>init_vel_sigma</code>: (optional) initial velocity uncertainty [m/s]</li><li><code>init_att_sigma</code>: (optional) initial attitude uncertainty [rad]</li><li><code>VRW_sigma</code>:      (optional) velocity random walk [m/s^2 /sqrt(Hz)]</li><li><code>ARW_sigma</code>:      (optional) angular  random walk [rad/s /sqrt(Hz)]</li><li><code>baro_sigma</code>:     (optional) barometer bias [m]</li><li><code>ha_sigma</code>:       (optional) barometer aiding altitude bias [m]</li><li><code>a_hat_sigma</code>:    (optional) barometer aiding vertical accel bias [m/s^2]</li><li><code>acc_sigma</code>:      (optional) accelerometer bias [m/s^2]</li><li><code>gyro_sigma</code>:     (optional) gyroscope bias [rad/s]</li><li><code>baro_tau</code>:       (optional) barometer time constant [s]</li><li><code>acc_tau</code>:        (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:       (optional) gyroscope time constant [s]</li></ul><p><strong>General Arguments:</strong></p><ul><li><code>silent</code>: (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ0</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L1-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_flux" href="#MagNav.create_flux"><code>MagNav.create_flux</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_flux(path::Path, mapV::MapV = get_map(emm720);
            meas_var     = 1.0^2,
            fogm_sigma   = 1.0,
            fogm_tau     = 600.0,
            silent::Bool = false)</code></pre><p>Create compensated (clean) vector magnetometer measurements from a vector magnetic anomaly map.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>mapV</code>:       (optional) <code>MapV</code> vector magnetic anomaly map struct</li><li><code>meas_var</code>:   (optional) measurement (white) noise variance [nT^2]</li><li><code>fogm_sigma</code>: (optional) FOGM catch-all bias [nT]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>flux</code>: <code>MagV</code> vector magnetometer measurement struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L815-L835">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_flux" href="#MagNav.create_flux"><code>MagNav.create_flux</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_flux(lat, lon, mapV::MapV = get_map(emm720);
            Cnb          = repeat(I(3),1,1,length(lat)),
            alt          = 1000,
            dt           = 0.1,
            meas_var     = 1.0^2,
            fogm_sigma   = 1.0,
            fogm_tau     = 600.0,
            silent::Bool = false)</code></pre><p>Create compensated (clean) vector magnetometer measurements from a vector magnetic anomaly map.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>mapV</code>:       (optional) <code>MapV</code> vector magnetic anomaly map struct</li><li><code>Cnb</code>:        (optional) direction cosine matrix (body to navigation) [-]</li><li><code>alt</code>:        (optional) altitude  [m]</li><li><code>dt</code>:         (optional) measurement time step [s]</li><li><code>meas_var</code>:   (optional) measurement (white) noise variance [nT^2]</li><li><code>fogm_sigma</code>: (optional) FOGM catch-all bias [nT]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>flux</code>: <code>MagV</code> vector magnetometer measurement struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L757-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_informed_xyz-Tuple{MagNav.XYZ, Any, Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}, Symbol, Symbol, Vector}" href="#MagNav.create_informed_xyz-Tuple{MagNav.XYZ, Any, Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}, Symbol, Symbol, Vector}"><code>MagNav.create_informed_xyz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_informed_xyz(xyz::XYZ, ind, mapS::Union{MapS,MapSd,MapS3D},
                    use_mag::Symbol, use_vec::Symbol, TL_coef::Vector;
                    terms::Vector{Symbol} = [:permanent,:induced,:eddy],
                    disp_min = 100,
                    disp_max = 500,
                    Bt_disp  = 50,
                    Bt_scale = 50000)</code></pre><p>Create knowledge-informed data from existing data. Given map information, an <code>XYZ</code> structure with magnetometer readings, and a fitted Tolles-Lawson model, this function creates a consistent, displaced <code>XYZ</code> structure representing what the <code>use_mag</code> and <code>mag_1_c</code> would have collected had the entire flight been laterally shifted by (<code>disp_min</code>,<code>disp_max</code>), assuming that the linear aircraft model is reasonably accurate. It makes use of a Taylor expansion of the map information to update the expected changes due to the alternative map location <em>and</em> due to the imputed aircraft field. The aircraft &quot;noise&quot; is then carried over into <code>use_mag</code> in the new <code>XYZ</code> data.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:      <code>XYZ</code> flight data struct</li><li><code>ind</code>:      selected data indices</li><li><code>mapS</code>:     <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>use_mag</code>:  uncompensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_uc</code>, etc.}</li><li><code>use_vec</code>:  vector magnetometer (fluxgate) to use for Tolles-Lawson <code>A</code> matrix {<code>:flux_a</code>, etc.}</li><li><code>TL_coef</code>:  Tolles-Lawson coefficients</li><li><code>terms</code>:    (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>}</li><li><code>disp_min</code>: (optional) minimum trajectory displacement [m]</li><li><code>disp_max</code>: (optional) maximum trajectory displacement [m]</li><li><code>Bt_disp</code>:  (optional) target total magnetic field magnitude displacement offset [nT]</li><li><code>Bt_scale</code>: (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz_disp</code>: <code>XYZ</code> flight data struct with displaced trajectory &amp; modified magnetometer readings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L931-L965">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_ins-Tuple{MagNav.Traj}" href="#MagNav.create_ins-Tuple{MagNav.Traj}"><code>MagNav.create_ins</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_ins(traj::Traj;
           init_pos_sigma = 3.0,
           init_alt_sigma = 0.001,
           init_vel_sigma = 0.01,
           init_att_sigma = deg2rad(0.01),
           VRW_sigma      = 0.000238,
           ARW_sigma      = 0.000000581,
           baro_sigma     = 1.0,
           ha_sigma       = 0.001,
           a_hat_sigma    = 0.01,
           acc_sigma      = 0.000245,
           gyro_sigma     = 0.00000000727,
           baro_tau       = 3600.0,
           acc_tau        = 3600.0,
           gyro_tau       = 3600.0,
           save_h5::Bool  = false,
           ins_h5::String = &quot;ins_data.h5&quot;)</code></pre><p>Creates an INS trajectory about a true trajectory. Propagates a 17-state Pinson error model to create INS errors.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:           <code>Traj</code> trajectory struct</li><li><code>init_pos_sigma</code>: (optional) initial position uncertainty [m]</li><li><code>init_alt_sigma</code>: (optional) initial altitude uncertainty [m]</li><li><code>init_vel_sigma</code>: (optional) initial velocity uncertainty [m/s]</li><li><code>init_att_sigma</code>: (optional) initial attitude uncertainty [rad]</li><li><code>VRW_sigma</code>:      (optional) velocity random walk [m/s^2 /sqrt(Hz)]</li><li><code>ARW_sigma</code>:      (optional) angular  random walk [rad/s /sqrt(Hz)]</li><li><code>baro_sigma</code>:     (optional) barometer bias [m]</li><li><code>ha_sigma</code>:       (optional) barometer aiding altitude bias [m]</li><li><code>a_hat_sigma</code>:    (optional) barometer aiding vertical accel bias [m/s^2]</li><li><code>acc_sigma</code>:      (optional) accelerometer bias [m/s^2]</li><li><code>gyro_sigma</code>:     (optional) gyroscope bias [rad/s]</li><li><code>baro_tau</code>:       (optional) barometer time constant [s]</li><li><code>acc_tau</code>:        (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:       (optional) gyroscope time constant [s]</li><li><code>save_h5</code>:        (optional) if true, save <code>ins</code> to <code>ins_h5</code></li><li><code>ins_h5</code>:         (optional) path/name of INS data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>ins</code>: <code>INS</code> inertial navigation system struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L407-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_mag_c" href="#MagNav.create_mag_c"><code>MagNav.create_mag_c</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_mag_c(lat, lon, mapS::Union{MapS,MapSd,MapS3D} = get_map(namad);
             alt          = 1000,
             dt           = 0.1,
             meas_var     = 1.0^2,
             fogm_sigma   = 1.0,
             fogm_tau     = 600.0,
             silent::Bool = false)</code></pre><p>Create compensated (clean) scalar magnetometer measurements from a scalar magnetic anomaly map.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>mapS</code>:       (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>alt</code>:        (optional) altitude  [m]</li><li><code>dt</code>:         (optional) measurement time step [s]</li><li><code>meas_var</code>:   (optional) measurement (white) noise variance [nT^2]</li><li><code>fogm_sigma</code>: (optional) FOGM catch-all bias [nT]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>mag_c</code>: compensated (clean) scalar magnetometer measurements [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L551-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_mag_c" href="#MagNav.create_mag_c"><code>MagNav.create_mag_c</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_mag_c(path::Path, mapS::Union{MapS,MapSd,MapS3D} = get_map(namad);
             meas_var     = 1.0^2,
             fogm_sigma   = 1.0,
             fogm_tau     = 600.0,
             silent::Bool = false)</code></pre><p>Create compensated (clean) scalar magnetometer measurements from a scalar magnetic anomaly map.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>mapS</code>:       (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>meas_var</code>:   (optional) measurement (white) noise variance [nT^2]</li><li><code>fogm_sigma</code>: (optional) FOGM catch-all bias [nT]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>mag_c</code>: compensated (clean) scalar magnetometer measurements [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L608-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_model" href="#MagNav.create_model"><code>MagNav.create_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_model(dt = 0.1, lat1 = deg2rad(45);
             init_pos_sigma   = 3.0,
             init_alt_sigma   = 0.001,
             init_vel_sigma   = 0.01,
             init_att_sigma   = deg2rad(0.01),
             meas_var         = 3.0^2,
             VRW_sigma        = 0.000238,
             ARW_sigma        = 0.000000581,
             baro_sigma       = 1.0,
             ha_sigma         = 0.001,
             a_hat_sigma      = 0.01,
             acc_sigma        = 0.000245,
             gyro_sigma       = 0.00000000727,
             fogm_sigma       = 3.0,
             vec_sigma        = 1000.0,
             TL_sigma         = [],
             baro_tau         = 3600.0,
             acc_tau          = 3600.0,
             gyro_tau         = 3600.0,
             fogm_tau         = 600.0,
             vec_states::Bool = false,
             fogm_state::Bool = true,
             P0_TL            = [])</code></pre><p>Create a magnetic navigation filter model for use in an EKF or a MPF.</p><p><strong>Arguments:</strong></p><ul><li><code>dt</code>:             measurement time step [s]</li><li><code>lat1</code>:           initial approximate latitude [rad]</li><li><code>init_pos_sigma</code>: (optional) initial position uncertainty [m]</li><li><code>init_alt_sigma</code>: (optional) initial altitude uncertainty [m]</li><li><code>init_vel_sigma</code>: (optional) initial velocity uncertainty [m/s]</li><li><code>init_att_sigma</code>: (optional) initial attitude uncertainty [rad]</li><li><code>meas_var</code>:       (optional) measurement (white) noise variance [nT^2]</li><li><code>VRW_sigma</code>:      (optional) velocity random walk [m/s^2 /sqrt(Hz)]</li><li><code>ARW_sigma</code>:      (optional) angular  random walk [rad/s /sqrt(Hz)]</li><li><code>baro_sigma</code>:     (optional) barometer bias [m]</li><li><code>ha_sigma</code>:       (optional) barometer aiding altitude bias [m]</li><li><code>a_hat_sigma</code>:    (optional) barometer aiding vertical accel bias [m/s^2]</li><li><code>acc_sigma</code>:      (optional) accelerometer bias [m/s^2]</li><li><code>gyro_sigma</code>:     (optional) gyroscope bias [rad/s]</li><li><code>fogm_sigma</code>:     (optional) FOGM catch-all bias [nT]</li><li><code>vec_sigma</code>:      (optional) vector magnetometer noise std dev</li><li><code>TL_sigma</code>:       (optional) Tolles-Lawson coefficients estimate std dev</li><li><code>baro_tau</code>:       (optional) barometer time constant [s]</li><li><code>acc_tau</code>:        (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:       (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:       (optional) FOGM catch-all time constant [s]</li><li><code>vec_states</code>:     (optional) if true, include vector magnetometer states</li><li><code>fogm_state</code>:     (optional) if true, include FOGM catch-all bias state</li><li><code>P0_TL</code>:          (optional) initial Tolles-Lawson covariance matrix</li></ul><p><strong>Returns:</strong></p><ul><li><code>P0</code>: initial covariance matrix</li><li><code>Qd</code>: discrete time process/system noise matrix</li><li><code>R</code>:  measurement (white) noise variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/model_functions.jl#L178-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.create_traj" href="#MagNav.create_traj"><code>MagNav.create_traj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_traj(mapS::Union{MapS,MapSd,MapS3D} = get_map(namad);
            alt             = 1000,
            dt              = 0.1,
            t               = 300,
            v               = 68,
            ll1::Tuple      = (),
            ll2::Tuple      = (),
            N_waves::Int    = 1,
            attempts::Int   = 10,
            save_h5::Bool   = false,
            traj_h5::String = &quot;traj_data.h5&quot;)</code></pre><p>Create <code>Traj</code> trajectory struct with a straight or sinusoidal flight path at constant altitude (2D flight).</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:     (optional) <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>alt</code>:      (optional) altitude  [m]</li><li><code>dt</code>:       (optional) measurement time step [s]</li><li><code>t</code>:        (optional) total flight time, ignored if <code>ll2</code> is set [s]</li><li><code>v</code>:        (optional) approximate aircraft velocity [m/s]</li><li><code>ll1</code>:      (optional) initial (lat,lon) point [deg]</li><li><code>ll2</code>:      (optional) final   (lat,lon) point [deg]</li><li><code>N_waves</code>:  (optional) number of sine waves along path</li><li><code>attempts</code>: (optional) maximum attempts at creating flight path on <code>mapS</code></li><li><code>save_h5</code>:  (optional) if true, save <code>traj</code> to <code>traj_h5</code></li><li><code>traj_h5</code>:  (optional) path/name of trajectory data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>traj</code>: <code>Traj</code> trajectory struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/create_XYZ.jl#L237-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.crlb-NTuple{12, Any}" href="#MagNav.crlb-NTuple{12, Any}"><code>MagNav.crlb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">crlb(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, dt, itp_mapS;
     P0         = create_P0(),
     Qd         = create_Qd(),
     R          = 1.0,
     baro_tau   = 3600.0,
     acc_tau    = 3600.0,
     gyro_tau   = 3600.0,
     fogm_tau   = 600.0,
     date       = get_years(2020,185),
     core::Bool = false)</code></pre><p>Cramér–Rao lower bound (CRLB) computed with classic Kalman Filter. Equations evaluated about true trajectory.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:      latitude  [rad]</li><li><code>lon</code>:      longitude [rad]</li><li><code>alt</code>:      altitude  [m]</li><li><code>vn</code>:       north velocity [m/s]</li><li><code>ve</code>:       east  velocity [m/s]</li><li><code>vd</code>:       down  velocity [m/s]</li><li><code>fn</code>:       north specific force [m/s^2]</li><li><code>fe</code>:       east  specific force [m/s^2]</li><li><code>fd</code>:       down  specific force [m/s^2]</li><li><code>Cnb</code>:      direction cosine matrix (body to navigation) [-]</li><li><code>dt</code>:       measurement time step [s]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>P</code>: non-linear covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_&amp;_crlb.jl#L316-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.crlb-Tuple{MagNav.Traj, Any}" href="#MagNav.crlb-Tuple{MagNav.Traj, Any}"><code>MagNav.crlb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">crlb(traj::Traj, itp_mapS;
     P0         = create_P0(),
     Qd         = create_Qd(),
     R          = 1.0,
     baro_tau   = 3600.0,
     acc_tau    = 3600.0,
     gyro_tau   = 3600.0,
     fogm_tau   = 600.0,
     date       = get_years(2020,185),
     core::Bool = false)</code></pre><p>Cramér–Rao lower bound (CRLB) computed with classic Kalman Filter. Equations evaluated about true trajectory.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:     <code>Traj</code> trajectory struct</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>P</code>: non-linear covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_&amp;_crlb.jl#L398-L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.dcm2euler" href="#MagNav.dcm2euler"><code>MagNav.dcm2euler</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcm2euler(dcm, order::Symbol = :body2nav)</code></pre><p>Converts a DCM (direction cosine matrix) to yaw, pitch, and roll Euler angles. Yaw is synonymous with azimuth and heading here. There are 2 use cases:</p><ol><li>With <code>order = :body2nav</code>, the provided DCM is assumed to rotate from the</li></ol><p>body frame in the standard -roll, -pitch, -yaw sequence to the navigation frame. For example, if v1 is a 3x1 vector in the body frame [nose, right wing, down], then that vector rotated into the navigation frame [north, east, down] would be v2 = dcm * v1.</p><ol><li>With <code>order = :nav2body</code>, the provided DCM is assumed to rotate from the</li></ol><p>navigation frame in the standard yaw, pitch, roll sequence to the body frame. For example, if v1 is a 3x1 vector in the navigation frame [north, east, down], then that vector rotated into the body frame [nose, right wing, down] would be v2 = dcm * v1.</p><p>Reference: Titterton &amp; Weston, Strapdown Inertial Navigation Technology, 2004, Section 3.6 (pg. 36-41 &amp; 537).</p><p><strong>Arguments:</strong></p><ul><li><code>dcm</code>:   <code>3</code> x <code>3</code> x <code>N</code> direction cosine matrix [-]</li><li><code>order</code>: (optional) rotation order {<code>:body2nav</code>,<code>:nav2body</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>roll</code>:  length-<code>N</code> roll  angle [rad], right-handed rotation about x-axis</li><li><code>pitch</code>: length-<code>N</code> pitch angle [rad], right-handed rotation about y-axis</li><li><code>yaw</code>:   length-<code>N</code> yaw   angle [rad], right-handed rotation about z-axis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/dcm.jl#L81-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.de2dlon-Tuple{Any, Any}" href="#MagNav.de2dlon-Tuple{Any, Any}"><code>MagNav.de2dlon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">de2dlon(de, lat)</code></pre><p>Convert east-west position (easting) difference to longitude difference.</p><p><strong>Arguments:</strong></p><ul><li><code>de</code>:  east-west position (easting) difference [m]</li><li><code>lat</code>: nominal latitude [rad]</li></ul><p><strong>Returns:</strong></p><ul><li><code>dlon</code>: longitude difference [rad]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.denorm_sets-NTuple{4, Any}" href="#MagNav.denorm_sets-NTuple{4, Any}"><code>MagNav.denorm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">denorm_sets(train_bias, train_scale, train, test)</code></pre><p>Denormalize (or destandardize) features (columns) of training &amp; testing data.</p><p><strong>Arguments:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training data, normalized</li><li><code>test</code>:        <code>N_test</code>  x <code>Nf</code> testing  data, normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train</code>: <code>N_train</code> x <code>Nf</code> training data, denormalized</li><li><code>test</code>:  <code>N_test</code>  x <code>Nf</code> testing  data, denormalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1480-L1494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.denorm_sets-NTuple{5, Any}" href="#MagNav.denorm_sets-NTuple{5, Any}"><code>MagNav.denorm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">denorm_sets(train_bias, train_scale, train, val, test)</code></pre><p>Denormalize (or destandardize) features (columns) of training, validation, &amp; testing data.</p><p><strong>Arguments:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training   data, normalized</li><li><code>val</code>:         <code>N_val</code>   x <code>Nf</code> validation data, normalized</li><li><code>test</code>:        <code>N_test</code>  x <code>Nf</code> testing    data, normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train</code>: <code>N_train</code> x <code>Nf</code> training   data, denormalized</li><li><code>val</code>:   <code>N_val</code>   x <code>Nf</code> validation data, denormalized</li><li><code>test</code>:  <code>N_test</code>  x <code>Nf</code> testing    data, denormalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1501-L1518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.denorm_sets-Tuple{Any, Any, Any}" href="#MagNav.denorm_sets-Tuple{Any, Any, Any}"><code>MagNav.denorm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">denorm_sets(train_bias, train_scale, train)</code></pre><p>Denormalize (or destandardize) features (columns) of training data.</p><p><strong>Arguments:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training data, normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train</code>: <code>N_train</code> x <code>Nf</code> training data, denormalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1462-L1474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.detrend" href="#MagNav.detrend"><code>MagNav.detrend</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detrend(y, x = [eachindex(y);]; λ = 0, mean_only::Bool = false)</code></pre><p>Detrend signal (remove mean and optionally slope).</p><p><strong>Arguments:</strong></p><ul><li><code>y</code>:         length-<code>N</code> observed data vector</li><li><code>x</code>:         (optional) <code>N</code> x <code>Nf</code> input data matrix (<code>Nf</code> is number of features)</li><li><code>λ</code>:         (optional) ridge parameter</li><li><code>mean_only</code>: (optional) if true, only remove mean (not slope)</li></ul><p><strong>Returns:</strong></p><ul><li><code>y</code>: length-<code>N</code> observed data vector, detrended</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L104-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.dlat2dn-Tuple{Any, Any}" href="#MagNav.dlat2dn-Tuple{Any, Any}"><code>MagNav.dlat2dn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dlat2dn(dlat, lat)</code></pre><p>Convert latitude difference to north-south position (northing) difference.</p><p><strong>Arguments:</strong></p><ul><li><code>dlat</code>: latitude difference [rad]</li><li><code>lat</code>:  nominal latitude [rad]</li></ul><p><strong>Returns:</strong></p><ul><li><code>dn</code>: north-south position (northing) difference [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.dlon2de-Tuple{Any, Any}" href="#MagNav.dlon2de-Tuple{Any, Any}"><code>MagNav.dlon2de</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dlon2de(dlon, lat)</code></pre><p>Convert longitude difference to east-west position (easting) difference.</p><p><strong>Arguments:</strong></p><ul><li><code>dlon</code>: longitude difference [rad]</li><li><code>lat</code>:  nominal latitude [rad]</li></ul><p><strong>Returns:</strong></p><ul><li><code>de</code>: east-west position (easting) difference [m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.dn2dlat-Tuple{Any, Any}" href="#MagNav.dn2dlat-Tuple{Any, Any}"><code>MagNav.dn2dlat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dn2dlat(dn, lat)</code></pre><p>Convert north-south position (northing) difference to latitude difference.</p><p><strong>Arguments:</strong></p><ul><li><code>dn</code>:  north-south position (northing) difference [m]</li><li><code>lat</code>: nominal latitude [rad]</li></ul><p><strong>Returns:</strong></p><ul><li><code>dlat</code>: latitude difference [rad]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.downward_L-Tuple{Matrix, Any, Any, Any, Vector}" href="#MagNav.downward_L-Tuple{Matrix, Any, Any, Any, Vector}"><code>MagNav.downward_L</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">downward_L(map_map::Matrix, dx, dy, dz, α::Vector;
           map_mask::BitMatrix = map_params(map_map)[2],
           expand::Bool        = true)</code></pre><p>Downward continuation using a sequence of regularization parameters to create a characteristic L-curve. The optimal regularization parameter is at a local minimum on the L-curve, which is a local maximum of curvature. The global maximum of curvature may or may not be the optimal regularization parameter.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>dx</code>:        x-direction map step size [m]</li><li><code>dy</code>:        y-direction map step size [m]</li><li><code>dz</code>:        z-direction upward/downward continuation distance [m]</li><li><code>α</code>:        (geometric) sequence of regularization parameters</li><li><code>map_mask</code>: (optional) <code>ny</code> x <code>nx</code> mask for valid (not filled-in) map data</li><li><code>expand</code>:   (optional) if true, expand map temporarily to reduce edge effects</li></ul><p><strong>Returns:</strong></p><ul><li><code>norms</code>: L-infinity norm of difference between sequential D.C. solutions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L287-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.downward_L-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}, Any, Vector}" href="#MagNav.downward_L-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}, Any, Vector}"><code>MagNav.downward_L</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">downward_L(mapS::Union{MapS,MapSd,MapS3D}, alt, α::Vector;
           expand::Bool = true)</code></pre><p>Downward continuation using a sequence of regularization parameters to create a characteristic L-curve. The optimal regularization parameter is at a local minimum on the L-curve, which is a local maximum of curvature. The global maximum of curvature may or may not be the optimal regularization parameter.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:   <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>alt</code>:    target downward continuation altitude [m]</li><li><code>α</code>:      (geometric) sequence of regularization parameters</li><li><code>expand</code>: (optional) if true, expand map temporarily to reduce edge effects</li></ul><p><strong>Returns:</strong></p><ul><li><code>norms</code>: L-infinity norm of difference between sequential D.C. solutions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L340-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf-NTuple{13, Any}" href="#MagNav.ekf-NTuple{13, Any}"><code>MagNav.ekf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;
    P0         = create_P0(),
    Qd         = create_Qd(),
    R          = 1.0,
    baro_tau   = 3600.0,
    acc_tau    = 3600.0,
    gyro_tau   = 3600.0,
    fogm_tau   = 600.0,
    date       = get_years(2020,185),
    core::Bool = false,
    der_mapS   = nothing,
    map_alt    = 0)</code></pre><p>Extended Kalman filter (EKF) for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:      latitude  [rad]</li><li><code>lon</code>:      longitude [rad]</li><li><code>alt</code>:      altitude  [m]</li><li><code>vn</code>:       north velocity [m/s]</li><li><code>ve</code>:       east  velocity [m/s]</li><li><code>vd</code>:       down  velocity [m/s]</li><li><code>fn</code>:       north specific force [m/s^2]</li><li><code>fe</code>:       east  specific force [m/s^2]</li><li><code>fd</code>:       down  specific force [m/s^2]</li><li><code>Cnb</code>:      direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>dt</code>:       measurement time step [s]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li><li><code>der_mapS</code>: (optional) scalar map vertical derivative map interpolation function (<code>f(lat,lon)</code> or (<code>f(lat,lon,alt)</code>)</li><li><code>map_alt</code>:  (optional) map altitude [m]</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_&amp;_crlb.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf-Tuple{MagNav.INS, Any, Any}" href="#MagNav.ekf-Tuple{MagNav.INS, Any, Any}"><code>MagNav.ekf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf(ins::INS, meas, itp_mapS;
    P0         = create_P0(),
    Qd         = create_Qd(),
    R          = 1.0,
    baro_tau   = 3600.0,
    acc_tau    = 3600.0,
    gyro_tau   = 3600.0,
    fogm_tau   = 600.0,
    date       = get_years(2020,185),
    core::Bool = false,
    der_mapS   = map_itp(zeros(2,2),[-pi,pi],[-pi/2,pi/2]),
    map_alt    = 0)</code></pre><p>Extended Kalman filter (EKF) for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li><li><code>der_mapS</code>: (optional) scalar map vertical derivative map interpolation function (<code>f(lat,lon)</code> or (<code>f(lat,lon,alt)</code>)</li><li><code>map_alt</code>:  (optional) map altitude [m]</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_&amp;_crlb.jl#L136-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online-NTuple{20, Any}" href="#MagNav.ekf_online-NTuple{20, Any}"><code>MagNav.ekf_online</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas,
           Bx, By, Bz, dt, itp_mapS, x0_TL, P0, Qd, R;
           baro_tau   = 3600.0,
           acc_tau    = 3600.0,
           gyro_tau   = 3600.0,
           fogm_tau   = 600.0,
           date       = get_years(2020,185),
           core::Bool = false,
           terms      = [:permanent,:induced,:eddy,:bias],
           Bt_scale   = 50000)</code></pre><p>Extended Kalman filter (EKF) with online learning of Tolles-Lawson coefficients.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:          latitude  [rad]</li><li><code>lon</code>:          longitude [rad]</li><li><code>alt</code>:          altitude  [m]</li><li><code>vn</code>:           north velocity [m/s]</li><li><code>ve</code>:           east  velocity [m/s]</li><li><code>vd</code>:           down  velocity [m/s]</li><li><code>fn</code>:           north specific force [m/s^2]</li><li><code>fe</code>:           east  specific force [m/s^2]</li><li><code>fd</code>:           down  specific force [m/s^2]</li><li><code>Cnb</code>:          direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:         scalar magnetometer measurement [nT]</li><li><code>Bx</code>,<code>By</code>,<code>Bz</code>: vector magnetometer measurements [nT]</li><li><code>dt</code>:           measurement time step [s]</li><li><code>itp_mapS</code>:     scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x0_TL</code>:        initial Tolles-Lawson coefficient states</li><li><code>P0</code>:           initial covariance matrix</li><li><code>Qd</code>:           discrete time process/system noise matrix</li><li><code>R</code>:            measurement (white) noise variance</li><li><code>baro_tau</code>:     (optional) barometer time constant [s]</li><li><code>acc_tau</code>:      (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:     (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:     (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:         (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:         (optional) if true, include core magnetic field in measurement</li><li><code>terms</code>:        (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>Bt_scale</code>:     (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online-Tuple{MagNav.INS, Any, MagNav.MagV, Vararg{Any, 5}}" href="#MagNav.ekf_online-Tuple{MagNav.INS, Any, MagNav.MagV, Vararg{Any, 5}}"><code>MagNav.ekf_online</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online(ins::INS, meas, flux::MagV, itp_mapS, x0_TL, P0, Qd, R;
           baro_tau   = 3600.0,
           acc_tau    = 3600.0,
           gyro_tau   = 3600.0,
           fogm_tau   = 600.0,
           date       = get_years(2020,185),
           core::Bool = false,
           terms      = [:permanent,:induced,:eddy,:bias],
           Bt_scale   = 50000)</code></pre><p>Extended Kalman filter (EKF) with online learning of Tolles-Lawson coefficients.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>flux</code>:     <code>MagV</code> vector magnetometer measurement struct</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x0_TL</code>:    initial Tolles-Lawson coefficient states</li><li><code>P0</code>:       initial covariance matrix</li><li><code>Qd</code>:       discrete time process/system noise matrix</li><li><code>R</code>:        measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li><li><code>terms</code>:    (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>Bt_scale</code>: (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online.jl#L153-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online_nn-NTuple{19, Any}" href="#MagNav.ekf_online_nn-NTuple{19, Any}"><code>MagNav.ekf_online_nn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online_nn(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas,
              dt, itp_mapS, x_nn, m, y_norms, P0, Qd, R;
              baro_tau   = 3600.0,
              acc_tau    = 3600.0,
              gyro_tau   = 3600.0,
              fogm_tau   = 600.0,
              date       = get_years(2020,185),
              core::Bool = false,
              terms      = [:permanent,:induced,:eddy])</code></pre><p>Extended Kalman filter (EKF) with online learning of neural network weights.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:      latitude  [rad]</li><li><code>lon</code>:      longitude [rad]</li><li><code>alt</code>:      altitude  [m]</li><li><code>vn</code>:       north velocity [m/s]</li><li><code>ve</code>:       east  velocity [m/s]</li><li><code>vd</code>:       down  velocity [m/s]</li><li><code>fn</code>:       north specific force [m/s^2]</li><li><code>fe</code>:       east  specific force [m/s^2]</li><li><code>fd</code>:       down  specific force [m/s^2]</li><li><code>Cnb</code>:      direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>dt</code>:       measurement time step [s]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:     <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>m</code>:        neural network model, does not work with skip connections</li><li><code>y_norms</code>:  length-<code>2</code> tuple of <code>y</code> normalizations, <code>(y_bias,y_scale)</code></li><li><code>P0</code>:       initial covariance matrix</li><li><code>Qd</code>:       discrete time process/system noise matrix</li><li><code>R</code>:        measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li><li><code>terms</code>:    (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online_nn.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online_nn-Tuple{MagNav.INS, Vararg{Any, 8}}" href="#MagNav.ekf_online_nn-Tuple{MagNav.INS, Vararg{Any, 8}}"><code>MagNav.ekf_online_nn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online_nn(ins::INS, meas, itp_mapS, x_nn, m, y_norms, P0, Qd, R;
              baro_tau   = 3600.0,
              acc_tau    = 3600.0,
              gyro_tau   = 3600.0,
              fogm_tau   = 600.0,
              date       = get_years(2020,185),
              core::Bool = false)</code></pre><p>Extended Kalman filter (EKF) with online learning of neural network weights.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:     <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>m</code>:        neural network model, does not work with skip connections</li><li><code>y_norms</code>:  length-<code>2</code> tuple of <code>y</code> normalizations, <code>(y_bias,y_scale)</code></li><li><code>P0</code>:       initial covariance matrix</li><li><code>Qd</code>:       discrete time process/system noise matrix</li><li><code>R</code>:        measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online_nn.jl#L149-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online_nn_setup-NTuple{4, Any}" href="#MagNav.ekf_online_nn_setup-NTuple{4, Any}"><code>MagNav.ekf_online_nn_setup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online_nn_setup(x, y, m, y_norms; N_sigma::Int = 1000)</code></pre><p>Setup for extended Kalman filter (EKF) with online learning of neural network weights.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:       <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:       length-<code>N</code> target vector</li><li><code>m</code>:       neural network model, does not work with skip connections</li><li><code>y_norms</code>: tuple of <code>y</code> normalizations, i.e., <code>(y_bias,y_scale)</code></li><li><code>N_sigma</code>: (optional) number of neural network weights sets to use to create <code>nn_sigma</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>P0_nn</code>:    initial neural network weights covariance matrix</li><li><code>nn_sigma</code>: initial neural network weights estimate std dev</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online_nn.jl#L227-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ekf_online_setup" href="#MagNav.ekf_online_setup"><code>MagNav.ekf_online_setup</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ekf_online_setup(flux::MagV, meas, ind = trues(length(meas));
                 Bt           = sqrt.(flux.x.^2+flux.y.^2+flux.z.^2)[ind],
                 λ            = 0.025,
                 terms        = [:permanent,:induced,:eddy,:bias],
                 pass1        = 0.1,
                 pass2        = 0.9,
                 fs           = 10.0,
                 pole::Int    = 4,
                 trim::Int    = 20,
                 N_sigma::Int = 100,
                 Bt_scale     = 50000)</code></pre><p>Setup for extended Kalman filter (EKF) with online learning of Tolles-Lawson coefficients.</p><p><strong>Arguments:</strong></p><ul><li><code>flux</code>:     <code>MagV</code> vector magnetometer measurement struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>ind</code>:      selected data indices</li><li><code>Bt</code>:       (optional) magnitude of vector magnetometer measurements or scalar magnetometer measurements for modified Tolles-Lawson [nT]</li><li><code>λ</code>:        (optional) ridge parameter</li><li><code>terms</code>:    (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>pass1</code>:    (optional) first passband frequency [Hz]</li><li><code>pass2</code>:    (optional) second passband frequency [Hz]</li><li><code>fs</code>:       (optional) sampling frequency [Hz]</li><li><code>pole</code>:     (optional) number of poles for Butterworth filter</li><li><code>trim</code>:     (optional) number of elements to trim after filtering</li><li><code>N_sigma</code>:  (optional) number of Tolles-Lawson coefficient sets to use to create <code>TL_sigma</code></li><li><code>Bt_scale</code>: (optional) scaling factor for induced &amp; eddy current terms [nT]</li></ul><p><strong>Returns:</strong></p><ul><li><code>x0_TL</code>:    initial Tolles-Lawson coefficient states</li><li><code>P0_TL</code>:    initial Tolles-Lawson covariance matrix</li><li><code>TL_sigma</code>: Tolles-Lawson coefficients estimate std dev</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/ekf_online.jl#L208-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.elasticnet_fit" href="#MagNav.elasticnet_fit"><code>MagNav.elasticnet_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elasticnet_fit(x, y, α::Real = 0.99, no_norm = falses(size(x,2));
               λ::Real           = -1,
               data_norms::Tuple = (zeros(1,1),zeros(1,1),[0.0],[0.0]),
               l_segs::Vector    = [length(y)],
               silent::Bool      = false)</code></pre><p>Fit an elastic net (ridge regression and/or Lasso) model to data.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:          <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:          length-<code>N</code> target vector</li><li><code>α</code>:          (optional) ridge regression (<code>α=0</code>) vs Lasso (<code>α=1</code>) balancing parameter {0:1}</li><li><code>no_norm</code>:    (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>λ</code>:          (optional) elastic net parameter, <code>-1</code> to ignore &amp; determine with cross-validation</li><li><code>data_norms</code>: (optional) length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>l_segs</code>:     (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>model</code>:      length-<code>2</code> tuple of elastic net-based model, (length-<code>Nf</code> coefficients, bias)</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>y_hat</code>:      length-<code>N</code> prediction vector</li><li><code>err</code>:        length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L1852-L1876">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.err_segs-Tuple{Any, Any, Any}" href="#MagNav.err_segs-Tuple{Any, Any, Any}"><code>MagNav.err_segs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">err_segs(y_hat, y, l_segs; silent::Bool = true)</code></pre><p>Remove mean error from multiple individual flight lines within larger dataset.</p><p><strong>Arguments:</strong></p><ul><li><code>y_hat</code>:  length-<code>N</code> prediction vector</li><li><code>y</code>:      length-<code>N</code> target vector</li><li><code>l_segs</code>: length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>: (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>err</code>: length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1298-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.euler2dcm" href="#MagNav.euler2dcm"><code>MagNav.euler2dcm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">euler2dcm(roll, pitch, yaw, order::Symbol = :body2nav)</code></pre><p>Converts a (Euler) roll-pitch-yaw (<code>X</code>-<code>Y</code>-<code>Z</code>) right-handed body to navigation frame rotation (or the opposite rotation), to a DCM (direction cosine matrix). Yaw is synonymous with azimuth and heading here. If frame 1 is rotated to frame 2, then the returned DCM, when pre-multiplied, rotates a vector in frame 1 into frame 2. There are 2 use cases:</p><ol><li>With <code>order = :body2nav</code>, the body frame is rotated in the standard</li></ol><p>-roll, -pitch, -yaw sequence to the navigation frame. For example, if v1 is a 3x1 vector in the body frame [nose, right wing, down], then that vector rotated into the navigation frame [north, east, down] would be v2 = dcm * v1.</p><ol><li>With <code>order = :nav2body</code>, the navigation frame is rotated in the standard</li></ol><p>yaw, pitch, roll sequence to the body frame. For example, if v1 is a 3x1 vector in the navigation frame [north, east, down], then that vector rotated into the body frame [nose, right wing, down] would be v2 = dcm * v1.</p><p>Reference: Titterton &amp; Weston, Strapdown Inertial Navigation Technology, 2004, Section 3.6 (pg. 36-41 &amp; 537).</p><p><strong>Arguments:</strong></p><ul><li><code>roll</code>:  length-<code>N</code> roll  angle [rad], right-handed rotation about x-axis</li><li><code>pitch</code>: length-<code>N</code> pitch angle [rad], right-handed rotation about y-axis</li><li><code>yaw</code>:   length-<code>N</code> yaw   angle [rad], right-handed rotation about z-axis</li><li><code>order</code>: (optional) rotation order {<code>:body2nav</code>,<code>:nav2body</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>dcm</code>: <code>3</code> x <code>3</code> x <code>N</code> direction cosine matrix [-]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/dcm.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_crlb-Tuple{MagNav.Traj, Array}" href="#MagNav.eval_crlb-Tuple{MagNav.Traj, Array}"><code>MagNav.eval_crlb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_crlb(traj::Traj, crlb_P::Array)</code></pre><p>Extract Cramér–Rao lower bound (CRLB) results.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:   <code>Traj</code> trajectory struct</li><li><code>crlb_P</code>: Cramér–Rao lower bound non-linear covariance matrix</li></ul><p><strong>Returns:</strong></p><ul><li><code>crlb_out</code>: <code>CRLBout</code> Cramér–Rao lower bound extracted output struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L249-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_filt-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTres}" href="#MagNav.eval_filt-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTres}"><code>MagNav.eval_filt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_filt(traj::Traj, ins::INS, filt_res::FILTres)</code></pre><p>Extract filter results.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:     <code>Traj</code> trajectory struct</li><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_out</code>: <code>FILTout</code> filter extracted output struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L327-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_gsa" href="#MagNav.eval_gsa"><code>MagNav.eval_gsa</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_gsa(m::Chain, x, n::Int = min(10000,size(x,1)))</code></pre><p>Global sensitivity analysis (GSA) with the Morris Method.</p><p>Reference: https://book.sciml.ai/notes/17-Global<em>Sensitivity</em>Analysis/</p><p>Reference: https://docs.sciml.ai/GlobalSensitivity/stable/methods/morris/</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>: neural network model</li><li><code>x</code>: <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>n</code>: (optional) number of samples (instances) to use for explanation</li></ul><p><strong>Returns:</strong></p><ul><li><code>means</code>: means of elementary effects</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2080-L2096">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_ins-Tuple{MagNav.Traj, MagNav.INS}" href="#MagNav.eval_ins-Tuple{MagNav.Traj, MagNav.INS}"><code>MagNav.eval_ins</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_ins(traj::Traj, ins::INS)</code></pre><p>Extract INS results.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>: <code>Traj</code> trajectory struct</li><li><code>ins</code>:  <code>INS</code> inertial navigation system struct</li></ul><p><strong>Returns:</strong></p><ul><li><code>ins_out</code>: <code>INSout</code> inertial navigation system extracted output struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L287-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_results-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTres, Array}" href="#MagNav.eval_results-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTres, Array}"><code>MagNav.eval_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_results(traj::Traj, ins::INS, filt_res::FILTres, crlb_P::Array)</code></pre><p>Extract CRLB, INS, &amp; filter results.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:     <code>Traj</code> trajectory struct</li><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li><li><code>crlb_P</code>:   Cramér–Rao lower bound non-linear covariance matrix</li></ul><p><strong>Returns:</strong></p><ul><li><code>crlb_out</code>: <code>CRLBout</code> Cramér–Rao lower bound extracted output struct</li><li><code>ins_out</code>:  <code>INSout</code>  inertial navigation system extracted output struct</li><li><code>filt_out</code>: <code>FILTout</code> filter extracted output struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L227-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.eval_shapley" href="#MagNav.eval_shapley"><code>MagNav.eval_shapley</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_shapley(m::Chain, x, features::Vector{Symbol},
             N::Int      = min(10000,size(x,1)),
             num_mc::Int = 10)</code></pre><p>Compute stochastic Shapley effects for global feature importance.</p><p>Reference: https://nredell.github.io/ShapML.jl/dev/#Examples-1</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>:        neural network model</li><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>N</code>:        (optional) number of samples (instances) to use for explanation</li><li><code>num_mc</code>:   (optional) number of Monte Carlo simulations</li></ul><p><strong>Returns:</strong></p><ul><li><code>df_shap</code>:       DataFrame of Shapley effects</li><li><code>baseline_shap</code>: intercept of Shapley effects</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1987-L2006">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.fdm-Tuple{Vector}" href="#MagNav.fdm-Tuple{Vector}"><code>MagNav.fdm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdm(x::Vector; scheme::Symbol = :central)</code></pre><p>Finite difference method (FDM) applied to <code>x</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:      data vector</li><li><code>scheme</code>: (optional) finite difference method scheme used<ul><li><code>backward</code>:  1st derivative 1st-order backward difference</li><li><code>forward</code>:   1st derivative 1st-order forward  difference</li><li><code>central</code>:   1st derivative 2nd-order central  difference</li><li><code>backward2</code>: 1st derivative 2nd-order backward difference</li><li><code>forward2</code>:  1st derivative 2nd-order forward  difference</li><li><code>fourth</code>:    4th derivative central difference</li></ul></li></ul><p><strong>Returns:</strong></p><ul><li><code>dif</code>: vector of finite differences (length of <code>x</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/tolles_lawson.jl#L316-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.filter_events!-Tuple{Symbol, DataFrames.DataFrame}" href="#MagNav.filter_events!-Tuple{Symbol, DataFrames.DataFrame}"><code>MagNav.filter_events!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_events!(flight::Symbol, df_event::DataFrame;
               keyword::String = &quot;&quot;,
               tt_lim::Tuple   = ())</code></pre><p>Filter a DataFrame of in-flight events to only contain relevant events.</p><p><strong>Arguments:</strong></p><ul><li><code>flight</code>:   flight name (e.g., <code>:Flt1001</code>)</li><li><code>df_event</code>: lookup table (DataFrame) of in-flight events</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">time of <code>event</code> [s]</td></tr><tr><td style="text-align: left"><code>event</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">event description</td></tr></table><ul><li><code>keyword</code>:  (optional) keyword to search within events, case insensitive</li><li><code>tt_lim</code>:   (optional) length-<code>2</code> start &amp; end time limits (inclusive) [s]</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>df_event</code> is filtered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2347-L2367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.filter_events-Tuple{Symbol, DataFrames.DataFrame}" href="#MagNav.filter_events-Tuple{Symbol, DataFrames.DataFrame}"><code>MagNav.filter_events</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter_events(flight::Symbol, df_event::DataFrame;
              keyword::String = &quot;&quot;,
              tt_lim::Tuple   = ())</code></pre><p>Filter a DataFrame of in-flight events to only contain relevant events.</p><p><strong>Arguments:</strong></p><ul><li><code>flight</code>:   flight name (e.g., <code>:Flt1001</code>)</li><li><code>df_event</code>: lookup table (DataFrame) of in-flight events</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">time of <code>event</code> [s]</td></tr><tr><td style="text-align: left"><code>event</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">event description</td></tr></table><ul><li><code>keyword</code>:  (optional) keyword to search within events, case insensitive</li><li><code>tt_lim</code>:   (optional) length-<code>2</code> start &amp; end time limits (inclusive) [s]</li></ul><p><strong>Returns:</strong></p><ul><li><code>df_event</code>: lookup table (DataFrame) of in-flight events, filtered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2379-L2399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.fogm-NTuple{4, Any}" href="#MagNav.fogm-NTuple{4, Any}"><code>MagNav.fogm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fogm(sigma, tau, dt, N)</code></pre><p>First-order Gauss-Markov stochastic process. Represents unmeasureable time-correlated errors.</p><p><strong>Arguments:</strong></p><ul><li><code>sigma</code>: FOGM catch-all bias</li><li><code>tau</code>:   FOGM catch-all time constant [s]</li><li><code>dt</code>:    measurement time step [s]</li><li><code>N</code>:     number of samples (instances)</li></ul><p><strong>Returns:</strong></p><ul><li><code>x</code>: FOGM data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/model_functions.jl#L661-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_Axy" href="#MagNav.get_Axy"><code>MagNav.get_Axy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_Axy(lines, df_line::DataFrame,
        df_flight::DataFrame, df_map::DataFrame,
        features_setup::Vector{Symbol}   = [:mag_1_uc,:TL_A_flux_a];
        features_no_norm::Vector{Symbol} = Symbol[],
        y_type::Symbol     = :d,
        use_mag::Symbol    = :mag_1_uc,
        use_mag_c::Symbol  = :mag_1_c,
        use_vec::Symbol    = :flux_a,
        terms              = [:permanent,:induced,:eddy],
        terms_A            = [:permanent,:induced,:eddy,:bias],
        sub_diurnal::Bool  = false,
        sub_igrf::Bool     = false,
        bpf_mag::Bool      = false,
        reorient_vec::Bool = false,
        l_window::Int      = -1,
        mod_TL::Bool       = false,
        map_TL::Bool       = false,
        return_B::Bool     = false,
        silent::Bool       = true)</code></pre><p>Get &quot;external&quot; Tolles-Lawson <code>A</code> matrix, <code>x</code> data matrix, &amp; <code>y</code> target vector from multiple flight lines, possibly multiple flights. Optionally return <code>Bt</code> &amp; <code>B_dot</code> used to create the &quot;external&quot; Tolles-Lawson <code>A</code> matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code>, only used for <code>y_type = :b, :c</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>features_setup</code>:   vector of features to include</li><li><code>features_no_norm</code>: (optional) vector of features to not normalize</li><li><code>y_type</code>: (optional) <code>y</code> target type<ul><li><code>:a</code> = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements</li><li><code>:b</code> = anomaly field  #2, interpolated <code>magnetic anomaly map</code> values</li><li><code>:c</code> = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated <code>magnetic anomaly map</code> values</li><li><code>:d</code> = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements</li><li><code>:e</code> = BPF&#39;d total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements</li></ul></li><li><code>use_mag</code>:      (optional) uncompensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_uc</code>, etc.}, only used for <code>y_type = :c, :d, :e</code></li><li><code>use_mag_c</code>:    (optional) compensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_c</code>, etc.}, only used for <code>y_type = :a, :d</code></li><li><code>use_vec</code>:      (optional) vector magnetometer (fluxgate) to use for &quot;external&quot; Tolles-Lawson <code>A</code> matrix {<code>:flux_a</code>, etc.}</li><li><code>terms</code>:        (optional) Tolles-Lawson terms to use for <code>A</code> within <code>x</code> data matrix {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>terms_A</code>:      (optional) Tolles-Lawson terms to use for &quot;external&quot; Tolles-Lawson <code>A</code> matrix {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>sub_diurnal</code>:  (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:     (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>bpf_mag</code>:      (optional) if true, bpf scalar magnetometer measurements in <code>x</code> data matrix</li><li><code>reorient_vec</code>: (optional) if true, align vector magnetometer measurements with body frame</li><li><code>l_window</code>:     (optional) trim data by <code>N % l_window</code>, <code>-1</code> to ignore</li><li><code>mod_TL</code>:       (optional) if true, create modified  &quot;external&quot; Tolles-Lawson <code>A</code> matrix with <code>use_mag</code></li><li><code>map_TL</code>:       (optional) if true, create map-based &quot;external&quot; Tolles-Lawson <code>A</code> matrix</li><li><code>return_B</code>:     (optional) if true, also return <code>Bt</code> &amp; <code>B_dot</code></li><li><code>silent</code>:       (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>A</code>:        <code>N</code> x <code>N_TL</code> &quot;external&quot; Tolles-Lawson <code>A</code> matrix (<code>N_TL</code> is number of Tolles-Lawson coefficients)</li><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:        length-<code>N</code> target vector</li><li><code>no_norm</code>:  length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>l_segs</code>:   length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>Bt</code>:       if <code>return_B = true</code>, length-<code>N</code> magnitude of total field measurements used to create <code>A</code> [nT]</li><li><code>B_dot</code>:    if <code>return_B = true</code>, <code>N</code> x <code>3</code> finite differences of total field vector used to create <code>A</code> [nT]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L785-L864">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ-Tuple{Symbol, DataFrames.DataFrame}" href="#MagNav.get_XYZ-Tuple{Symbol, DataFrames.DataFrame}"><code>MagNav.get_XYZ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ(flight::Symbol, df_flight::DataFrame;
        tt_sort::Bool      = true,
        reorient_vec::Bool = false,
        silent::Bool       = false)</code></pre><p>Get <code>XYZ</code> flight data from saved HDF5 file via DataFrame lookup.</p><p><strong>Arguments:</strong></p><ul><li><code>flight</code>:    flight name (e.g., <code>:Flt1001</code>)</li><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>tt_sort</code>:      (optional) if true, sort data by time (instead of line)</li><li><code>reorient_vec</code>: (optional) if true, align vector magnetometer measurements with body frame</li><li><code>silent</code>:       (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1430-L1453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ0" href="#MagNav.get_XYZ0"><code>MagNav.get_XYZ0</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ0(xyz_file::String,
         traj_field::Symbol = :traj,
         ins_field::Symbol  = :ins_data;
         info::String       = splitpath(xyz_file)[end],
         flight             = 1,
         line               = 1,
         year               = 2023,
         doy                = 154,
         dt                 = 0.1,
         tt_sort::Bool      = true,
         silent::Bool       = false)</code></pre><p>Get the minimum dataset required for MagNav from saved CSV, HDF5, or MAT file. Not all fields within the <code>XYZ0</code> flight data struct are required. The minimum data required in the CSV, HDF5, or MAT file includes:</p><ul><li><code>lat</code>, <code>lon</code>, <code>alt</code> (position)</li><li><code>mag_1_c</code> OR <code>mag_1_uc</code> (scalar magnetometer measurements)</li></ul><p>All other fields can be computed/simulated.</p><p>If a CSV or HDF5 file is provided, the possible columns/fields in the file are:</p><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">measurement time step [s]</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">time [s]</td></tr><tr><td style="text-align: left"><code>lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">latitude  [deg]</td></tr><tr><td style="text-align: left"><code>lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">longitude [deg]</td></tr><tr><td style="text-align: left"><code>alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">altitude  [m]</td></tr><tr><td style="text-align: left"><code>vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>roll</code>, <code>pitch</code>, &amp; <code>yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">roll [deg]</td></tr><tr><td style="text-align: left"><code>pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">pitch [deg]</td></tr><tr><td style="text-align: left"><code>yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">yaw [deg]</td></tr><tr><td style="text-align: left"><code>ins_dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">INS measurement time step [s]</td></tr><tr><td style="text-align: left"><code>ins_tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS time [s]</td></tr><tr><td style="text-align: left"><code>ins_lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS latitude  [deg]</td></tr><tr><td style="text-align: left"><code>ins_lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS longitude [deg]</td></tr><tr><td style="text-align: left"><code>ins_alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS altitude  [m]</td></tr><tr><td style="text-align: left"><code>ins_vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">INS direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>ins_roll</code>, <code>ins_pitch</code>, &amp; <code>ins_yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>ins_roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS roll [deg]</td></tr><tr><td style="text-align: left"><code>ins_pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS pitch [deg]</td></tr><tr><td style="text-align: left"><code>ins_yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS yaw [deg]</td></tr><tr><td style="text-align: left"><code>ins_P</code></td><td style="text-align: left">17x17xN</td><td style="text-align: left">INS covariance matrix, only relevant for simulated data, otherwise zeros [-], not valid for CSV file</td></tr><tr><td style="text-align: left"><code>flux_a_x</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A x-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_y</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A y-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_z</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A z-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_t</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A total magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left">vector</td><td style="text-align: left">flight number(s)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left">vector</td><td style="text-align: left">line number(s), i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>year</code></td><td style="text-align: left">vector</td><td style="text-align: left">year</td></tr><tr><td style="text-align: left"><code>doy</code></td><td style="text-align: left">vector</td><td style="text-align: left">day of year</td></tr><tr><td style="text-align: left"><code>diurnal</code></td><td style="text-align: left">vector</td><td style="text-align: left">measured diurnal, i.e., temporal variations or space weather effects [nT]</td></tr><tr><td style="text-align: left"><code>igrf</code></td><td style="text-align: left">vector</td><td style="text-align: left">International Geomagnetic Reference Field (IGRF), i.e., core field [nT]</td></tr><tr><td style="text-align: left"><code>mag_1_c</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 1 compensated (clean) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_1_uc</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]</td></tr></table><p>If a MAT file is provided, the above fields may also be provided, but the non-INS fields should be within the specified <code>traj_field</code> MAT struct and the INS fields should be within the specified <code>ins_field</code> MAT struct and without <code>ins_</code> prefixes. This is the standard way the MATLAB-companion outputs data.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_file</code>:   path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</li><li><code>traj_field</code>: (optional) trajectory struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>ins_field</code>:  (optional) INS struct field within MAT file to use, <code>:none</code> if unavailable, not relevant for CSV or HDF5 file</li><li><code>tt_sort</code>:    (optional) if true, sort data by time (instead of line)</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p>If not provided in <code>xyz_file</code>:</p><ul><li><code>info</code>:   (optional) flight data information</li><li><code>flight</code>: (optional) flight number</li><li><code>line</code>:   (optional) line number, i.e., segment within <code>flight</code></li><li><code>year</code>:   (optional) year</li><li><code>doy</code>:    (optional) day of year</li><li><code>dt</code>:     (optional) measurement time step [s]</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ0</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ1" href="#MagNav.get_XYZ1"><code>MagNav.get_XYZ1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ1(xyz_file::String,
         traj_field::Symbol = :traj,
         ins_field::Symbol  = :ins_data;
         info::String       = splitpath(xyz_file)[end],
         flight             = 1,
         line               = 1,
         year               = 2023,
         doy                = 154,
         dt                 = 0.1,
         tt_sort::Bool      = true,
         silent::Bool       = false)</code></pre><p>Get the minimum dataset required for MagNav from saved CSV, HDF5, or MAT file. Not all fields within the <code>XYZ1</code> flight data struct are required. The minimum data required in the CSV, HDF5, or MAT file includes:</p><ul><li><code>lat</code>, <code>lon</code>, <code>alt</code> (position)</li><li><code>mag_1_c</code> OR <code>mag_1_uc</code> (scalar magnetometer measurements)</li></ul><p>All other fields can be computed/simulated, except <code>flux_b</code>, <code>mag_2_c</code>, <code>mag_3_c</code>, <code>mag_2_uc</code>, <code>mag_3_uc</code>, <code>aux_1</code>, <code>aux_2</code>, and <code>aux_3</code>.</p><p>If a CSV or HDF5 file is provided, the possible columns/fields in the file are:</p><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">measurement time step [s]</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">time [s]</td></tr><tr><td style="text-align: left"><code>lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">latitude  [deg]</td></tr><tr><td style="text-align: left"><code>lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">longitude [deg]</td></tr><tr><td style="text-align: left"><code>alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">altitude  [m]</td></tr><tr><td style="text-align: left"><code>vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>roll</code>, <code>pitch</code>, &amp; <code>yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">roll [deg]</td></tr><tr><td style="text-align: left"><code>pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">pitch [deg]</td></tr><tr><td style="text-align: left"><code>yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">yaw [deg]</td></tr><tr><td style="text-align: left"><code>ins_dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">INS measurement time step [s]</td></tr><tr><td style="text-align: left"><code>ins_tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS time [s]</td></tr><tr><td style="text-align: left"><code>ins_lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS latitude  [deg]</td></tr><tr><td style="text-align: left"><code>ins_lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS longitude [deg]</td></tr><tr><td style="text-align: left"><code>ins_alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS altitude  [m]</td></tr><tr><td style="text-align: left"><code>ins_vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">INS direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>ins_roll</code>, <code>ins_pitch</code>, &amp; <code>ins_yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>ins_roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS roll [deg]</td></tr><tr><td style="text-align: left"><code>ins_pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS pitch [deg]</td></tr><tr><td style="text-align: left"><code>ins_yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS yaw [deg]</td></tr><tr><td style="text-align: left"><code>ins_P</code></td><td style="text-align: left">17x17xN</td><td style="text-align: left">INS covariance matrix, only relevant for simulated data, otherwise zeros [-], not valid for CSV file</td></tr><tr><td style="text-align: left"><code>flux_a_x</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A x-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_y</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A y-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_z</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A z-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_a_t</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux A total magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_b_x</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux B x-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_b_y</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux B y-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_b_z</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux B z-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flux_b_t</code></td><td style="text-align: left">vector</td><td style="text-align: left">Flux B total magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left">vector</td><td style="text-align: left">flight number(s)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left">vector</td><td style="text-align: left">line number(s), i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>year</code></td><td style="text-align: left">vector</td><td style="text-align: left">year</td></tr><tr><td style="text-align: left"><code>doy</code></td><td style="text-align: left">vector</td><td style="text-align: left">day of year</td></tr><tr><td style="text-align: left"><code>diurnal</code></td><td style="text-align: left">vector</td><td style="text-align: left">measured diurnal, i.e., temporal variations or space weather effects [nT]</td></tr><tr><td style="text-align: left"><code>igrf</code></td><td style="text-align: left">vector</td><td style="text-align: left">International Geomagnetic Reference Field (IGRF), i.e., core field [nT]</td></tr><tr><td style="text-align: left"><code>mag_1_c</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 1 compensated (clean) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_2_c</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 2 compensated (clean) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_3_c</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 3 compensated (clean) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_1_uc</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 1 uncompensated (corrupted) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_2_uc</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 2 uncompensated (corrupted) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>mag_3_uc</code></td><td style="text-align: left">vector</td><td style="text-align: left">Mag 3 uncompensated (corrupted) scalar magnetometer measurements [nT]</td></tr><tr><td style="text-align: left"><code>aux_1</code></td><td style="text-align: left">vector</td><td style="text-align: left">flexible-use auxiliary data 1</td></tr><tr><td style="text-align: left"><code>aux_2</code></td><td style="text-align: left">vector</td><td style="text-align: left">flexible-use auxiliary data 2</td></tr><tr><td style="text-align: left"><code>aux_3</code></td><td style="text-align: left">vector</td><td style="text-align: left">flexible-use auxiliary data 3</td></tr></table><p>If a MAT file is provided, the above fields may also be provided, but the non-INS fields should be within the specified <code>traj_field</code> MAT struct and the INS fields should be within the specified <code>ins_field</code> MAT struct and without <code>ins_</code> prefixes. This is the standard way the MATLAB-companion outputs data.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_file</code>:   path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</li><li><code>traj_field</code>: (optional) trajectory struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>ins_field</code>:  (optional) INS struct field within MAT file to use, <code>:none</code> if unavailable, not relevant for CSV or HDF5 file</li><li><code>tt_sort</code>:    (optional) if true, sort data by time (instead of line)</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p>If not provided in <code>xyz_file</code>:</p><ul><li><code>info</code>:   (optional) flight data information</li><li><code>flight</code>: (optional) flight number</li><li><code>line</code>:   (optional) line number, i.e., segment within <code>flight</code></li><li><code>year</code>:   (optional) year</li><li><code>doy</code>:    (optional) day of year</li><li><code>dt</code>:     (optional) measurement time step [s]</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ1</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L257-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ20-Tuple{String, String}" href="#MagNav.get_XYZ20-Tuple{String, String}"><code>MagNav.get_XYZ20</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ20(xyz_160_h5::String, xyz_h5::String;
          info::String = splitpath(xyz_160_h5)[end] * &quot; &amp; &quot; * splitpath(xyz_h5)[end],
          silent::Bool = false)</code></pre><p>Get 160 Hz (partial) <code>XYZ20</code> flight data from saved HDF5 file and combine with 10 Hz <code>XYZ20</code> flight data from another saved HDF5 file. Data is time sorted to ensure data is aligned.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_160_h5</code>: path/name of 160 Hz flight data HDF5 file (<code>.h5</code> extension optional)</li><li><code>xyz_h5</code>:     path/name of 10  Hz flight data HDF5 file (<code>.h5</code> extension optional)</li><li><code>info</code>:       (optional) flight data information</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ20</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1252-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ20-Tuple{String}" href="#MagNav.get_XYZ20-Tuple{String}"><code>MagNav.get_XYZ20</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ20(xyz_h5::String;
          info::String  = splitpath(xyz_h5)[end],
          tt_sort::Bool = true,
          silent::Bool  = false)</code></pre><p>Get <code>XYZ20</code> flight data from saved HDF5 file. Based on 2020 SGL data fields.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_h5</code>:  path/name of flight data HDF5 file (<code>.h5</code> extension optional)</li><li><code>info</code>:    (optional) flight data information</li><li><code>tt_sort</code>: (optional) if true, sort data by time (instead of line)</li><li><code>silent</code>:  (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ20</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1130-L1146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_XYZ21-Tuple{String}" href="#MagNav.get_XYZ21-Tuple{String}"><code>MagNav.get_XYZ21</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_XYZ21(xyz_h5::String;
          info::String  = splitpath(xyz_h5)[end],
          tt_sort::Bool = true,
          silent::Bool  = false)</code></pre><p>Get <code>XYZ21</code> flight data from saved HDF5 file. Based on 2021 SGL data fields.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_h5</code>:  path/name of flight data HDF5 file (<code>.h5</code> extension optional)</li><li><code>info</code>:    (optional) flight data information</li><li><code>tt_sort</code>: (optional) if true, sort data by time (instead of line)</li><li><code>silent</code>:  (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>xyz</code>: <code>XYZ21</code> flight data struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1320-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_autocor" href="#MagNav.get_autocor"><code>MagNav.get_autocor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_autocor(x::Vector, dt = 0.1, dt_max = 300.0)</code></pre><p>Get autocorrelation of data (e.g., actual - expected measurements).</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:      data vector</li><li><code>dt</code>:     (optional) measurement time step [s]</li><li><code>dt_max</code>: (optional) maximum time step to evaluate [s]</li></ul><p><strong>Returns:</strong></p><ul><li><code>sigma</code>: standard deviation</li><li><code>tau</code>:   autocorrelation decay to e^-1 of <code>x</code> [s]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L888-L901">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_bpf-Tuple{}" href="#MagNav.get_bpf-Tuple{}"><code>MagNav.get_bpf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_bpf(; pass1 = 0.1, pass2 = 0.9, fs = 10.0, pole::Int = 4)</code></pre><p>Create a Butterworth bandpass (or low-pass or high-pass) filter object. Set <code>pass1 = -1</code> for low-pass filter or <code>pass2 = -1</code> for high-pass filter.</p><p><strong>Arguments:</strong></p><ul><li><code>pass1</code>: (optional) first  passband frequency [Hz]</li><li><code>pass2</code>: (optional) second passband frequency [Hz]</li><li><code>fs</code>:    (optional) sampling frequency [Hz]</li><li><code>pole</code>:  (optional) number of poles for Butterworth filter</li></ul><p><strong>Returns:</strong></p><ul><li><code>bpf</code>: filter object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_cached_map-Tuple{Map_Cache, Real, Real, Real}" href="#MagNav.get_cached_map-Tuple{Map_Cache, Real, Real, Real}"><code>MagNav.get_cached_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_cached_map(map_cache::Map_Cache, lat::Real, lon::Real, alt::Real;
               silent::Bool = false)</code></pre><p>Get cached map at specific location.</p><p><strong>Arguments:</strong></p><ul><li><code>map_cache</code>: <code>Map_Cache</code> map cache struct</li><li><code>lat</code>:       latitude  [rad]</li><li><code>lon</code>:       longitude [rad]</li><li><code>alt</code>:       altitude  [m]</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> at <code>alt</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2525-L2540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_comp_params" href="#MagNav.get_comp_params"><code>MagNav.get_comp_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_comp_params(comp_params_bson::String, silent::Bool = false)</code></pre><p>Get aeromagnetic compensation parameters from saved BSON file.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params_bson</code>: path/name of aeromagnetic compensation parameters BSON file (<code>.bson</code> extension optional)</li><li><code>silent</code>:           (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L336-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_days_in_year-Tuple{Any}" href="#MagNav.get_days_in_year-Tuple{Any}"><code>MagNav.get_days_in_year</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_days_in_year(year)</code></pre><p>Internal helper function to get days in year based on (rounded down) year.</p><p><strong>Arguments:</strong></p><ul><li><code>year</code>: year (rounded down)</li></ul><p><strong>Returns:</strong></p><ul><li><code>days_in_year</code>: days in <code>year</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2265-L2275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_flux" href="#MagNav.get_flux"><code>MagNav.get_flux</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_flux(flux_file::String,
         use_vec::Symbol = :flux_a,
         field::Symbol   = :traj)</code></pre><p>Get vector magnetometer data from saved CSV, HDF5, or MAT file.</p><p>If a CSV or HDF5 file is provided, the possible columns/fields in the file are:</p><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>use_vec</code>*<code>_x</code></td><td style="text-align: left">vector</td><td style="text-align: left">x-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>use_vec</code>*<code>_y</code></td><td style="text-align: left">vector</td><td style="text-align: left">y-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>use_vec</code>*<code>_z</code></td><td style="text-align: left">vector</td><td style="text-align: left">z-direction magnetic field [nT]</td></tr><tr><td style="text-align: left"><code>use_vec</code>*<code>_t</code></td><td style="text-align: left">vector</td><td style="text-align: left">total magnetic field [nT], optional</td></tr></table><p>If a MAT file is provided, the above fields may also be provided, but they should be within the specified <code>field</code> MAT struct. This is the standard way the MATLAB-companion outputs data.</p><p><strong>Arguments:</strong></p><ul><li><code>flux_file</code>: path/name of vector magnetometer data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</li><li><code>use_vec</code>:   (optional) vector magnetometer (fluxgate) to use</li><li><code>field</code>:     (optional) struct field within MAT file to use, not relevant for CSV or HDF5 file</li></ul><p><strong>Returns:</strong></p><ul><li><code>flux</code>: <code>MagV</code> vector magnetometer measurement struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L467-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_igrf" href="#MagNav.get_igrf"><code>MagNav.get_igrf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_igrf(xyz::XYZ, ind = trues(xyz.traj.N);
         frame::Symbol   = :body,
         norm_igrf::Bool = false,
         check_xyz::Bool = true)</code></pre><p>Get the IGRF Earth vector in the body or navigation frame given an <code>XYZ</code> flight data struct containing trajectory information, valid indices, a start date in IGRF time (years since 0 CE), and reference frame.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:       <code>XYZ</code> flight data struct</li><li><code>ind</code>:       (optional) selected data indices</li><li><code>frame</code>:     (optional) desired reference frame {<code>:body</code>,<code>:nav</code>}</li><li><code>norm_igrf</code>: (optional) if true, normalize <code>igrf_vec</code></li><li><code>check_xyz</code>: (optional) if true, cross-check with <code>igrf</code> field in <code>xyz</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>igrf_vec</code>: length-<code>N</code> stacked vector of <code>3</code> IGRF coordinates in <code>frame</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2109-L2128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ind-Tuple{MagNav.XYZ, Any, DataFrames.DataFrame}" href="#MagNav.get_ind-Tuple{MagNav.XYZ, Any, DataFrames.DataFrame}"><code>MagNav.get_ind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ind(xyz::XYZ, lines, df_line::DataFrame;
        splits        = (1),
        l_window::Int = -1)</code></pre><p>Get BitVector of selected data indices for further analysis via DataFrame lookup.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:     <code>XYZ</code> flight data struct</li><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>splits</code>:   (optional) data splits, must sum to 1</li><li><code>l_window</code>: (optional) trim data by <code>N % l_window</code>, <code>-1</code> to ignore</li></ul><p><strong>Returns:</strong></p><ul><li><code>ind</code>: BitVector (or tuple of BitVector) of selected data indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1728-L1751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ind-Tuple{MagNav.XYZ, Real, DataFrames.DataFrame}" href="#MagNav.get_ind-Tuple{MagNav.XYZ, Real, DataFrames.DataFrame}"><code>MagNav.get_ind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ind(xyz::XYZ, line::Real, df_line::DataFrame;
        splits        = (1),
        l_window::Int = -1)</code></pre><p>Get BitVector of indices for further analysis via DataFrame lookup.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:     <code>XYZ</code> flight data struct</li><li><code>line</code>:    line number</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>splits</code>:   (optional) data splits, must sum to 1</li><li><code>l_window</code>: (optional) trim data by <code>N % l_window</code>, <code>-1</code> to ignore</li></ul><p><strong>Returns:</strong></p><ul><li><code>ind</code>: BitVector (or tuple of BitVector) of selected data indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1672-L1695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ind-Tuple{MagNav.XYZ}" href="#MagNav.get_ind-Tuple{MagNav.XYZ}"><code>MagNav.get_ind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ind(xyz::XYZ;
        ind    = trues(xyz.traj.N),
        lines  = (),
        tt_lim = (),
        splits = (1))</code></pre><p>Get BitVector of indices for further analysis from specified indices (subset), lines, and/or time range. Any or all of these may be used. Defaults to use all indices, lines, and times.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:    <code>XYZ</code> flight data struct</li><li><code>ind</code>:    (optional) selected data indices</li><li><code>lines</code>:  (optional) selected line number(s)</li><li><code>tt_lim</code>: (optional) end time limit or length-<code>2</code> start &amp; end time limits (inclusive) [s]</li><li><code>splits</code>: (optional) data splits, must sum to 1</li></ul><p><strong>Returns:</strong></p><ul><li><code>ind</code>: BitVector (or tuple of BitVector) of selected data indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1637-L1657">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ind-Tuple{Vector, Vector}" href="#MagNav.get_ind-Tuple{Vector, Vector}"><code>MagNav.get_ind</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ind(tt::Vector, line::Vector;
        ind    = trues(length(tt)),
        lines  = (),
        tt_lim = (),
        splits = (1))</code></pre><p>Get BitVector of indices for further analysis from specified indices (subset), lines, and/or time range. Any or all of these may be used. Defaults to use all indices, lines, and times.</p><p><strong>Arguments:</strong></p><ul><li><code>tt</code>:     time [s]</li><li><code>line</code>:   line number(s)</li><li><code>ind</code>:    (optional) selected data indices</li><li><code>lines</code>:  (optional) selected line number(s)</li><li><code>tt_lim</code>: (optional) end time limit or length-<code>2</code> start &amp; end time limits (inclusive) [s]</li><li><code>splits</code>: (optional) data splits, must sum to 1</li></ul><p><strong>Returns:</strong></p><ul><li><code>ind</code>: BitVector (or tuple of BitVector) of selected data indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1563-L1584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ins" href="#MagNav.get_ins"><code>MagNav.get_ins</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ins(xyz::XYZ, ind = trues(xyz.traj.N);
        N_zero_ll::Int  = 0,
        t_zero_ll::Real = 0,
        err::Real       = 0.0)</code></pre><p>Get inertial navigation system data at specific indices, possibly zeroed.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:       <code>XYZ</code> flight data struct</li><li><code>ind</code>:       (optional) selected data indices</li><li><code>N_zero_ll</code>: (optional) number of samples (instances) to zero INS lat/lon to truth (<code>xyz.traj</code>)</li><li><code>t_zero_ll</code>: (optional) length of time to zero INS lat/lon to truth (<code>xyz.traj</code>), overwrites <code>N_zero_ll</code></li><li><code>err</code>:       (optional) additional position error [m]</li></ul><p><strong>Returns:</strong></p><ul><li><code>ins</code>: <code>INS</code> inertial navigation system struct at <code>ind</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L949-L966">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_ins" href="#MagNav.get_ins"><code>MagNav.get_ins</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ins(ins_file::String, field::Symbol = :ins_data;
        dt            = 0.1,
        tt_sort::Bool = true,
        silent::Bool  = false)</code></pre><p>Get inertial navigation system data from saved CSV, HDF5, or MAT file. The only required fields are <code>ins_lat</code>, <code>ins_lon</code>, and <code>ins_alt</code> (position).</p><p>If a CSV or HDF5 file is provided, the possible columns/fields in the file are:</p><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>ins_dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">INS measurement time step [s]</td></tr><tr><td style="text-align: left"><code>ins_tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS time [s]</td></tr><tr><td style="text-align: left"><code>ins_lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS latitude  [deg]</td></tr><tr><td style="text-align: left"><code>ins_lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS longitude [deg]</td></tr><tr><td style="text-align: left"><code>ins_alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS altitude  [m]</td></tr><tr><td style="text-align: left"><code>ins_vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>ins_Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">INS direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>ins_roll</code>, <code>ins_pitch</code>, &amp; <code>ins_yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>ins_roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS roll [deg]</td></tr><tr><td style="text-align: left"><code>ins_pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS pitch [deg]</td></tr><tr><td style="text-align: left"><code>ins_yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">INS yaw [deg]</td></tr><tr><td style="text-align: left"><code>ins_P</code></td><td style="text-align: left">17x17xN</td><td style="text-align: left">INS covariance matrix, only relevant for simulated data, otherwise zeros [-], not valid for CSV file</td></tr></table><p>If a MAT file is provided, the above fields may also be provided, but they should be within the specified <code>field</code> MAT struct and without <code>ins_</code> prefixes. This is the standard way the MATLAB-companion outputs data.</p><p><strong>Arguments:</strong></p><ul><li><code>ins_file</code>: path/name of INS data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</li><li><code>field</code>:    (optional) struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>dt</code>:       (optional) measurement time step [s], only used if not in <code>ins_file</code></li><li><code>silent</code>:   (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>ins</code>: <code>INS</code> inertial navigation system struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L743-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_map" href="#MagNav.get_map"><code>MagNav.get_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_map(map_file::String   = namad,
        map_field::Symbol  = :map_data;
        map_info::String   = splitpath(map_file)[end],
        map_units::Symbol  = :rad,
        file_units::Symbol = :deg,
        flip_map::Bool     = false)</code></pre><p>Get map data from saved HDF5 or MAT file or folder containing CSV files. Maps are typically saved in <code>:deg</code> units, while <code>:rad</code> is used internally.</p><p><strong>Arguments:</strong></p><ul><li><code>map_file</code>:   path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required) or folder containing CSV files</li><li><code>map_field</code>:  (optional) struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>map_info</code>:   (optional) map information, only used if not in <code>map_file</code></li><li><code>map_units</code>:  (optional) map xx/yy units to use in <code>map_map</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>file_units</code>: (optional) map xx/yy units used in <code>map_file</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>flip_map</code>:   (optional) if true, vertically flip data from map file (possibly useful for CSV map)</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_map" href="#MagNav.get_map"><code>MagNav.get_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_map(map_name::Symbol, df_map::DataFrame,
        map_field::Symbol  = :map_data;
        map_info::String   = &quot;$map_name&quot;,
        map_units::Symbol  = :rad,
        file_units::Symbol = :deg,
        flip_map::Bool     = false)</code></pre><p>Get map data from saved HDF5 or MAT file or folder containing CSV files via DataFrame lookup. Maps are typically saved in <code>:deg</code> units, while <code>:rad</code> is used internally.</p><p><strong>Arguments:</strong></p><ul><li><code>map_name</code>: name of magnetic anomaly map</li><li><code>df_map</code>:   lookup table (DataFrame) of map data HDF5 and/or MAT files and/or folder containing CSV files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required) or folder containing CSV files</td></tr></table><ul><li><code>map_info</code>:   (optional) map information, only used if not in <code>map_file</code></li><li><code>map_field</code>:  (optional) struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>map_units</code>:  (optional) map xx/yy units to use in <code>map_map</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>file_units</code>: (optional) map xx/yy units used in files within <code>df_map</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>flip_map</code>:   (optional) if true, vertically flip data from map file (possibly useful for CSV map)</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L175-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_map_val" href="#MagNav.get_map_val"><code>MagNav.get_map_val</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_map_val(map_map::Map, path::Path, ind = trues(path.N);
            α=200, return_itp::Bool = false)</code></pre><p>Get scalar magnetic anomaly map values along a flight path. <code>map_map</code> is upward and/or downward continued to <code>alt</code> as necessary.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>Map</code> magnetic anomaly map struct</li><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:        (optional) selected data indices</li><li><code>α</code>:          (optional) regularization parameter for downward continuation</li><li><code>return_itp</code>: (optional) if true, also return <code>map_itp</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>map_val</code>: scalar magnetic anomaly map values</li><li><code>map_itp</code>: if <code>return_itp = true</code>, map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2473-L2490">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_map_val" href="#MagNav.get_map_val"><code>MagNav.get_map_val</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_map_val(map_map_vec::Vector, path::Path, ind = trues(path.N); α = 200)</code></pre><p>Get scalar magnetic anomaly map values from multiple maps along a flight path. Each map in <code>map_map_vec</code> is upward and/or downward continued to <code>alt</code> as necessary.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map_vec</code>: vector of <code>Map</code> magnetic anomaly map structs</li><li><code>path</code>:        <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:         (optional) selected data indices</li><li><code>α</code>:           (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_vals</code>: vector of scalar magnetic anomaly map values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2496-L2510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_map_val-Tuple{MagNav.Map, Any, Any, Any}" href="#MagNav.get_map_val-Tuple{MagNav.Map, Any, Any, Any}"><code>MagNav.get_map_val</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_map_val(map_map::Map, lat, lon, alt; α = 200, return_itp::Bool = false)</code></pre><p>Get scalar magnetic anomaly map values along a flight path. <code>map_map</code> is upward and/or downward continued to <code>alt</code> as necessary (except if drape map).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>Map</code> magnetic anomaly map struct</li><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>alt</code>:        altitude [m]</li><li><code>α</code>:          (optional) regularization parameter for downward continuation</li><li><code>return_itp</code>: (optional) if true, also return <code>itp_map</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>map_val</code>: scalar magnetic anomaly map values</li><li><code>itp_map</code>: if <code>return_itp = true</code>, map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2416-L2433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_nn_m" href="#MagNav.get_nn_m"><code>MagNav.get_nn_m</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nn_m(Nf::Int, Ny::Int = 1;
         hidden                = [8],
         activation::Function  = swish,
         final_bias::Bool      = true,
         skip_con::Bool        = false,
         model_type::Symbol    = :m1
         l_window::Int         = 5,
         tf_layer_type::Symbol = :postlayer,
         tf_norm_type::Symbol  = :batch,
         dropout_prob::Real    = 0.2,
         N_tf_head::Int        = 8,
         tf_gain::Real         = 1.0)</code></pre><p>Get neural network model. Valid for 0-3 hidden layers, except for <code>model_type = :m3w, :m3tf</code>, which are only valid for 1 or 2 hidden layers.</p><p><strong>Arguments:</strong></p><ul><li><code>Nf</code>:            length of input (feature) layer</li><li><code>Ny</code>:            (optional) length of output layer</li><li><code>hidden</code>:        (optional) hidden layers &amp; nodes (e.g., <code>[8,8]</code> for 2 hidden layers, 8 nodes each)</li><li><code>activation</code>:    (optional) activation function<ul><li><code>relu</code>  = rectified linear unit</li><li><code>σ</code>     = sigmoid (logistic function)</li><li><code>swish</code> = self-gated</li><li><code>tanh</code>  = hyperbolic tan</li><li>run <code>plot_activation()</code> for a visual</li></ul></li><li><code>final_bias</code>:    (optional) if true, include final layer bias</li><li><code>skip_con</code>:      (optional) if true, use skip connections, must have length(<code>hidden</code>) == 1</li><li><code>model_type</code>:    (optional) aeromagnetic compensation model type</li><li><code>l_window</code>:      (optional) temporal window length, only used for <code>model_type = :m3w, :m3tf</code></li><li><code>tf_layer_type</code>: (optional) transformer normalization layer before or after skip connection {<code>:prelayer</code>,<code>:postlayer</code>}, only used for <code>model_type = :m3tf</code></li><li><code>tf_norm_type</code>:  (optional) normalization for transformer encoder {<code>:batch</code>,<code>:layer</code>,<code>:none</code>}, only used for <code>model_type = :m3tf</code></li><li><code>dropout_prob</code>:  (optional) dropout rate, only used for <code>model_type = :m3w, :m3tf</code></li><li><code>N_tf_head</code>:     (optional) number of attention heads, only used for <code>model_type = :m3tf</code></li><li><code>tf_gain</code>:       (optional) weight initialization parameter, only used for <code>model_type = :m3tf</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>m</code>: neural network model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1071-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_optimal_rotation_matrix-Tuple{Any, Any}" href="#MagNav.get_optimal_rotation_matrix-Tuple{Any, Any}"><code>MagNav.get_optimal_rotation_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_optimal_rotation_matrix(v1s, v2s)</code></pre><p>Get the <code>3</code> x <code>3</code> rotation matrix rotating the directions of v1s into v2s. Uses the Kabsch algorithm.</p><p>Reference: https://en.wikipedia.org/wiki/Kabsch_algorithm</p><p><strong>Arguments:</strong></p><ul><li><code>v1s</code>: <code>N</code> x <code>3</code> matrix for first  set of 3D points</li><li><code>v2s</code>: <code>N</code> x <code>3</code> matrix for second set of 3D points</li></ul><p><strong>Returns:</strong></p><ul><li><code>R</code>: 3D matrix rotatating v1s into v2s&#39; directions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2223-L2237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_pinson-Tuple{Int64, Vararg{Any, 8}}" href="#MagNav.get_pinson-Tuple{Int64, Vararg{Any, 8}}"><code>MagNav.get_pinson</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_pinson(nx::Int, lat, vn, ve, vd, fn, fe, fd, Cnb;
           baro_tau         = 3600.0,
           acc_tau          = 3600.0,
           gyro_tau         = 3600.0,
           fogm_tau         = 600.0,
           vec_states::Bool = false,
           fogm_state::Bool = true,
           k1=3e-2, k2=3e-4, k3=1e-6)</code></pre><p>Get the <code>nx</code> x <code>nx</code> Pinson dynamics matrix. States (errors) are:</p><table><tr><th style="text-align: left"><strong>Num</strong></th><th style="text-align: left"><strong>State</strong></th><th style="text-align: left"><strong>Units</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left">1</td><td style="text-align: left">lat</td><td style="text-align: left">rad</td><td style="text-align: left">latitude</td></tr><tr><td style="text-align: left">2</td><td style="text-align: left">lon</td><td style="text-align: left">rad</td><td style="text-align: left">longitude</td></tr><tr><td style="text-align: left">3</td><td style="text-align: left">alt</td><td style="text-align: left">m</td><td style="text-align: left">altitude</td></tr><tr><td style="text-align: left">4</td><td style="text-align: left">vn</td><td style="text-align: left">m/s</td><td style="text-align: left">north velocity</td></tr><tr><td style="text-align: left">5</td><td style="text-align: left">ve</td><td style="text-align: left">m/s</td><td style="text-align: left">east  velocity</td></tr><tr><td style="text-align: left">6</td><td style="text-align: left">vd</td><td style="text-align: left">m/s</td><td style="text-align: left">down  velocity</td></tr><tr><td style="text-align: left">7</td><td style="text-align: left">tn</td><td style="text-align: left">rad</td><td style="text-align: left">north tilt (attitude)</td></tr><tr><td style="text-align: left">8</td><td style="text-align: left">te</td><td style="text-align: left">rad</td><td style="text-align: left">east  tilt (attitude)</td></tr><tr><td style="text-align: left">9</td><td style="text-align: left">td</td><td style="text-align: left">rad</td><td style="text-align: left">down  tilt (attitude)</td></tr><tr><td style="text-align: left">10</td><td style="text-align: left">ha</td><td style="text-align: left">m</td><td style="text-align: left">barometer aiding altitude</td></tr><tr><td style="text-align: left">11</td><td style="text-align: left">a_hat</td><td style="text-align: left">m/s^2</td><td style="text-align: left">barometer aiding vertical acceleration</td></tr><tr><td style="text-align: left">12</td><td style="text-align: left">ax</td><td style="text-align: left">m/s^2</td><td style="text-align: left">x accelerometer</td></tr><tr><td style="text-align: left">13</td><td style="text-align: left">ay</td><td style="text-align: left">m/s^2</td><td style="text-align: left">y accelerometer</td></tr><tr><td style="text-align: left">14</td><td style="text-align: left">az</td><td style="text-align: left">m/s^2</td><td style="text-align: left">z accelerometer</td></tr><tr><td style="text-align: left">15</td><td style="text-align: left">gx</td><td style="text-align: left">rad/s</td><td style="text-align: left">x gyroscope</td></tr><tr><td style="text-align: left">16</td><td style="text-align: left">gy</td><td style="text-align: left">rad/s</td><td style="text-align: left">y gyroscope</td></tr><tr><td style="text-align: left">17</td><td style="text-align: left">gz</td><td style="text-align: left">rad/s</td><td style="text-align: left">z gyroscope</td></tr><tr><td style="text-align: left">end</td><td style="text-align: left">S</td><td style="text-align: left">nT</td><td style="text-align: left">FOGM catch-all</td></tr></table><p><strong>Arguments:</strong></p><ul><li><code>nx</code>:         total state dimension</li><li><code>lat</code>:        latitude       [rad]</li><li><code>vn</code>:         north velocity [m/s]</li><li><code>ve</code>:         east  velocity [m/s]</li><li><code>vd</code>:         down  velocity [m/s]</li><li><code>fn</code>:         north specific force [m/s^2]</li><li><code>fe</code>:         east  specific force [m/s^2]</li><li><code>fd</code>:         down  specific force [m/s^2]</li><li><code>Cnb</code>:        direction cosine matrix (body to navigation) [-]</li><li><code>baro_tau</code>:   (optional) barometer      time constant [s]</li><li><code>acc_tau</code>:    (optional) accelerometer  time constant [s]</li><li><code>gyro_tau</code>:   (optional) gyroscope      time constant [s]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>vec_states</code>: (optional) if true, include vector magnetometer states</li><li><code>fogm_state</code>: (optional) if true, include FOGM catch-all bias state</li><li><code>k1</code>:         (optional) barometer aiding constant [1/s]</li><li><code>k2</code>:         (optional) barometer aiding constant [1/s^2]</li><li><code>k3</code>:         (optional) barometer aiding constant [1/s^3]</li></ul><p><strong>Returns:</strong></p><ul><li><code>F</code>: <code>nx</code> x <code>nx</code> Pinson matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/model_functions.jl#L296-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_step-Tuple{AbstractVector}" href="#MagNav.get_step-Tuple{AbstractVector}"><code>MagNav.get_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_step(x::AbstractVector)</code></pre><p>Get the step size (spacing) of elements in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2516-L2520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_traj" href="#MagNav.get_traj"><code>MagNav.get_traj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_traj(xyz::XYZ, ind = trues(xyz.traj.N))</code></pre><p>Get trajectory data at specific indices.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>: <code>XYZ</code> flight data struct</li><li><code>ind</code>: (optional) selected data indices</li></ul><p><strong>Returns:</strong></p><ul><li><code>traj</code>: <code>Traj</code> trajectory struct at <code>ind</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L1072-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_traj" href="#MagNav.get_traj"><code>MagNav.get_traj</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_traj(traj_file::String, field::Symbol = :traj;
         dt            = 0.1,
         tt_sort::Bool = true,
         silent::Bool  = false)</code></pre><p>Get trajectory data from saved CSV, HDF5, or MAT file. The only required fields are <code>lat</code>, <code>lon</code>, and <code>alt</code> (position).</p><p>If a CSV or HDF5 file is provided, the possible columns/fields in the file are:</p><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>dt</code></td><td style="text-align: left">scalar</td><td style="text-align: left">measurement time step [s]</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left">vector</td><td style="text-align: left">time [s]</td></tr><tr><td style="text-align: left"><code>lat</code></td><td style="text-align: left">vector</td><td style="text-align: left">latitude  [deg]</td></tr><tr><td style="text-align: left"><code>lon</code></td><td style="text-align: left">vector</td><td style="text-align: left">longitude [deg]</td></tr><tr><td style="text-align: left"><code>alt</code></td><td style="text-align: left">vector</td><td style="text-align: left">altitude  [m]</td></tr><tr><td style="text-align: left"><code>vn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north velocity [m/s]</td></tr><tr><td style="text-align: left"><code>ve</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>vd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  velocity [m/s]</td></tr><tr><td style="text-align: left"><code>fn</code></td><td style="text-align: left">vector</td><td style="text-align: left">north specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fe</code></td><td style="text-align: left">vector</td><td style="text-align: left">east  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>fd</code></td><td style="text-align: left">vector</td><td style="text-align: left">down  specific force [m/s]</td></tr><tr><td style="text-align: left"><code>Cnb</code></td><td style="text-align: left">3x3xN</td><td style="text-align: left">direction cosine matrix (body to navigation) [-], not valid for CSV file (use <code>roll</code>, <code>pitch</code>, &amp; <code>yaw</code> instead)</td></tr><tr><td style="text-align: left"><code>roll</code></td><td style="text-align: left">vector</td><td style="text-align: left">roll [deg]</td></tr><tr><td style="text-align: left"><code>pitch</code></td><td style="text-align: left">vector</td><td style="text-align: left">pitch [deg]</td></tr><tr><td style="text-align: left"><code>yaw</code></td><td style="text-align: left">vector</td><td style="text-align: left">yaw [deg]</td></tr></table><p>If a MAT file is provided, the above fields may also be provided, but they should be within the specified <code>field</code> MAT struct. This is the standard way the MATLAB-companion outputs data.</p><p><strong>Arguments:</strong></p><ul><li><code>traj_file</code>: path/name of trajectory data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</li><li><code>field</code>:     (optional) struct field within MAT file to use, not relevant for CSV or HDF5 file</li><li><code>dt</code>:        (optional) measurement time step [s], only used if not in <code>traj_file</code></li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>traj</code>: <code>Traj</code> trajectory struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_XYZ.jl#L548-L589">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_x" href="#MagNav.get_x"><code>MagNav.get_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_x(xyz::XYZ, ind = trues(xyz.traj.N),
      features_setup::Vector{Symbol}   = [:mag_1_uc,:TL_A_flux_a];
      features_no_norm::Vector{Symbol} = Symbol[],
      terms             = [:permanent,:induced,:eddy],
      sub_diurnal::Bool = false,
      sub_igrf::Bool    = false,
      bpf_mag::Bool     = false)</code></pre><p>Get <code>x</code> data matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:              <code>XYZ</code> flight data struct</li><li><code>ind</code>:              selected data indices</li><li><code>features_setup</code>:   vector of features to include</li><li><code>features_no_norm</code>: (optional) vector of features to not normalize</li><li><code>terms</code>:            (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>sub_diurnal</code>:      (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:         (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>bpf_mag</code>:          (optional) if true, bpf scalar magnetometer measurements</li></ul><p><strong>Returns:</strong></p><ul><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>no_norm</code>:  length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>l_segs</code>:   length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L236-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_x" href="#MagNav.get_x"><code>MagNav.get_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_x(xyz_vec::Vector{XYZ}, ind_vec,
      features_setup::Vector{Symbol}   = [:mag_1_uc,:TL_A_flux_a];
      features_no_norm::Vector{Symbol} = Symbol[],
      terms             = [:permanent,:induced,:eddy],
      sub_diurnal::Bool = false,
      sub_igrf::Bool    = false,
      bpf_mag::Bool     = false)</code></pre><p>Get <code>x</code> data matrix from multiple <code>XYZ</code> flight data structs.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_vec</code>:          vector of <code>XYZ</code> flight data structs</li><li><code>ind_vec</code>:          vector of selected data indices</li><li><code>features_setup</code>:   vector of features to include</li><li><code>features_no_norm</code>: (optional) vector of features to not normalize</li><li><code>terms</code>:            (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>sub_diurnal</code>:      (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:         (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>bpf_mag</code>:          (optional) if true, bpf scalar magnetometer measurements</li></ul><p><strong>Returns:</strong></p><ul><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>no_norm</code>:  length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>l_segs</code>:   length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L428-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_x" href="#MagNav.get_x"><code>MagNav.get_x</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_x(lines, df_line::DataFrame, df_flight::DataFrame,
      features_setup::Vector{Symbol}   = [:mag_1_uc,:TL_A_flux_a];
      features_no_norm::Vector{Symbol} = Symbol[],
      terms              = [:permanent,:induced,:eddy],
      sub_diurnal::Bool  = false,
      sub_igrf::Bool     = false,
      bpf_mag::Bool      = false,
      reorient_vec::Bool = false,
      l_window::Int      = -1,
      silent::Bool       = true)</code></pre><p>Get <code>x</code> data matrix from multiple flight lines, possibly multiple flights.</p><p><strong>Arguments:</strong></p><ul><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>features_setup</code>:   vector of features to include</li><li><code>features_no_norm</code>: (optional) vector of features to not normalize</li><li><code>terms</code>:            (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>sub_diurnal</code>:      (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:         (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>bpf_mag</code>:          (optional) if true, bpf scalar magnetometer measurements</li><li><code>reorient_vec</code>:     (optional) if true, align vector magnetometer measurements with body frame</li><li><code>l_window</code>:         (optional) trim data by <code>N % l_window</code>, <code>-1</code> to ignore</li><li><code>silent</code>:           (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>no_norm</code>:  length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>features</code>: length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>l_segs</code>:   length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L484-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_y" href="#MagNav.get_y"><code>MagNav.get_y</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_y(xyz::XYZ, ind = trues(xyz.traj.N),
      map_val           = -1);
      y_type::Symbol    = :d,
      use_mag::Symbol   = :mag_1_uc,
      use_mag_c::Symbol = :mag_1_c,
      sub_diurnal::Bool = false,
      sub_igrf::Bool    = false)</code></pre><p>Get <code>y</code> target vector.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:     <code>XYZ</code> flight data struct</li><li><code>ind</code>:     selected data indices</li><li><code>map_val</code>: (optional) scalar magnetic anomaly map values, only used for <code>y_type = :b</code></li><li><code>y_type</code>:  (optional) <code>y</code> target type<ul><li><code>:a</code> = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements</li><li><code>:b</code> = anomaly field  #2, interpolated <code>magnetic anomaly map</code> values</li><li><code>:c</code> = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated <code>magnetic anomaly map</code> values</li><li><code>:d</code> = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements</li><li><code>:e</code> = BPF&#39;d total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements</li></ul></li><li><code>use_mag</code>:     (optional) uncompensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_uc</code>, etc.}, only used for <code>y_type = :c, :d, :e</code></li><li><code>use_mag_c</code>:   (optional) compensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_c</code>, etc.}, only used for <code>y_type = :a, :d</code></li><li><code>sub_diurnal</code>: (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:    (optional) if true, subtract IGRF from scalar magnetometer measurements</li></ul><p><strong>Returns:</strong></p><ul><li><code>y</code>: length-<code>N</code> target vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L599-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_y-Tuple{Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#MagNav.get_y-Tuple{Any, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>MagNav.get_y</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_y(lines, df_line::DataFrame, df_flight::DataFrame,
      df_map::DataFrame;
      y_type::Symbol    = :d,
      use_mag::Symbol   = :mag_1_uc,
      use_mag_c::Symbol = :mag_1_c,
      sub_diurnal::Bool = false,
      sub_igrf::Bool    = false,
      l_window::Int     = -1,
      silent::Bool      = true)</code></pre><p>Get <code>y</code> target vector from multiple flight lines, possibly multiple flights.</p><p><strong>Arguments:</strong></p><ul><li><code>lines</code>:   selected line number(s)</li><li><code>df_line</code>: lookup table (DataFrame) of <code>lines</code></li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>line</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">line number, i.e., segments within <code>flight</code></td></tr><tr><td style="text-align: left"><code>t_start</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">start time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>t_end</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">end   time of <code>line</code> to use [s]</td></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">(optional) name of magnetic anomaly map relevant to <code>line</code>, only used for <code>y_type = :b, :c</code></td></tr></table><ul><li><code>df_flight</code>: lookup table (DataFrame) of flight data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>xyz_type</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">subtype of <code>XYZ</code> to use for flight data {<code>:XYZ0</code>,<code>:XYZ1</code>,<code>:XYZ20</code>,<code>:XYZ21</code>}</td></tr><tr><td style="text-align: left"><code>xyz_set</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">flight dataset number (used to prevent improper mixing of datasets, such as different magnetometer locations)</td></tr><tr><td style="text-align: left"><code>xyz_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of flight data CSV, HDF5, or MAT file (<code>.csv</code>, <code>.h5</code>, or <code>.mat</code> extension required)</td></tr></table><ul><li><code>df_map</code>: lookup table (DataFrame) of map data files</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>map_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">name of magnetic anomaly map</td></tr><tr><td style="text-align: left"><code>map_file</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">path/name of map data HDF5 or MAT file (<code>.h5</code> or <code>.mat</code> extension required)</td></tr></table><ul><li><code>y_type</code>: (optional) <code>y</code> target type<ul><li><code>:a</code> = anomaly field  #1, compensated tail stinger total field scalar magnetometer measurements</li><li><code>:b</code> = anomaly field  #2, interpolated <code>magnetic anomaly map</code> values</li><li><code>:c</code> = aircraft field #1, difference between uncompensated cabin total field scalar magnetometer measurements and interpolated <code>magnetic anomaly map</code> values</li><li><code>:d</code> = aircraft field #2, difference between uncompensated cabin and compensated tail stinger total field scalar magnetometer measurements</li><li><code>:e</code> = BPF&#39;d total field, bandpass filtered uncompensated cabin total field scalar magnetometer measurements</li></ul></li><li><code>use_mag</code>:     (optional) uncompensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_uc</code>, etc.}, only used for <code>y_type = :c, :d, :e</code></li><li><code>use_mag_c</code>:   (optional) compensated scalar magnetometer to use for <code>y</code> target vector {<code>:mag_1_c</code>, etc.}, only used for <code>y_type = :a, :d</code></li><li><code>sub_diurnal</code>: (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:    (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>l_window</code>:    (optional) trim data by <code>N % l_window</code>, <code>-1</code> to ignore</li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y</code>: length-<code>N</code> target vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L671-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.get_years-Tuple{Any, Any}" href="#MagNav.get_years-Tuple{Any, Any}"><code>MagNav.get_years</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_years(year, doy=0)</code></pre><p>Get decimal (fractional) year from <code>year</code> and <code>doy</code> (day of year).</p><p><strong>Arguments:</strong></p><ul><li><code>year</code>: year</li><li><code>doy</code>:  day of year</li></ul><p><strong>Returns:</strong></p><ul><li><code>years</code>: decimal (fractional) year</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2280-L2291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.gif_animation_m3" href="#MagNav.gif_animation_m3"><code>MagNav.gif_animation_m3</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gif_animation_m3(TL_perm::AbstractMatrix, TL_induced::AbstractMatrix, TL_eddy::AbstractMatrix,
                 TL_aircraft::AbstractMatrix, B_unit::AbstractMatrix, y_nn::AbstractMatrix,
                 y::Vector, y_hat::Vector, xyz::XYZ,
                 filt_lat::Vector = [],
                 filt_lon::Vector = [];
                 ind              = trues(xyz.traj.N),
                 tt_lim::Tuple    = (0, (xyz.traj(ind).N-1)*xyz.traj.dt/60),
                 skip_every::Int  = 5,
                 save_plot::Bool  = false,
                 mag_gif::String  = &quot;comp_xai.gif&quot;)</code></pre><p>Create a GIF animation of the model 3 components and the true and predicted scalar magnetic field. First run <code>comp_m3_test()</code> to generate the individual model components 3.</p><p><strong>Arguments</strong></p><ul><li><code>TL_perm</code>:     <code>3</code> x <code>N</code> matrix of TL permanent vector field</li><li><code>TL_induced</code>:  <code>3</code> x <code>N</code> matrix of TL induced vector field</li><li><code>TL_eddy</code>:     <code>3</code> x <code>N</code> matrix of TL eddy current vector field</li><li><code>TL_aircraft</code>: <code>3</code> x <code>N</code> matrix of TL aircraft vector field</li><li><code>B_unit</code>:      <code>3</code> x <code>N</code> matrix of normalized vector magnetometer measurements</li><li><code>y_nn</code>:        <code>3</code> x <code>N</code> matrix of vector neural network correction (for scalar models, in direction of <code>Bt</code>)</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>y_hat</code>:       length-<code>N</code> prediction vector</li><li><code>xyz</code>:         <code>XYZ</code> flight data struct</li><li><code>filt_lat</code>:    (optional) length-<code>N</code> filter output latitude  [rad]</li><li><code>filt_lon</code>:    (optional) length-<code>N</code> filter output longitude [rad]</li><li><code>ind</code>:         (optional) selected data indices</li><li><code>tt_lim</code>:      (optional) length-<code>2</code> start &amp; end time limits (inclusive) [min]</li><li><code>skip_every</code>:  (optional) number of time steps to skip between frames</li><li><code>save_plot</code>:   (optional) if true, save <code>g1</code> as <code>mag_gif</code></li><li><code>mag_gif</code>:     (optional) path/name of magnetic field GIF file to save (<code>.gif</code> extension optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>g1</code>: magnetic field GIF animation</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">gif_animation_m3(TL_perm, TL_induced, TL_eddy, TL_aircraft, B_unit,
                 y_nn, y, y_hat, xyz, filt_lat, filt_lon; ind=ind, tt_lim=(0.0,10.0),
                 skip_every=5, save_plot=false, mag_gif=&quot;comp_xai.gif&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2408-L2451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.gif_ellipse" href="#MagNav.gif_ellipse"><code>MagNav.gif_ellipse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gif_ellipse(P, lat1 = deg2rad(45);
            dt                   = 0.1,
            di::Int              = 10,
            speedup::Int         = 60,
            conf_units::Symbol   = :m,
            μ                    = zeros(eltype(P),2),
            conf                 = 0.95,
            clip                 = Inf,
            n::Int               = 61,
            lim                  = 500,
            margin::Int          = 2,
            axis::Bool           = true,
            plot_eigax::Bool     = false,
            bg_color::Symbol     = :white,
            ce_color::Symbol     = :black,
            b_e::AbstractBackend = gr(),
            save_plot::Bool      = false,
            ellipse_gif::String  = &quot;conf_ellipse.gif&quot;)</code></pre><p>Create a (position) confidence ellipse GIF animation for a <code>2</code> x <code>2</code> (x <code>N</code>) covariance matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>P</code>:           <code>2</code> x <code>2</code> (x <code>N</code>) covariance matrix</li><li><code>lat1</code>:        (optional) nominal latitude [rad], only used if <code>conf_units = :m</code> or <code>:ft</code></li><li><code>dt</code>:          (optional) measurement time step [s]</li><li><code>di</code>:          (optional) GIF measurement interval (e.g., <code>di = 10</code> uses every 10th measurement)</li><li><code>speedup</code>:     (optional) GIF speedup (e.g., <code>speedup = 60</code> is 60x speed)</li><li><code>conf_units</code>:  (optional) confidence ellipse units {<code>:m</code>,<code>:ft</code>,<code>:deg</code>,<code>:rad</code>}</li><li><code>μ</code>:           (optional) confidence ellipse center [<code>conf_units</code>]</li><li><code>conf</code>:        (optional) percentile {0:1}</li><li><code>clip</code>:        (optional) clipping radius [<code>conf_units</code>]</li><li><code>n</code>:           (optional) number of confidence ellipse points</li><li><code>lim</code>:         (optional) plot <code>x</code> &amp; <code>y</code> limits (<code>-lim</code>,<code>lim</code>) [<code>conf_units</code>]</li><li><code>margin</code>:      (optional) margin around plot [mm]</li><li><code>axis</code>:        (optional) if true, show axes</li><li><code>plot_eigax</code>:  (optional) if true, show major &amp; minor axes</li><li><code>bg_color</code>:    (optional) background color</li><li><code>ce_color</code>:    (optional) confidence ellipse color</li><li><code>b_e</code>:         (optional) plotting backend</li><li><code>save_plot</code>:   (optional) if true, save <code>g1</code> as <code>ellipse_gif</code></li><li><code>ellipse_gif</code>: (optional) path/name of confidence ellipse GIF file to save (<code>.gif</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>g1</code>: confidence ellipse GIF animation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L1243-L1289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.gif_ellipse" href="#MagNav.gif_ellipse"><code>MagNav.gif_ellipse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gif_ellipse(filt_res::FILTres,
            filt_out::FILTout,
            map_map::Map         = mapS_null;
            dt                   = 0.1,
            di::Int              = 10,
            speedup::Int         = 60,
            conf_units::Symbol   = :m,
            μ                    = zeros(eltype(filt_res.P),2),
            conf                 = 0.95,
            clip                 = Inf,
            n::Int               = 61,
            lim                  = 500,
            dpi::Int             = 200,
            margin::Int          = 2,
            axis::Bool           = true,
            plot_eigax::Bool     = false,
            bg_color::Symbol     = :white,
            ce_color::Symbol     = :black,
            map_color::Symbol    = :usgs,
            clims::Tuple         = (),
            b_e::AbstractBackend = gr(),
            save_plot::Bool      = false,
            ellipse_gif::String  = &quot;conf_ellipse.gif&quot;)</code></pre><p>Create a (position) confidence ellipse GIF animation for a <code>2</code> x <code>2</code> (x <code>N</code>) covariance matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>filt_res</code>:    <code>FILTres</code> filter results struct</li><li><code>filt_out</code>:    <code>FILTout</code> filter extracted output struct</li><li><code>map_map</code>:     (optional) <code>Map</code> magnetic anomaly map struct</li><li><code>dt</code>:          (optional) measurement time step [s]</li><li><code>di</code>:          (optional) GIF measurement interval (e.g., <code>di = 10</code> uses every 10th measurement)</li><li><code>speedup</code>:     (optional) GIF speedup (e.g., <code>speedup = 60</code> is 60x speed)</li><li><code>conf_units</code>:  (optional) confidence ellipse units {<code>:m</code>,<code>:ft</code>,<code>:deg</code>,<code>:rad</code>}</li><li><code>μ</code>:           (optional) confidence ellipse center [<code>conf_units</code>]</li><li><code>conf</code>:        (optional) percentile {0:1}</li><li><code>clip</code>:        (optional) clipping radius [<code>conf_units</code>]</li><li><code>n</code>:           (optional) number of confidence ellipse points</li><li><code>lim</code>:         (optional) plot <code>x</code> &amp; <code>y</code> limits (<code>-lim</code>,<code>lim</code>) [<code>conf_units</code>]</li><li><code>dpi</code>:         (optional) dots per inch (image resolution)</li><li><code>margin</code>:      (optional) margin around plot [mm]</li><li><code>axis</code>:        (optional) if true, show axes</li><li><code>plot_eigax</code>:  (optional) if true, show major &amp; minor axes</li><li><code>bg_color</code>:    (optional) background color</li><li><code>ce_color</code>:    (optional) confidence ellipse color</li><li><code>map_color</code>:   (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>clims</code>:       (optional) length-<code>2</code> map colorbar limits <code>(cmin,cmax)</code></li><li><code>b_e</code>:         (optional) plotting backend</li><li><code>save_plot</code>:   (optional) if true, save <code>g1</code> as <code>ellipse_gif</code></li><li><code>ellipse_gif</code>: (optional) path/name of confidence ellipse GIF file to save (<code>.gif</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>g1</code>: confidence ellipse GIF animation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L1336-L1391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.krr_fit" href="#MagNav.krr_fit"><code>MagNav.krr_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krr_fit(x, y, no_norm = falses(size(x,2));
        k::Kernel           = PolynomialKernel(;degree=1),
        λ::Real             = 0.5,
        norm_type_x::Symbol = :standardize,
        norm_type_y::Symbol = :standardize,
        data_norms::Tuple   = (zeros(1,1),zeros(1,1),[0.0],[0.0]),
        l_segs::Vector      = [length(y)],
        silent::Bool        = false)</code></pre><p>Fit a kernel ridge regression (KRR) model to data.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:           <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>no_norm</code>:     (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>k</code>:           (optional) kernel</li><li><code>λ</code>:           (optional) ridge parameter</li><li><code>norm_type_x</code>: (optional) normalization for <code>x</code> data matrix</li><li><code>norm_type_y</code>: (optional) normalization for <code>y</code> target vector</li><li><code>data_norms</code>:  (optional) length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>l_segs</code>:      (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>model</code>:      length-<code>3</code> tuple of KRR-based model, (<code>k</code>, length-<code>N</code> coefficients, <code>N</code> x <code>Nf</code> data matrix, normalized)</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>y_hat</code>:      length-<code>N</code> prediction vector</li><li><code>err</code>:        length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1861-L1890">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.krr_test-Tuple{Any, Any, Tuple, Tuple}" href="#MagNav.krr_test-Tuple{Any, Any, Tuple, Tuple}"><code>MagNav.krr_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">krr_test(x, y, data_norms::Tuple, model::Tuple;
         l_segs::Vector = [length(y)],
         silent::Bool   = false)</code></pre><p>Evaluate performance of a kernel ridge regression (KRR) model.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:          <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:          length-<code>N</code> target vector</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>model</code>:      length-<code>3</code> tuple of KRR-based model, (<code>k</code>, length-<code>N_train</code> coefficients, <code>N_train</code> x <code>Nf</code> training data matrix, normalized)</li><li><code>l_segs</code>:     (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_hat</code>: length-<code>N</code> prediction vector</li><li><code>err</code>:   length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1930-L1948">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.linear_fit" href="#MagNav.linear_fit"><code>MagNav.linear_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_fit(x, y, no_norm = falses(size(x,2));
           trim::Int           = 0,
           λ::Real             = 0,
           norm_type_x::Symbol = :none,
           norm_type_y::Symbol = :none,
           data_norms::Tuple   = (zeros(1,1),zeros(1,1),[0.0],[0.0]),
           l_segs::Vector      = [length(y)],
           silent::Bool        = false)</code></pre><p>Fit a linear regression model to data.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:           <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:           length-<code>N</code> target vector</li><li><code>no_norm</code>:     (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>trim</code>:        (optional) number of elements to trim (e.g., due to bpf)</li><li><code>λ</code>:           (optional) ridge parameter</li><li><code>norm_type_x</code>: (optional) normalization for <code>x</code> data matrix</li><li><code>norm_type_y</code>: (optional) normalization for <code>y</code> target vector</li><li><code>data_norms</code>:  (optional) length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>l_segs</code>:      (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:      (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>model</code>:      length-<code>2</code> tuple of linear regression model, (length-<code>Nf</code> coefficients, bias=<code>0</code>)</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>y_hat</code>:      length-<code>N</code> prediction vector</li><li><code>err</code>:        length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L1926-L1955">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.linear_test-Tuple{Any, Any, Any, Any, Tuple}" href="#MagNav.linear_test-Tuple{Any, Any, Any, Any, Tuple}"><code>MagNav.linear_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_test(x_norm, y, y_bias, y_scale, model::Tuple;
            l_segs::Vector = [length(y)],
            silent::Bool   = false)</code></pre><p>Evaluate performance of a linear model.</p><p><strong>Arguments:</strong></p><ul><li><code>x_norm</code>:  <code>N</code> x <code>Nf</code> normalized data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:       length-<code>N</code> target vector</li><li><code>y_bias</code>:  <code>y</code> target vector bias bias (mean, min, or zero)</li><li><code>y_scale</code>: <code>y</code> target vector bias scaling factor (std dev, max-min, or one)</li><li><code>model</code>:   length-<code>2</code> tuple of model, (length-<code>Nf</code> coefficients, bias)</li><li><code>l_segs</code>:  (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:  (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_hat</code>: length-<code>N</code> prediction vector</li><li><code>err</code>:   length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L2052-L2071">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.linear_test-Tuple{Any, Any, Tuple, Tuple}" href="#MagNav.linear_test-Tuple{Any, Any, Tuple, Tuple}"><code>MagNav.linear_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_test(x, y, data_norms::Tuple, model::Tuple;
            l_segs::Vector = [length(y)],
            silent::Bool   = false)</code></pre><p>Evaluate performance of a linear model.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:          <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:          length-<code>N</code> target vector</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>model</code>:      length-<code>2</code> tuple of model, (length-<code>Nf</code> coefficients, bias)</li><li><code>l_segs</code>:     (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_hat</code>: length-<code>N</code> prediction vector</li><li><code>err</code>:   length-<code>N</code> mean-corrected (per line) error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L2084-L2102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.linreg-Tuple{Any, Any}" href="#MagNav.linreg-Tuple{Any, Any}"><code>MagNav.linreg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linreg(y, x; λ=0)</code></pre><p>Linear regression with data matrix.</p><p><strong>Arguments:</strong></p><ul><li><code>y</code>: length-<code>N</code> observed data vector</li><li><code>x</code>: <code>N</code> x <code>Nf</code> input data matrix (<code>Nf</code> is number of features)</li><li><code>λ</code>: (optional) ridge parameter</li></ul><p><strong>Returns:</strong></p><ul><li><code>coef</code>: linear regression coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L69-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.linreg-Tuple{Any}" href="#MagNav.linreg-Tuple{Any}"><code>MagNav.linreg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linreg(y; λ=0)</code></pre><p>Linear regression to determine best fit line for x = eachindex(y).</p><p><strong>Arguments:</strong></p><ul><li><code>y</code>: length-<code>N</code> observed data vector</li><li><code>λ</code>: (optional) ridge parameter</li></ul><p><strong>Returns:</strong></p><ul><li><code>coef</code>: length-<code>2</code> vector of linear regression coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map2kmz" href="#MagNav.map2kmz"><code>MagNav.map2kmz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2kmz(map_map::Matrix, map_xx::Vector, map_yy::Vector,
        map_kmz::String   = &quot;map.kmz&quot;;
        map_units::Symbol = :rad,
        plot_alt::Real    = 0,
        opacity::Real     = 0.75,
        clims::Tuple      = ())</code></pre><p>Create KMZ file of map for use with Google Earth. Generates an &quot;icon&quot; overlay, thus not suitable for large maps (e.g., &gt; 5 deg x 5 deg).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:    <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg]</li><li><code>map_yy</code>:    <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg]</li><li><code>map_kmz</code>:   (optional) path/name of map KMZ file to save (<code>.kmz</code> extension optional)</li><li><code>map_units</code>: (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_alt</code>:  (optional) map altitude in Google Earth [m]</li><li><code>opacity</code>:   (optional) map opacity {0:1}</li><li><code>clims</code>:     (optional) length-<code>2</code> map colorbar limits <code>(cmin,cmax)</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_kmz</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/google_earth.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map2kmz" href="#MagNav.map2kmz"><code>MagNav.map2kmz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map2kmz(mapS::Union{MapS,MapSd,MapS3D},
        map_kmz::String = &quot;map.kmz&quot;;
        use_mask::Bool  = true,
        plot_alt::Real  = 0,
        opacity::Real   = 0.75,
        clims::Tuple    = ())</code></pre><p>Create KMZ file of map for use with Google Earth. Generates an &quot;icon&quot; overlay, thus not suitable for large maps (e.g., &gt; 5 deg x 5 deg).</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:     <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>map_kmz</code>:  (optional) path/name of map KMZ file to save (<code>.kmz</code> extension optional)</li><li><code>use_mask</code>: (optional) if true, apply <code>mapS</code> mask to map</li><li><code>plot_alt</code>: (optional) map altitude in Google Earth [m]</li><li><code>opacity</code>:  (optional) map opacity {0:1}</li><li><code>clims</code>:    (optional) length-<code>2</code> map colorbar limits <code>(cmin,cmax)</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_kmz</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/google_earth.jl#L113-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_border-Tuple{Matrix, Vector, Vector}" href="#MagNav.map_border-Tuple{Matrix, Vector, Vector}"><code>MagNav.map_border</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_border(map_map::Matrix, map_xx::Vector, map_yy::Vector;
           inner::Bool       = true,
           sort_border::Bool = false,
           return_ind::Bool  = false)</code></pre><p>Get map border from an unfilled map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:     <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:      <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:      <code>ny</code> map y-direction (latitude)  coordinates</li><li><code>inner</code>:       (optional) if true, get inner border, otherwise outer border</li><li><code>sort_border</code>: (optional) if true, sort border data points sequentially</li><li><code>return_ind</code>:  (optional) if true, return <code>ind</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>yy</code>:  border y-direction (latitude)  coordinates</li><li><code>xx</code>:  border x-direction (longitude) coordinates</li><li><code>ind</code>: if <code>return_ind = true</code>, <code>BitMatrix</code> of border indices within <code>map_map</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2602-L2622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_border-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_border-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_border</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_border(mapS::Union{MapS,MapSd,MapS3D};
           inner::Bool       = true,
           sort_border::Bool = false,
           return_ind::Bool  = false)</code></pre><p>Get map border from an unfilled map.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:        <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>inner</code>:       (optional) if true, get inner border, otherwise outer border</li><li><code>sort_border</code>: (optional) if true, sort border data points sequentially</li><li><code>return_ind</code>:  (optional) if true, return <code>ind</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>yy</code>:  border y-direction (latitude)  coordinates</li><li><code>xx</code>:  border x-direction (longitude) coordinates</li><li><code>ind</code>: if <code>return_ind = true</code>, <code>BitMatrix</code> of border indices within <code>map_map</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2688-L2706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_check" href="#MagNav.map_check"><code>MagNav.map_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_check(map_map::Map, lat, lon, alt = fill(median(map_map.alt),size(lat)))</code></pre><p>Check if latitude and longitude points are on given map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct</li><li><code>lat</code>:     latitude  [rad]</li><li><code>lon</code>:     longitude [rad]</li><li><code>alt</code>:     (optional) altitude [m], only used for <code>MapS3D</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>bool</code>: if true, all <code>lat</code> &amp; <code>lon</code> (&amp; <code>alt</code>) points are on <code>map_map</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2343-L2356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_check" href="#MagNav.map_check"><code>MagNav.map_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_check(map_map::Map, path::Path, ind = trues(path.N))</code></pre><p>Check if latitude and longitude points are on given map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct</li><li><code>path</code>:    <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:     (optional) selected data indices</li></ul><p><strong>Returns:</strong></p><ul><li><code>bool</code>: if true, all <code>path</code>[<code>ind</code>] points are on <code>map_map</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2382-L2394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_check" href="#MagNav.map_check"><code>MagNav.map_check</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_check(map_map_vec::Vector, path::Path, ind = trues(path.N))</code></pre><p>Check if latitude and longitude points are on given maps.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map_vec</code>: vector of <code>Map</code> magnetic anomaly map structs</li><li><code>path</code>:        <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:         (optional) selected data indices</li></ul><p><strong>Returns:</strong></p><ul><li><code>bools</code>: if true, all <code>path</code>[<code>ind</code>] points are on <code>map_map_vec</code>[i]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2399-L2411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_chessboard!-Tuple{Matrix, Matrix, Vector, Vector, Real}" href="#MagNav.map_chessboard!-Tuple{Matrix, Matrix, Vector, Vector, Real}"><code>MagNav.map_chessboard!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_chessboard!(map_map::Matrix, map_alt::Matrix, map_xx::Vector,
                map_yy::Vector, alt::Real;
                down_cont::Bool = true,
                dz              = 5,
                down_max        = 150,
                α               = 200)</code></pre><p>Perform the <code>chessboard method</code>, which upward (and possibly downward) continues a map to multiple altitudes to create a 3D map, then vertically interpolates at each horizontal grid point.</p><p>Reference: Cordell, Phillips, &amp; Godson, U.S. Geological Survey Potential-Field Software Version 2.0, 1992.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>ny</code> x <code>nx</code> 2D gridded target (e.g., magnetic) map data on [m] grid</li><li><code>map_alt</code>:   <code>ny</code> x <code>nx</code> 2D gridded altitude map data [m] on [m] grid</li><li><code>map_xx</code>:    <code>nx</code> map x-direction (longitude) coordinates [m]</li><li><code>map_yy</code>:    <code>ny</code> map y-direction (latitude)  coordinates [m]</li><li><code>alt</code>:       final map altitude after upward continuation [m]</li><li><code>down_cont</code>: (optional) if true, downward continue if needed, only used if <code>up_cont = true</code></li><li><code>dz</code>:        (optional) upward continuation step size [m]</li><li><code>down_max</code>:  (optional) maximum downward continuation distance [m]</li><li><code>α</code>:         (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_map</code> is mutated with upward continued map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L912-L940">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_chessboard-Tuple{MagNav.MapSd, Real}" href="#MagNav.map_chessboard-Tuple{MagNav.MapSd, Real}"><code>MagNav.map_chessboard</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_chessboard(mapSd::MapSd, alt::Real;
               down_cont::Bool = true,
               dz              = 5,
               down_max        = 150,
               α               = 200)</code></pre><p>Perform the <code>chessboard method</code>, which upward (and possibly downward) continues a map to multiple altitudes to create a 3D map, then vertically interpolates at each horizontal grid point.</p><p>Reference: Cordell, Phillips, &amp; Godson, U.S. Geological Survey Potential-Field Software Version 2.0, 1992.</p><p><strong>Arguments:</strong></p><ul><li><code>mapSd</code>:     <code>MapSd</code> scalar magnetic anomaly map struct</li><li><code>alt</code>:       final map altitude after upward continuation [m]</li><li><code>down_cont</code>: (optional) if true, downward continue if needed</li><li><code>dz</code>:        (optional) upward continuation step size [m]</li><li><code>down_max</code>:  (optional) maximum downward continuation distance [m]</li><li><code>α</code>:         (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> scalar magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1009-L1033">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_combine" href="#MagNav.map_combine"><code>MagNav.map_combine</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_combine(mapS_vec::Vector, mapS_fallback::MapS = get_map(namad);
            map_info::String   = &quot;Combined map&quot;,
            N_levels::Int      = 3,
            dx                 = get_step(mapS_vec[1].xx),
            dy                 = get_step(mapS_vec[1].yy),
            xx_lim::Tuple      = get_lim(mapS_vec[1].xx,0.5),
            yy_lim::Tuple      = get_lim(mapS_vec[1].yy,0.5),
            α                  = 200,
            use_fallback::Bool = true)</code></pre><p>Combine maps at different altitudes. Lowest and highest maps are directly used (with resampling &amp; resizing), with intermediate maps determined by <code>N_levels</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS_vec</code>:      vector of <code>MapS</code> scalar magnetic anomaly map structs</li><li><code>mapS_fallback</code>: (optional) fallback <code>MapS</code> scalar magnetic anomaly map struct</li><li><code>map_info</code>:      (optional) map information</li><li><code>N_levels</code>:      (optional) number of map altitude levels</li><li><code>dx</code>:            (optional) desired x-direction map step size</li><li><code>dy</code>:            (optional) desired y-direction map step size</li><li><code>xx_lim</code>:        (optional) length-<code>2</code>x-direction map limits <code>(xx_min,xx_max)</code></li><li><code>yy_lim</code>:        (optional) length-<code>2</code> y-direction map limits <code>(yy_min,yy_max)</code></li><li><code>α</code>:             (optional) regularization parameter for downward continuation</li><li><code>use_fallback</code>:  (optional) if true, use <code>mapS_fallback</code> for missing map data</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS3D</code>: <code>MapS3D</code> 3D (multi-level) scalar magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L3005-L3033">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_combine" href="#MagNav.map_combine"><code>MagNav.map_combine</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_combine(mapS::MapS, mapS_fallback::MapS = get_map(namad);
            map_info::String = mapS.info,
            xx_lim::Tuple    = get_lim(mapS.xx,0.1),
            yy_lim::Tuple    = get_lim(mapS.yy,0.1),
            α                = 200)</code></pre><p>Combine two maps at same altitude.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:          <code>MapS</code> scalar magnetic anomaly map struct</li><li><code>mapS_fallback</code>: (optional) fallback <code>MapS</code> scalar magnetic anomaly map struct</li><li><code>map_info</code>:      (optional) map information</li><li><code>xx_lim</code>:        (optional) length-<code>2</code> x-direction map limits <code>(xx_min,xx_max)</code></li><li><code>yy_lim</code>:        (optional) length-<code>2</code> y-direction map limits <code>(yy_min,yy_max)</code></li><li><code>α</code>:             (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> scalar magnetic anomaly map struct, combined</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2948-L2967">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_correct_igrf!-Tuple{Matrix, Any, Vector, Vector}" href="#MagNav.map_correct_igrf!-Tuple{Matrix, Any, Vector, Vector}"><code>MagNav.map_correct_igrf!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_correct_igrf!(map_map::Matrix, map_alt,
                  map_xx::Vector, map_yy::Vector;
                  sub_igrf_date::Real = get_years(2013,293), # 20-Oct-2013
                  add_igrf_date::Real = -1,
                  zone_utm::Int       = 18,
                  is_north::Bool      = true,
                  map_units::Symbol   = :rad)</code></pre><p>Correct the International Geomagnetic Reference Field (IGRF), i.e., core field, of a map by subtracting and/or adding the IGRF on specified date(s).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:       <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_alt</code>:       <code>ny</code> x <code>nx</code> 2D gridded altitude map data, single altitude value may be provided [m]</li><li><code>map_xx</code>:        <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg] or [m]</li><li><code>map_yy</code>:        <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg] or [m]</li><li><code>sub_igrf_date</code>: (optional) date of IGRF core field to subtract [yr], -1 to ignore</li><li><code>add_igrf_date</code>: (optional) date of IGRF core field to add [yr], -1 to ignore</li><li><code>zone_utm</code>:      (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:      (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>:     (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_map</code> is mutated with IGRF corrected map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L602-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_correct_igrf!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_correct_igrf!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_correct_igrf!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_correct_igrf!(mapS::Union{MapS,MapSd,MapS3D};
                  sub_igrf_date::Real = get_years(2013,293), # 20-Oct-2013
                  add_igrf_date::Real = -1,
                  zone_utm::Int       = 18,
                  is_north::Bool      = true,
                  map_units::Symbol   = :rad)</code></pre><p>Correct the International Geomagnetic Reference Field (IGRF), i.e., core field, of a map by subtracting and/or adding the IGRF on specified date(s).</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:          <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>sub_igrf_date</code>: (optional) date of IGRF core field to subtract [yr], -1 to ignore</li><li><code>add_igrf_date</code>: (optional) date of IGRF core field to add [yr], -1 to ignore</li><li><code>zone_utm</code>:      (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:      (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>:     (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map</code> field within <code>mapS</code> is mutated with IGRF corrected map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L682-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_correct_igrf-Tuple{Matrix, Any, Vector, Vector}" href="#MagNav.map_correct_igrf-Tuple{Matrix, Any, Vector, Vector}"><code>MagNav.map_correct_igrf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_correct_igrf(map_map::Matrix, map_alt,
                 map_xx::Vector, map_yy::Vector;
                 sub_igrf_date::Real = get_years(2013,293), # 20-Oct-2013
                 add_igrf_date::Real = -1,
                 zone_utm::Int       = 18,
                 is_north::Bool      = true,
                 map_units::Symbol   = :rad)</code></pre><p>Correct the International Geomagnetic Reference Field (IGRF), i.e., core field, of a map by subtracting and/or adding the IGRF on specified date(s).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:       <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_alt</code>:       <code>ny</code> x <code>nx</code> 2D gridded altitude map data [m]</li><li><code>map_xx</code>:        <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg] or [m]</li><li><code>map_yy</code>:        <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg] or [m]</li><li><code>sub_igrf_date</code>: (optional) date of IGRF core field to subtract [yr], -1 to ignore</li><li><code>add_igrf_date</code>: (optional) date of IGRF core field to add [yr], -1 to ignore</li><li><code>zone_utm</code>:      (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:      (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>:     (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data, IGRF corrected</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L730-L755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_correct_igrf-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_correct_igrf-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_correct_igrf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_correct_igrf(mapS::Union{MapS,MapSd,MapS3D};
                 sub_igrf_date::Real = get_years(2013,293), # 20-Oct-2013
                 add_igrf_date::Real = -1,
                 zone_utm::Int       = 18,
                 is_north::Bool      = true,
                 map_units::Symbol   = :rad)</code></pre><p>Correct the International Geomagnetic Reference Field (IGRF), i.e., core field, of a map by subtracting and/or adding the IGRF on specified date(s).</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:          <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>sub_igrf_date</code>: (optional) date of IGRF core field to subtract [yr], -1 to ignore</li><li><code>add_igrf_date</code>: (optional) date of IGRF core field to add [yr], -1 to ignore</li><li><code>zone_utm</code>:      (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:      (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>:     (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct, IGRF corrected</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L773-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_expand" href="#MagNav.map_expand"><code>MagNav.map_expand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_expand(map_map::Matrix, pad::Int = 1)</code></pre><p>Expand a map with padding on each edge to eliminate discontinuities in the discrete Fourier transform. The map is “wrapped around” to make it periodic. Padding expands the map to 7-smooth dimensions, allowing for a faster Fast Fourier Transform algorithm to be used during upward/downward continuation.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>pad</code>:     minimum padding (grid cells) along map edges</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data, expanded (padded)</li><li><code>padx</code>:    x-direction padding (grid cells) applied on first edge</li><li><code>pady</code>:    y-direction padding (grid cells) applied on first edge</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L217-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_fill!-Tuple{Matrix, Vector, Vector}" href="#MagNav.map_fill!-Tuple{Matrix, Vector, Vector}"><code>MagNav.map_fill!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_fill!(map_map::Matrix, map_xx::Vector, map_yy::Vector; k::Int = 3)</code></pre><p>Fill areas that are missing map data.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:  <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:  <code>ny</code> map y-direction (latitude)  coordinates</li><li><code>k</code>:       (optional) number of nearest neighbors for knn</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_map</code> is mutated with filled map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L811-L824">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_fill!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_fill!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_fill!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_fill!(mapS::Union{MapS,MapSd,MapS3D}; k::Int = 3)</code></pre><p>Fill areas that are missing map data.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>k</code>:    (optional) number of nearest neighbors for knn</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map</code> field within <code>mapS</code> is mutated with filled map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L848-L859">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_fill-Tuple{Matrix, Vector, Vector}" href="#MagNav.map_fill-Tuple{Matrix, Vector, Vector}"><code>MagNav.map_fill</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_fill(map_map::Matrix, map_xx::Vector, map_yy::Vector; k::Int = 3)</code></pre><p>Fill areas that are missing map data.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:  <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:  <code>ny</code> map y-direction (latitude)  coordinates</li><li><code>k</code>:       (optional) number of nearest neighbors for knn</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data, filled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L874-L887">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_fill-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_fill-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_fill</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_fill(mapS::Union{MapS,MapSd,MapS3D}; k::Int = 3)</code></pre><p>Fill areas that are missing map data.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>k</code>:    (optional) number of nearest neighbors for knn</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct, filled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L894-L905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_get_gxf-Tuple{String}" href="#MagNav.map_get_gxf-Tuple{String}"><code>MagNav.map_get_gxf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_get_gxf(map_gxf::String)</code></pre><p>Use ArchGDAL to read in map data from GXF file.</p><p><strong>Arguments:</strong></p><ul><li><code>map_gxf</code>: path/name of map GXF file (<code>.gxf</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:  <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:  <code>ny</code> map y-direction (latitude)  coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L198-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_gxf2h5-Tuple{String, Real}" href="#MagNav.map_gxf2h5-Tuple{String, Real}"><code>MagNav.map_gxf2h5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_gxf2h5(map_gxf::String, alt::Real;
           map_info::String = splitpath(map_gxf)[end],
           fill_map::Bool   = true,
           get_lla::Bool    = true,
           zone_utm::Int    = 18,
           is_north::Bool   = true,
           save_h5::Bool    = false,
           map_h5::String   = &quot;map_data.h5&quot;)</code></pre><p>Convert map data file (with assumed <code>UTM</code> grid) from GXF to HDF5. The order of operations is:</p><ul><li>original map from <code>map_gxf</code> =&gt;</li><li>trim away large areas that are missing map data =&gt;</li><li>fill remaining areas that are missing map data =&gt;</li><li>convert map grid from <code>UTM</code> to <code>LLA</code></li></ul><p>Specifically meant for SMALL and LEVEL maps ONLY.</p><p><strong>Arguments:</strong></p><ul><li><code>map_gxf</code>:  path/name of target (e.g., magnetic) map GXF file (<code>.gxf</code> extension optional)</li><li><code>alt</code>:      map altitude [m]</li><li><code>map_info</code>: (optional) map information</li><li><code>fill_map</code>: (optional) if true, fill areas that are missing map data</li><li><code>get_lla</code>:  (optional) if true, convert map grid from <code>UTM</code> to <code>LLA</code></li><li><code>zone_utm</code>: (optional) UTM zone</li><li><code>is_north</code>: (optional) if true, map is in northern hemisphere</li><li><code>save_h5</code>:  (optional) if true, save <code>mapS</code> to <code>map_h5</code></li><li><code>map_h5</code>:   (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> scalar magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1419-L1450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_gxf2h5-Tuple{String, String, Real}" href="#MagNav.map_gxf2h5-Tuple{String, String, Real}"><code>MagNav.map_gxf2h5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_gxf2h5(map_gxf::String, alt_gxf::String, alt::Real;
           map_info::String    = splitpath(map_gxf)[end],
           pad::Int            = 0,
           sub_igrf_date::Real = get_years(2013,293),
           add_igrf_date::Real = -1,
           zone_utm::Int       = 18,
           is_north::Bool      = true,
           fill_map::Bool      = true,
           up_cont::Bool       = true,
           down_cont::Bool     = true,
           get_lla::Bool       = true,
           dz::Real            = 5,
           down_max::Real      = 150,
           α::Real             = 200,
           save_h5::Bool       = false,
           map_h5::String      = &quot;map_data.h5&quot;)</code></pre><p>Convert map data file (with assumed <code>UTM</code> grid) from GXF to HDF5. The order of operations is:</p><ul><li>original map from <code>map_gxf</code> =&gt;</li><li>trim away large areas that are missing map data =&gt;</li><li>subtract and/or add IGRF to map data =&gt;</li><li>fill remaining areas that are missing map data =&gt;</li><li>upward/downward continue to <code>alt</code> =&gt;</li><li>convert map grid from <code>UTM</code> to <code>LLA</code></li></ul><p>This can be memory intensive, largely depending on the map size and <code>dz</code>. If <code>up_cont = true</code>, a <code>MapS</code> struct is returned. If <code>up_cont = false</code>, a <code>MapSd</code> struct is returned, which has an included altitude map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_gxf</code>:       path/name of target (e.g., magnetic) map GXF file (<code>.gxf</code> extension optional)</li><li><code>alt_gxf</code>:       path/name of altitude map GXF file (<code>.gxf</code> extension optional)</li><li><code>alt</code>:           final map altitude after upward continuation [m], not used for drape map</li><li><code>map_info</code>:      (optional) map information</li><li><code>pad</code>:           (optional) minimum padding (grid cells) along map edges</li><li><code>sub_igrf_date</code>: (optional) date of IGRF core field to subtract [yr], -1 to ignore</li><li><code>add_igrf_date</code>: (optional) date of IGRF core field to add [yr], -1 to ignore</li><li><code>zone_utm</code>:      (optional) UTM zone</li><li><code>is_north</code>:      (optional) if true, map is in northern hemisphere</li><li><code>fill_map</code>:      (optional) if true, fill areas that are missing map data</li><li><code>up_cont</code>:       (optional) if true, upward/downward continue to <code>alt</code></li><li><code>down_cont</code>:     (optional) if true, downward continue if needed, only used if <code>up_cont = true</code></li><li><code>get_lla</code>:       (optional) if true, convert map grid from <code>UTM</code> to <code>LLA</code></li><li><code>dz</code>:            (optional) upward continuation step size [m]</li><li><code>down_max</code>:      (optional) maximum downward continuation distance [m]</li><li><code>α</code>:             (optional) regularization parameter for downward continuation</li><li><code>save_h5</code>:       (optional) if true, save <code>mapS</code> to <code>map_h5</code></li><li><code>map_h5</code>:        (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> or <code>MapSd</code> scalar magnetic anomaly map struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1274-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_interpolate" href="#MagNav.map_interpolate"><code>MagNav.map_interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_interpolate(mapV::MapV, dim::Symbol = :X, type::Symbol = :cubic)</code></pre><p>Create map interpolation function, equivalent of griddedInterpolant in MATLAB.</p><p><strong>Arguments:</strong></p><ul><li><code>mapV</code>: <code>MapV</code> vector magnetic anomaly map struct</li><li><code>dim</code>:  map dimension to interpolate {<code>:X</code>,<code>:Y</code>,<code>:Z</code>}</li><li><code>type</code>: (optional) type of interpolation {:linear,:quad,:cubic}</li></ul><p><strong>Returns:</strong></p><ul><li><code>itp_map</code>: map interpolation function (<code>f(yy,xx)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L128-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_interpolate" href="#MagNav.map_interpolate"><code>MagNav.map_interpolate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_interpolate(mapS::Union{MapS,MapSd,MapS3D}, type::Symbol = :cubic;
                return_vert_deriv::Bool = false)</code></pre><p>Create map interpolation function, equivalent of griddedInterpolant in MATLAB. Optionally return vertical derivative map interpolation function, which is calculated using finite differences between map and 1 m upward continued map.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:              <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>type</code>:              (optional) type of interpolation {:linear,:quad,:cubic}</li><li><code>return_vert_deriv</code>: (optional) if true, also return <code>der_map</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>itp_map</code>: map interpolation function (<code>f(yy,xx)</code> or (<code>f(yy,xx,alt)</code>)</li><li><code>der_map</code>: if <code>return_vert_deriv = true</code>, vertical derivative map interpolation function (<code>f(yy,xx)</code> or (<code>f(yy,xx,alt)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L84-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_interpolate-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}, Symbol}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}, Symbol, AbstractVector{T}}} where T" href="#MagNav.map_interpolate-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}, Symbol}, Tuple{AbstractArray{T}, AbstractVector{T}, AbstractVector{T}, Symbol, AbstractVector{T}}} where T"><code>MagNav.map_interpolate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_interpolate(map_map::AbstractArray{T},
                map_xx::AbstractVector{T},
                map_yy::AbstractVector{T},
                type::Symbol = :cubic,
                map_alt::AbstractVector{T} = T[0]) where T</code></pre><p>Create map interpolation function, equivalent of griddedInterpolant in MATLAB.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> (x <code>nz</code>) 2D or 3D gridded map data</li><li><code>map_xx</code>:  <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:  <code>ny</code> map y-direction (latitude)  coordinates</li><li><code>type</code>:    (optional) type of interpolation {:linear,:quad,:cubic}</li><li><code>map_alt</code>: (optional) map altitude levels</li></ul><p><strong>Returns:</strong></p><ul><li><code>itp_map</code>: map interpolation function (<code>f(yy,xx)</code> or (<code>f(yy,xx,alt)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_resample-Tuple{MagNav.MapS, MagNav.MapS}" href="#MagNav.map_resample-Tuple{MagNav.MapS, MagNav.MapS}"><code>MagNav.map_resample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_resample(mapS::MapS, mapS_new::MapS)</code></pre><p>Resample map with new grid.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:     <code>MapS</code> scalar magnetic anomaly map struct</li><li><code>mapS_new</code>: <code>MapS</code> scalar magnetic anomaly map struct to use for resampling</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> scalar magnetic anomaly map struct, resampled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2932-L2943">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_resample-Tuple{MagNav.MapS, Vector, Vector}" href="#MagNav.map_resample-Tuple{MagNav.MapS, Vector, Vector}"><code>MagNav.map_resample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_resample(mapS::MapS, map_xx_new::Vector, map_yy_new::Vector)</code></pre><p>Resample map with new grid.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:       <code>MapS</code> scalar magnetic anomaly map struct</li><li><code>map_xx_new</code>: <code>nx_new</code> map x-direction (longitude) coordinates to use for resampling</li><li><code>map_yy_new</code>: <code>ny_new</code> map y-direction (latitude)  coordinates to use for resampling</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code> scalar magnetic anomaly map struct, resampled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2913-L2925">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_resample-Tuple{Matrix, Vector, Vector, BitMatrix, Vector, Vector}" href="#MagNav.map_resample-Tuple{Matrix, Vector, Vector, BitMatrix, Vector, Vector}"><code>MagNav.map_resample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_resample(map_map::Matrix, map_xx::Vector, map_yy::Vector,
             map_mask::BitMatrix, map_xx_new::Vector, map_yy_new::Vector)</code></pre><p>Resample map with new grid.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:     <code>nx</code> map x-direction (longitude) coordinates</li><li><code>map_yy</code>:     <code>ny</code> map y-direction (latitude)  coordinates</li><li><code>map_mask</code>    <code>ny</code> x <code>nx</code> mask for valid (not filled-in) map data</li><li><code>map_xx_new</code>: <code>nx_new</code> map x-direction (longitude) coordinates to use for resampling</li><li><code>map_yy_new</code>: <code>ny_new</code> map y-direction (latitude)  coordinates to use for resampling</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>:  <code>ny_new</code> x <code>nx_new</code> 2D gridded map data, resampled</li><li><code>map_mask</code>: <code>ny_new</code> x <code>nx_new</code> mask for valid (not filled-in) map data, resampled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2864-L2881">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_trim" href="#MagNav.map_trim"><code>MagNav.map_trim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_trim(map_map::Matrix,
         map_xx::Vector    = collect(axes(map_map,2)),
         map_yy::Vector    = collect(axes(map_map,1)),
         pad::Int          = 0,
         xx_lim::Tuple     = (-Inf,Inf),
         yy_lim::Tuple     = (-Inf,Inf),
         zone_utm::Int     = 18,
         is_north::Bool    = true,
         map_units::Symbol = :rad,
         silent::Bool      = true)</code></pre><p>Trim map by removing large areas that are missing map data. Returns indices for the original map that produces the appropriate trimmed map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:    (optional) <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg] or [m]</li><li><code>map_yy</code>:    (optional) <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg] or [m]</li><li><code>pad</code>:       (optional) minimum padding (grid cells) along map edges</li><li><code>xx_lim</code>:    (optional) x-direction map limits <code>(xx_min,xx_max)</code> [rad] or [deg] or [m]</li><li><code>yy_lim</code>:    (optional) y-direction map limits <code>(yy_min,yy_max)</code> [rad] or [deg] or [m]</li><li><code>zone_utm</code>:  (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:  (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>: (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>ind_xx</code>: <code>nx</code> trimmed x-direction map indices</li><li><code>ind_yy</code>: <code>ny</code> trimmed y-direction map indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L364-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_trim-Tuple{MagNav.Map, MagNav.Path}" href="#MagNav.map_trim-Tuple{MagNav.Map, MagNav.Path}"><code>MagNav.map_trim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_trim(map_map::Map, path::Path;
         pad::Int          = 0,
         zone_utm::Int     = 18,
         is_north::Bool    = true,
         map_units::Symbol = :rad,
         silent::Bool      = true)</code></pre><p>Trim map by removing large areas far away from <code>path</code>. Do not use prior to upward continuation, as this causes in edge effect errors. Returns trimmed magnetic anomaly map struct.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>Map</code> magnetic anomaly map struct</li><li><code>path</code>:      <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>pad</code>:       (optional) minimum padding (grid cells) along map edges</li><li><code>zone_utm</code>:  (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:  (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>: (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct, trimmed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L562-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_trim-Tuple{MagNav.Map}" href="#MagNav.map_trim-Tuple{MagNav.Map}"><code>MagNav.map_trim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_trim(map_map::Map;
         pad::Int          = 0,
         xx_lim::Tuple     = (-Inf,Inf),
         yy_lim::Tuple     = (-Inf,Inf),
         zone_utm::Int     = 18,
         is_north::Bool    = true,
         map_units::Symbol = :rad,
         silent::Bool      = true)</code></pre><p>Trim map by removing large areas that are missing map data. Returns trimmed magnetic anomaly map struct.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>Map</code> magnetic anomaly map struct</li><li><code>pad</code>:       (optional) minimum padding (grid cells) along map edges</li><li><code>xx_lim</code>:    (optional) x-direction map limits <code>(xx_min,xx_max)</code> [rad] or [deg] or [m]</li><li><code>yy_lim</code>:    (optional) y-direction map limits <code>(yy_min,yy_max)</code> [rad] or [deg] or [m]</li><li><code>zone_utm</code>:  (optional) UTM zone, only used if <code>map_units = :utm</code></li><li><code>is_north</code>:  (optional) if true, map is in northern hemisphere, only used if <code>map_units = :utm</code></li><li><code>map_units</code>: (optional) map xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:utm</code>}</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct, trimmed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L495-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_utm2lla!-Tuple{Matrix, Vector, Vector, Any, BitMatrix}" href="#MagNav.map_utm2lla!-Tuple{Matrix, Vector, Vector, Any, BitMatrix}"><code>MagNav.map_utm2lla!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_utm2lla!(map_map::Matrix, map_xx::Vector, map_yy::Vector,
             alt, map_mask::BitMatrix;
             map_info::String = &quot;Map&quot;,
             zone_utm::Int    = 18,
             is_north::Bool   = true,
             save_h5::Bool    = false,
             map_h5::String   = &quot;map_data.h5&quot;)</code></pre><p>Convert map grid from <code>UTM</code> to <code>LLA</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:  <code>ny</code> x <code>nx</code> 2D gridded map data on <code>UTM</code> grid</li><li><code>map_xx</code>:   <code>nx</code> map x-direction (longitude) coordinates [m]</li><li><code>map_yy</code>:   <code>ny</code> map y-direction (latitude)  coordinates [m]</li><li><code>alt</code>:      map altitude(s) or altitude map [m]</li><li><code>map_mask</code>: <code>ny</code> x <code>nx</code> mask for valid (not filled-in) map data</li><li><code>map_info</code>: (optional) map information</li><li><code>zone_utm</code>: (optional) UTM zone</li><li><code>is_north</code>: (optional) if true, map is in northern hemisphere</li><li><code>save_h5</code>:  (optional) if true, save map data to <code>map_h5</code></li><li><code>map_h5</code>:   (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_map</code>, <code>map_xx</code>, <code>map_yy</code>, &amp; <code>map_mask</code> (&amp; <code>alt</code>) are mutated with <code>LLA</code> gridded map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1058-L1083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_utm2lla!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_utm2lla!-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_utm2lla!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_utm2lla!(mapS::Union{MapS,MapSd,MapS3D};
             zone_utm::Int  = 18,
             is_north::Bool = true,
             save_h5::Bool  = false
             map_h5::String = &quot;map_data.h5&quot;)</code></pre><p>Convert map grid from <code>UTM</code> to <code>LLA</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:     <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct on <code>UTM</code> grid</li><li><code>zone_utm</code>: (optional) UTM zone</li><li><code>is_north</code>: (optional) if true, map is in northern hemisphere</li><li><code>save_h5</code>:  (optional) if true, save <code>mapS</code> to <code>map_h5</code></li><li><code>map_h5</code>:   (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map</code>, <code>xx</code>, <code>yy</code>, &amp; <code>mask</code> (&amp; <code>alt</code>) fields within <code>mapS</code> are mutated with <code>LLA</code> gridded map data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1138-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_utm2lla-Tuple{Matrix, Vector, Vector, Any, BitMatrix}" href="#MagNav.map_utm2lla-Tuple{Matrix, Vector, Vector, Any, BitMatrix}"><code>MagNav.map_utm2lla</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_utm2lla(map_map::Matrix, map_xx::Vector, map_yy::Vector,
            alt, map_mask::BitMatrix;
            map_info::String = &quot;Map&quot;,
            zone_utm::Int    = 18,
            is_north::Bool   = true,
            save_h5::Bool    = false,
            map_h5::String   = &quot;map_data.h5&quot;)</code></pre><p>Convert map grid from <code>UTM</code> to <code>LLA</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:  <code>ny</code> x <code>nx</code> 2D gridded map data on <code>UTM</code> grid</li><li><code>map_xx</code>:   <code>nx</code> map x-direction (longitude) coordinates [m]</li><li><code>map_yy</code>:   <code>ny</code> map y-direction (latitude)  coordinates [m]</li><li><code>alt</code>:      map altitude(s) or altitude map [m]</li><li><code>map_mask</code>: <code>ny</code> x <code>nx</code> mask for valid (not filled-in) map data</li><li><code>map_info</code>: (optional) map information</li><li><code>zone_utm</code>: (optional) UTM zone</li><li><code>is_north</code>: (optional) if true, map is in northern hemisphere</li><li><code>save_h5</code>:  (optional) if true, save map data to <code>map_h5</code></li><li><code>map_h5</code>:   (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>:  <code>ny</code> x <code>nx</code> 2D gridded map data on <code>LLA</code> grid</li><li><code>map_xx</code>:   <code>nx</code> map x-direction (longitude) coordinates [rad]</li><li><code>map_yy</code>:   <code>ny</code> map y-direction (latitude)  coordinates [rad]</li><li><code>map_mask</code>: <code>ny</code> x <code>nx</code> mask for valid (not filled-in) map data on <code>LLA</code> grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1191-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.map_utm2lla-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.map_utm2lla-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.map_utm2lla</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_utm2lla(mapS::Union{MapS,MapSd,MapS3D};
            zone_utm::Int  = 18,
            is_north::Bool = true,
            save_h5::Bool  = false
            map_h5::String = &quot;map_data.h5&quot;)</code></pre><p>Convert map grid from <code>UTM</code> to <code>LLA</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>:     <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct on <code>UTM</code> grid</li><li><code>zone_utm</code>: (optional) UTM zone</li><li><code>is_north</code>: (optional) if true, map is in northern hemisphere</li><li><code>save_h5</code>:  (optional) if true, save <code>mapS</code> to <code>map_h5</code></li><li><code>map_h5</code>:   (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct on <code>LLA</code> grid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1241-L1259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.mpf-NTuple{13, Any}" href="#MagNav.mpf-NTuple{13, Any}"><code>MagNav.mpf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS;
    P0         = create_P0(),
    Qd         = create_Qd(),
    R          = 1.0,
    num_part   = 1000,
    thresh     = 0.8,
    baro_tau   = 3600.0,
    acc_tau    = 3600.0,
    gyro_tau   = 3600.0,
    fogm_tau   = 600.0,
    date       = get_years(2020,185),
    core::Bool = false)</code></pre><p>Rao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic anomaly navigation. This simplified MPF works only with LINEAR dynamics. This allows the same Kalman filter covariance matrices to be used with each particle, simplifying the filter and reducing the computational load. It is especially suited for map-matching navigation in which there is a highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics. The filter also assumes NON-correlated measurements to speed up computation.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:      latitude  [rad]</li><li><code>lon</code>:      longitude [rad]</li><li><code>alt</code>:      altitude  [m]</li><li><code>vn</code>:       north velocity [m/s]</li><li><code>ve</code>:       east  velocity [m/s]</li><li><code>vd</code>:       down  velocity [m/s]</li><li><code>fn</code>:       north specific force [m/s^2]</li><li><code>fe</code>:       east  specific force [m/s^2]</li><li><code>fd</code>:       down  specific force [m/s^2]</li><li><code>Cnb</code>:      direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>dt</code>:       measurement time step [s]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>num_part</code>: (optional) number of particles</li><li><code>thresh</code>:   (optional) resampling threshold fraction {0:1}</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/mpf.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.mpf-Tuple{MagNav.INS, Any, Any}" href="#MagNav.mpf-Tuple{MagNav.INS, Any, Any}"><code>MagNav.mpf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpf(ins::INS, meas, itp_mapS;
    P0         = create_P0(),
    Qd         = create_Qd(),
    R          = 1.0,
    num_part   = 1000,
    thresh     = 0.8,
    baro_tau   = 3600.0,
    acc_tau    = 3600.0,
    gyro_tau   = 3600.0,
    fogm_tau   = 600.0,
    date       = get_years(2020,185),
    core::Bool = false)</code></pre><p>Rao-Blackwellized (marginalized) particle filter (MPF) for airborne magnetic anomaly navigation. This simplified MPF works only with LINEAR dynamics. This allows the same Kalman filter covariance matrices to be used with each particle, simplifying the filter and reducing the computational load. It is especially suited for map-matching navigation in which there is a highly non-linear, non-Gaussian MEASUREMENT, but NOT non-linear dynamics. The filter also assumes NON-correlated measurements to speed up computation.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>num_part</code>: (optional) number of particles</li><li><code>thresh</code>:   (optional) resampling threshold fraction {0:1}</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/mpf.jl#L184-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.nekf" href="#MagNav.nekf"><code>MagNav.nekf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nekf(ins::INS, meas, itp_mapS,
     x_nn::Matrix = meas[:,:],
     m            = Dense(1 =&gt; 1);
     P0           = create_P0(),
     Qd           = create_Qd(),
     R            = 1.0,
     baro_tau     = 3600.0,
     acc_tau      = 3600.0,
     gyro_tau     = 3600.0,
     fogm_tau     = 600.0,
     date         = get_years(2020,185),
     core::Bool   = false)</code></pre><p>Measurement noise covariance-adaptive neural extended Kalman filter (nEKF) for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:      <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:     <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>m</code>:        neural network model</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/nekf.jl#L115-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.nekf" href="#MagNav.nekf"><code>MagNav.nekf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nekf(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt, itp_mapS,
     x_nn::Matrix = meas[:,:],
     m            = Dense(1 =&gt; 1);
     P0           = create_P0(),
     Qd           = create_Qd(),
     R            = 1.0,
     baro_tau     = 3600.0,
     acc_tau      = 3600.0,
     gyro_tau     = 3600.0,
     fogm_tau     = 600.0,
     date         = get_years(2020,185),
     core::Bool   = false)</code></pre><p>Measurement noise covariance-adaptive neural extended Kalman filter (nEKF) for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:      latitude  [rad]</li><li><code>lon</code>:      longitude [rad]</li><li><code>alt</code>:      altitude  [m]</li><li><code>vn</code>:       north velocity [m/s]</li><li><code>ve</code>:       east  velocity [m/s]</li><li><code>vd</code>:       down  velocity [m/s]</li><li><code>fn</code>:       north specific force [m/s^2]</li><li><code>fe</code>:       east  specific force [m/s^2]</li><li><code>fd</code>:       down  specific force [m/s^2]</li><li><code>Cnb</code>:      direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:     scalar magnetometer measurement [nT]</li><li><code>dt</code>:       measurement time step [s]</li><li><code>itp_mapS</code>: scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:     <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>m</code>:        neural network model</li><li><code>P0</code>:       (optional) initial covariance matrix</li><li><code>Qd</code>:       (optional) discrete time process/system noise matrix</li><li><code>R</code>:        (optional) measurement (white) noise variance</li><li><code>baro_tau</code>: (optional) barometer time constant [s]</li><li><code>acc_tau</code>:  (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>: (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>: (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:     (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:     (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/nekf.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.nekf_train-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Matrix, Matrix}" href="#MagNav.nekf_train-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Matrix, Matrix}"><code>MagNav.nekf_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nekf_train(lat, lon, alt, vn, ve, vd, fn, fe, fd, Cnb, meas, dt,
           itp_mapS, x_nn::Matrix, y_nn::Matrix;
           P0                   = create_P0(),
           Qd                   = create_Qd(),
           R                    = 1.0,
           baro_tau             = 3600.0,
           acc_tau              = 3600.0,
           gyro_tau             = 3600.0,
           fogm_tau             = 600.0,
           η_adam               = 0.1,
           epoch_adam::Int      = 10,
           hidden::Int          = 1,
           activation::Function = swish,
           l_window::Int        = 50,
           date                 = get_years(2020,185),
           core::Bool           = false)</code></pre><p>Train a measurement noise covariance-adaptive neural extended Kalman filter (nEKF) model for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>alt</code>:        altitude  [m]</li><li><code>vn</code>:         north velocity [m/s]</li><li><code>ve</code>:         east  velocity [m/s]</li><li><code>vd</code>:         down  velocity [m/s]</li><li><code>fn</code>:         north specific force [m/s^2]</li><li><code>fe</code>:         east  specific force [m/s^2]</li><li><code>fd</code>:         down  specific force [m/s^2]</li><li><code>Cnb</code>:        direction cosine matrix (body to navigation) [-]</li><li><code>meas</code>:       scalar magnetometer measurement [nT]</li><li><code>dt</code>:         measurement time step [s]</li><li><code>itp_mapS</code>:   scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:       <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>y_nn</code>:       <code>y</code> target matrix for neural network (<code>[latitude longitude]</code>)</li><li><code>P0</code>:         (optional) initial covariance matrix</li><li><code>Qd</code>:         (optional) discrete time process/system noise matrix</li><li><code>R</code>:          (optional) measurement (white) noise variance</li><li><code>baro_tau</code>:   (optional) barometer time constant [s]</li><li><code>acc_tau</code>:    (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:   (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>η_adam</code>:     (optional) learning rate for Adam optimizer</li><li><code>epoch_adam</code>: (optional) number of epochs for Adam optimizer</li><li><code>hidden</code>:     (optional) hidden layers &amp; nodes (e.g., <code>[8,8]</code> for 2 hidden layers, 8 nodes each)</li><li><code>activation</code>: (optional) activation function<ul><li><code>relu</code>  = rectified linear unit</li><li><code>σ</code>     = sigmoid (logistic function)</li><li><code>swish</code> = self-gated</li><li><code>tanh</code>  = hyperbolic tan</li><li>run <code>plot_activation()</code> for a visual</li></ul></li><li><code>l_window</code>:   (optional) temporal window length</li><li><code>date</code>:       (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:       (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>m</code>: neural network model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/nekf.jl#L243-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.nekf_train-Tuple{MagNav.INS, Any, Any, Matrix, Matrix}" href="#MagNav.nekf_train-Tuple{MagNav.INS, Any, Any, Matrix, Matrix}"><code>MagNav.nekf_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nekf_train(ins::INS, meas, itp_mapS, x_nn::Matrix, y_nn::Matrix;
           P0                   = create_P0(),
           Qd                   = create_Qd(),
           R                    = 1.0,
           baro_tau             = 3600.0,
           acc_tau              = 3600.0,
           gyro_tau             = 3600.0,
           fogm_tau             = 600.0,
           η_adam               = 0.1,
           epoch_adam::Int      = 10,
           hidden::Int          = 1,
           activation::Function = swish,
           l_window::Int        = 50,
           date                 = get_years(2020,185),
           core::Bool           = false)</code></pre><p>Train a measurement noise covariance-adaptive neural extended Kalman filter (nEKF) model for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>ins</code>:        <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:       scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>:   scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x_nn</code>:       <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>y_nn</code>:       <code>y</code> target matrix for neural network (<code>[latitude longitude]</code>)</li><li><code>P0</code>:         (optional) initial covariance matrix</li><li><code>Qd</code>:         (optional) discrete time process/system noise matrix</li><li><code>R</code>:          (optional) measurement (white) noise variance</li><li><code>baro_tau</code>:   (optional) barometer time constant [s]</li><li><code>acc_tau</code>:    (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:   (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>η_adam</code>:     (optional) learning rate for Adam optimizer</li><li><code>epoch_adam</code>: (optional) number of epochs for Adam optimizer</li><li><code>hidden</code>:     (optional) hidden layers &amp; nodes (e.g., <code>[8,8]</code> for 2 hidden layers, 8 nodes each)</li><li><code>activation</code>: (optional) activation function<ul><li><code>relu</code>  = rectified linear unit</li><li><code>σ</code>     = sigmoid (logistic function)</li><li><code>swish</code> = self-gated</li><li><code>tanh</code>  = hyperbolic tan</li><li>run <code>plot_activation()</code> for a visual</li></ul></li><li><code>l_window</code>:   (optional) temporal window length</li><li><code>date</code>:       (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:       (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>m</code>: neural network model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/nekf.jl#L371-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.nekf_train-Tuple{MagNav.XYZ, Any, Any, Any, Matrix}" href="#MagNav.nekf_train-Tuple{MagNav.XYZ, Any, Any, Any, Matrix}"><code>MagNav.nekf_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nekf_train(xyz::XYZ, ind, meas, itp_mapS, x::Matrix;
           P0                   = create_P0(),
           Qd                   = create_Qd(),
           R                    = 1.0,
           baro_tau             = 3600.0,
           acc_tau              = 3600.0,
           gyro_tau             = 3600.0,
           fogm_tau             = 600.0,
           η_adam               = 0.1,
           epoch_adam::Int      = 10,
           hidden::Int          = 1,
           activation::Function = swish,
           l_window::Int        = 50,
           date                 = get_years(2020,185),
           core::Bool           = false)</code></pre><p>Train a measurement noise covariance-adaptive neural extended Kalman filter (nEKF) model for airborne magnetic anomaly navigation.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:        <code>XYZ</code> flight data struct</li><li><code>ind</code>:        selected data indices</li><li><code>meas</code>:       scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>:   scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>x</code>:          <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>P0</code>:         (optional) initial covariance matrix</li><li><code>Qd</code>:         (optional) discrete time process/system noise matrix</li><li><code>R</code>:          (optional) measurement (white) noise variance</li><li><code>baro_tau</code>:   (optional) barometer time constant [s]</li><li><code>acc_tau</code>:    (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:   (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:   (optional) FOGM catch-all time constant [s]</li><li><code>η_adam</code>:     (optional) learning rate for Adam optimizer</li><li><code>epoch_adam</code>: (optional) number of epochs for Adam optimizer</li><li><code>hidden</code>:     (optional) hidden layers &amp; nodes (e.g., <code>[8,8]</code> for 2 hidden layers, 8 nodes each)</li><li><code>activation</code>: (optional) activation function<ul><li><code>relu</code>  = rectified linear unit</li><li><code>σ</code>     = sigmoid (logistic function)</li><li><code>swish</code> = self-gated</li><li><code>tanh</code>  = hyperbolic tan</li><li>run <code>plot_activation()</code> for a visual</li></ul></li><li><code>l_window</code>:   (optional) temporal window length</li><li><code>date</code>:       (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:       (optional) if true, include core magnetic field in measurement</li></ul><p><strong>Returns:</strong></p><ul><li><code>m</code>:          neural network model</li><li><code>data_norms</code>: length-<code>3</code> tuple of data normalizations, <code>(v_scale,x_bias,x_scale)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/nekf.jl#L451-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.norm_sets-Tuple{Any, Any, Any}" href="#MagNav.norm_sets-Tuple{Any, Any, Any}"><code>MagNav.norm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm_sets(train, val, test;
          norm_type::Symbol = :standardize,
          no_norm           = falses(size(train,2)))</code></pre><p>Normalize (or standardize) features (columns) of training, validation, &amp; testing data.</p><p><strong>Arguments:</strong></p><ul><li><code>train</code>:     <code>N_train</code> x <code>Nf</code> training data</li><li><code>val</code>:       <code>N_val</code>   x <code>Nf</code> validation data</li><li><code>test</code>:      <code>N_test</code>  x <code>Nf</code> testing data</li><li><code>norm_type</code>: (optional) normalization type:<ul><li><code>:standardize</code> = Z-score normalization</li><li><code>:normalize</code>   = min-max normalization</li><li><code>:scale</code>       = scale by maximum absolute value, bias = 0</li><li><code>:none</code>        = scale by 1, bias = 0</li></ul></li><li><code>no_norm</code>: (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training   data, normalized</li><li><code>val</code>:         <code>N_val</code>   x <code>Nf</code> validation data, normalized</li><li><code>test</code>:        <code>N_test</code>  x <code>Nf</code> testing    data, normalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1418-L1443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.norm_sets-Tuple{Any, Any}" href="#MagNav.norm_sets-Tuple{Any, Any}"><code>MagNav.norm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm_sets(train, test;
          norm_type::Symbol = :standardize,
          no_norm           = falses(size(train,2)))</code></pre><p>Normalize (or standardize) features (columns) of training &amp; testing data.</p><p><strong>Arguments:</strong></p><ul><li><code>train</code>:     <code>N_train</code> x <code>Nf</code> training data</li><li><code>test</code>:      <code>N_test</code>  x <code>Nf</code> testing data</li><li><code>norm_type</code>: (optional) normalization type:<ul><li><code>:standardize</code> = Z-score normalization</li><li><code>:normalize</code>   = min-max normalization</li><li><code>:scale</code>       = scale by maximum absolute value, bias = 0</li><li><code>:none</code>        = scale by 1, bias = 0</li></ul></li><li><code>no_norm</code>: (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training data, normalized</li><li><code>test</code>:        <code>N_test</code>  x <code>Nf</code> testing  data, normalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1378-L1400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.norm_sets-Tuple{Any}" href="#MagNav.norm_sets-Tuple{Any}"><code>MagNav.norm_sets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm_sets(train;
          norm_type::Symbol = :standardize,
          no_norm           = falses(size(train,2)))</code></pre><p>Normalize (or standardize) features (columns) of training data.</p><p><strong>Arguments:</strong></p><ul><li><code>train</code>:     <code>N_train</code> x <code>Nf</code> training data</li><li><code>norm_type</code>: (optional) normalization type:<ul><li><code>:standardize</code> = Z-score normalization</li><li><code>:normalize</code>   = min-max normalization</li><li><code>:scale</code>       = scale by maximum absolute value, bias = 0</li><li><code>:none</code>        = scale by 1, bias = 0</li></ul></li><li><code>no_norm</code>: (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li></ul><p><strong>Returns:</strong></p><ul><li><code>train_bias</code>:  <code>1</code> x <code>Nf</code> training data biases (means, mins, or zeros)</li><li><code>train_scale</code>: <code>1</code> x <code>Nf</code> training data scaling factors (std devs, maxs-mins, or ones)</li><li><code>train</code>:       <code>N_train</code> x <code>Nf</code> training data, normalized</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1323-L1343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ottawa_area_maps-Tuple{}" href="#MagNav.ottawa_area_maps-Tuple{}"><code>MagNav.ottawa_area_maps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ottawa_area_maps()</code></pre><p>Magnetic anomaly maps near Ottawa, Ontario, Canada, contains:</p><ul><li><code>Eastern_395.h5</code>:   Eastern Ontario at 395 m HAE</li><li><code>Eastern_drape.h5</code>: Eastern Ontario on drape</li><li><code>Renfrew_395.h5</code>:   Renfrew at 395 m HAE</li><li><code>Renfrew_555.h5</code>:   Renfrew at 555 m HAE</li><li><code>Renfrew_drape.h5</code>: Renfrew on drape</li><li><code>HighAlt_5181.h5</code>:  High Altitude mini-survey (within Renfrew) at 5181 m HAE</li><li><code>Perth_800.h5</code>:     Perth mini-survey (within Eastern Ontario) at 800 m HAE</li></ul><p><code>NOTE</code>: Missing map data within each map has been filled in (using k-nearest neighbors) so that the maps are fully filled. Care must be taken to not navigate in the filled-in areas, as this is not real data and only done for more accurate and consistent upward continuation of the maps. Use the <code>map_check</code> function with the desired map and flight path data to check if the map may be used without navigating into filled-in (artificial) areas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/MagNav.jl#L185-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.ottawa_area_maps_gxf-Tuple{}" href="#MagNav.ottawa_area_maps_gxf-Tuple{}"><code>MagNav.ottawa_area_maps_gxf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ottawa_area_maps_gxf()</code></pre><p>GXF versions of small magnetic anomaly maps near Ottawa, Ontario, Canada, contains:</p><ul><li><code>HighAlt_Mag.gxf</code>: High Altitude mini-survey (within Renfrew) at 5181 m HAE</li><li><code>Perth_Mag.gxf</code>:   Perth mini-survey (within Eastern Ontario) at 800 m HAE</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/MagNav.jl#L206-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.path2kml" href="#MagNav.path2kml"><code>MagNav.path2kml</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">path2kml(lat::Vector, lon::Vector, alt::Vector,
         path_kml::String   = &quot;path.kml&quot;;
         path_units::Symbol = :rad,
         width::Int         = 3,
         color1::String     = &quot;ff000000&quot;,
         color2::String     = &quot;80000000&quot;,
         points::Bool       = false)</code></pre><p>Create KML file of flight path for use with Google Earth.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:        latitude  [rad] or [deg]</li><li><code>lon</code>:        longitude [rad] or [deg]</li><li><code>alt</code>:        altitude  [m]</li><li><code>path_kml</code>:   (optional) path/name of flight path KML file to save (<code>.kml</code> extension optional)</li><li><code>path_units</code>: (optional) <code>lat</code>/<code>lon</code> units {<code>:rad</code>,<code>:deg</code>}</li><li><code>width</code>:      (optional) line width</li><li><code>color1</code>:     (optional) path color</li><li><code>color2</code>:     (optional) below-path color</li><li><code>points</code>:     (optional) if true, create points instead of line</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>path_kml</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/google_earth.jl#L151-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.path2kml" href="#MagNav.path2kml"><code>MagNav.path2kml</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">path2kml(path::Path,
         path_kml::String = &quot;path.kml&quot;;
         width::Int       = 3,
         color1::String   = &quot;&quot;,
         color2::String   = &quot;00ffffff&quot;,
         points::Bool     = false)</code></pre><p>Create KML file of flight path for use with Google Earth.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:      <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>path_kml</code>:  (optional) path/name of flight path KML file to save (<code>.kml</code> extension optional)</li><li><code>width</code>:     (optional) line width</li><li><code>color1</code>:    (optional) path color</li><li><code>color2</code>:    (optional) below-path color</li><li><code>points</code>:    (optional) if true, create points instead of line</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>path_kml</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/google_earth.jl#L305-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_activation" href="#MagNav.plot_activation"><code>MagNav.plot_activation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_activation(activation = [:relu,:σ,:swish,:tanh];
                plot_deriv::Bool  = false,
                show_plot::Bool   = true,
                save_plot::Bool   = false,
                plot_png::String  = &quot;act_func.png&quot;)</code></pre><p>Plot activation function(s) or their derivative(s).</p><p><strong>Arguments:</strong></p><ul><li><code>activation</code>: activation function(s) to plot<ul><li><code>relu</code>  = rectified linear unit</li><li><code>σ</code>     = sigmoid (logistic function)</li><li><code>swish</code> = self-gated</li><li><code>tanh</code>  = hyperbolic tan</li></ul></li><li><code>plot_deriv</code>: (optional) if true, plot activation function(s) derivative(s)</li><li><code>show_plot</code>:  (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:  (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:   (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of activation function(s) or their derivative(s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L42-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_autocor" href="#MagNav.plot_autocor"><code>MagNav.plot_autocor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_autocor(x::Vector, dt = 0.1, dt_max = 300.0;
             show_plot::Bool  = true,
             save_plot::Bool  = false,
             plot_png::String = &quot;autocor.png&quot;)</code></pre><p>Plot autocorrelation of data (e.g., actual - expected measurements). Prints out <code>σ</code> = standard deviation &amp; <code>τ</code> = autocorrelation decay to e^-1 of <code>x</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:         data vector</li><li><code>dt</code>:        (optional) measurement time step [s]</li><li><code>dt_max</code>:    (optional) maximum time step to evaluate [s]</li><li><code>show_plot</code>: (optional) if true, show <code>p1</code></li><li><code>save_plot</code>: (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:  (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of autocorrelation of <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L912-L931">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_basic" href="#MagNav.plot_basic"><code>MagNav.plot_basic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_basic(tt::Vector, y::Vector, ind = trues(length(tt));
           lab::String      = &quot;&quot;,
           xlab::String     = &quot;time [min]&quot;,
           ylab::String     = &quot;&quot;,
           show_plot::Bool  = true,
           save_plot::Bool  = false,
           plot_png::String = &quot;data_vs_time.png&quot;)</code></pre><p>Plot data vs time.</p><p><strong>Arguments:</strong></p><ul><li><code>tt</code>:        length-<code>N</code> time vector [s]</li><li><code>y</code>:         length-<code>N</code> data vector</li><li><code>ind</code>:       (optional) selected data indices</li><li><code>lab</code>:       (optional) data (legend) label</li><li><code>xlab</code>:      (optional) x-axis label</li><li><code>ylab</code>:      (optional) y-axis label</li><li><code>show_plot</code>: (optional) if true, show <code>p1</code></li><li><code>save_plot</code>: (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:  (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of <code>y</code> vs <code>tt</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_correlation" href="#MagNav.plot_correlation"><code>MagNav.plot_correlation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_correlation(xyz::XYZ,
                 xfeature::Symbol = :mag_1_c,
                 yfeature::Symbol = :mag_1_uc,
                 ind              = trues(xyz.traj.N);
                 lim::Real        = 0,
                 dpi::Int         = 200,
                 show_plot::Bool  = true,
                 save_plot::Bool  = false,
                 plot_png::String = &quot;$xfeature-$yfeature.png&quot;,
                 silent::Bool     = true)</code></pre><p>Plot the correlation between 2 features.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:       <code>XYZ</code> flight data struct</li><li><code>xfeature</code>:  x-axis feature name</li><li><code>yfeature</code>:  y-axis feature name</li><li><code>ind</code>:       (optional) selected data indices</li><li><code>lim</code>:       (optional) only plot if Pearson correlation coefficient &gt; <code>lim</code></li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>show_plot</code>: (optional) if true, show <code>p1</code></li><li><code>save_plot</code>: (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:  (optional) plot file name to save (<code>.png</code> extension optional)</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of <code>yfeature</code> vs <code>xfeature</code> correlation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L593-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_correlation" href="#MagNav.plot_correlation"><code>MagNav.plot_correlation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_correlation(x::Vector, y::Vector,
                 xfeature::Symbol = :feature_1,
                 yfeature::Symbol = :feature_2;
                 lim::Real        = 0,
                 dpi::Int         = 200,
                 show_plot::Bool  = true,
                 save_plot::Bool  = false,
                 plot_png::String = &quot;$xfeature-$yfeature.png&quot;,
                 silent::Bool     = true)</code></pre><p>Plot the correlation between 2 features.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:         x-axis data</li><li><code>y</code>:         y-axis data</li><li><code>xfeature</code>:  x-axis feature name</li><li><code>yfeature</code>:  y-axis feature name</li><li><code>lim</code>:       (optional) only plot if Pearson correlation coefficient &gt; <code>lim</code></li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>show_plot</code>: (optional) if true, show <code>p1</code></li><li><code>save_plot</code>: (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:  (optional) plot file name to save (<code>.png</code> extension optional)</li><li><code>silent</code>:    (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of <code>yfeature</code> vs <code>xfeature</code> correlation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L536-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_correlation_matrix" href="#MagNav.plot_correlation_matrix"><code>MagNav.plot_correlation_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_correlation_matrix(xyz::XYZ, ind = trues(xyz.traj.N),
                        features_setup::Vector{Symbol} = [:mag_1_uc,:TL_A_flux_a];
                        terms             = [:permanent],
                        sub_diurnal::Bool = false,
                        sub_igrf::Bool    = false,
                        bpf_mag::Bool     = false,
                        dpi::Int          = 200,
                        Nmax::Int         = 1000,
                        show_plot::Bool   = true,
                        save_plot::Bool   = false,
                        plot_png::String  = &quot;correlation_matrix.png&quot;)</code></pre><p>Plot the correlation matrix for <code>2-5</code> features.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:            <code>XYZ</code> flight data struct</li><li><code>ind</code>:            selected data indices</li><li><code>features_setup</code>: vector of features to include</li><li><code>terms</code>:          (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>sub_diurnal</code>:    (optional) if true, subtract diurnal from scalar magnetometer measurements</li><li><code>sub_igrf</code>:       (optional) if true, subtract IGRF from scalar magnetometer measurements</li><li><code>bpf_mag</code>:        (optional) if true, bpf scalar magnetometer measurements</li><li><code>dpi</code>:            (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:           (optional) maximum number of data points plotted</li><li><code>show_plot</code>:      (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:      (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:       (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of correlation matrix between <code>features</code> (created from <code>features_setup</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L714-L745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_correlation_matrix-Tuple{AbstractMatrix, Vector{Symbol}}" href="#MagNav.plot_correlation_matrix-Tuple{AbstractMatrix, Vector{Symbol}}"><code>MagNav.plot_correlation_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_correlation_matrix(x::AbstractMatrix, features::Vector{Symbol};
                        dpi::Int         = 200,
                        Nmax::Int        = 1000,
                        show_plot::Bool  = true,
                        save_plot::Bool  = false,
                        plot_png::String = &quot;correlation_matrix.png&quot;)</code></pre><p>Plot the correlation matrix for <code>2-5</code> features.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:         <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>features</code>:  length-<code>Nf</code> feature vector (including components of TL <code>A</code>, etc.)</li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:      (optional) maximum number of data points plotted</li><li><code>show_plot</code>: (optional) if true, show <code>p1</code></li><li><code>save_plot</code>: (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:  (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of correlation matrix between <code>features</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L643-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_events!" href="#MagNav.plot_events!"><code>MagNav.plot_events!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_events!(p1::Plot, t::Real, lab::String = &quot;&quot;;
             legend::Symbol = :outertopright)</code></pre><p>Plot in-flight event on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:     plot (i.e., time series of data)</li><li><code>t</code>:      time of in-flight event</li><li><code>lab</code>:    (optional) in-flight event (legend) label</li><li><code>legend</code>: (optional) legend position (e.g., <code>:topleft</code>,<code>:outertopright</code>)</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: in-flight event is plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2232-L2246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_events!-Tuple{Plots.Plot, Symbol, DataFrames.DataFrame}" href="#MagNav.plot_events!-Tuple{Plots.Plot, Symbol, DataFrames.DataFrame}"><code>MagNav.plot_events!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_events!(p1::Plot, flight::Symbol,  df_event::DataFrame;
             keyword::String = &quot;&quot;,
             show_lab::Bool  = true,
             t0::Real        = 0,
             t_units::Symbol = :sec,
             legend::Symbol  = :outertopright)</code></pre><p>Plot in-flight event(s) on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:       plot (i.e., time series of data)</li><li><code>flight</code>:   flight name (e.g., <code>:Flt1001</code>)</li><li><code>df_event</code>: lookup table (DataFrame) of in-flight events</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">time of <code>event</code> [s]</td></tr><tr><td style="text-align: left"><code>event</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">event description</td></tr></table><ul><li><code>keyword</code>:  (optional) keyword to search within events, case insensitive</li><li><code>show_lab</code>: (optional) if true, show in-flight event (legend) label(s)</li><li><code>t0</code>:       (optional) time offset [<code>t_units</code>]</li><li><code>t_units</code>:  (optional) time units {<code>:sec</code>,<code>:min</code>}</li><li><code>legend</code>:   (optional) legend position (e.g., <code>:topleft</code>,<code>:outertopright</code>)</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: in-flight events are plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2253-L2280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_events-Tuple{Plots.Plot, Symbol, DataFrames.DataFrame}" href="#MagNav.plot_events-Tuple{Plots.Plot, Symbol, DataFrames.DataFrame}"><code>MagNav.plot_events</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_events(p1::Plot, flight::Symbol,  df_event::DataFrame;
            keyword::String = &quot;&quot;,
            show_lab::Bool  = true,
            t0::Real        = 0,
            t_units::Symbol = :sec,
            legend::Symbol  = :outertopright)</code></pre><p>Plot in-flight event(s) on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:       plot (i.e., time series of data)</li><li><code>flight</code>:   flight name (e.g., <code>:Flt1001</code>)</li><li><code>df_event</code>: lookup table (DataFrame) of in-flight events</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>flight</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">flight name (e.g., <code>:Flt1001</code>)</td></tr><tr><td style="text-align: left"><code>tt</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">time of <code>event</code> [s]</td></tr><tr><td style="text-align: left"><code>event</code></td><td style="text-align: left"><code>String</code></td><td style="text-align: left">event description</td></tr></table><ul><li><code>keyword</code>:  (optional) keyword to search within events, case insensitive</li><li><code>show_lab</code>: (optional) if true, show in-flight event (legend) label(s)</li><li><code>t0</code>:       (optional) time offset [<code>t_units</code>]</li><li><code>t_units</code>:  (optional) time units {<code>:sec</code>,<code>:min</code>}</li><li><code>legend</code>:   (optional) legend position (e.g., <code>:topleft</code>,<code>:outertopright</code>)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p2</code>: <code>p1</code> with in-flight events</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2299-L2326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_filt!-Tuple{Plots.Plot, MagNav.Traj, MagNav.INS, MagNav.FILTout}" href="#MagNav.plot_filt!-Tuple{Plots.Plot, MagNav.Traj, MagNav.INS, MagNav.FILTout}"><code>MagNav.plot_filt!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_filt!(p1::Plot, traj::Traj, ins::INS, filt_out::FILTout;
           dpi::Int        = 200,
           Nmax::Int       = 5000,
           show_plot::Bool = true,
           save_plot::Bool = false)</code></pre><p>Plot flights paths on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:        plot (i.e., map)</li><li><code>traj</code>:      <code>Traj</code> trajectory struct</li><li><code>ins</code>:       <code>INS</code> inertial navigation system struct</li><li><code>filt_out</code>:  <code>FILTout</code> filter extracted output struct</li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:      (optional) maximum number of data points plotted</li><li><code>show_plot</code>: (optional) if true, show plots</li><li><code>save_plot</code>: (optional) if true, save plots with default file names</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: flight paths are plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L420-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_filt-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTout}" href="#MagNav.plot_filt-Tuple{MagNav.Traj, MagNav.INS, MagNav.FILTout}"><code>MagNav.plot_filt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_filt(traj::Traj, ins::INS, filt_out::FILTout;
          dpi::Int        = 200,
          Nmax::Int       = 5000,
          plot_vel::Bool  = false,
          show_plot::Bool = true,
          save_plot::Bool = false)</code></pre><p>Plot flights paths and latitudes &amp; longitudes vs time.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:      <code>Traj</code> trajectory struct</li><li><code>ins</code>:       <code>INS</code> inertial navigation system struct</li><li><code>filt_out</code>:  <code>FILTout</code> filter extracted output struct</li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:      (optional) maximum number of data points plotted</li><li><code>plot_vel</code>:  (optional) if true, plot velocities</li><li><code>show_plot</code>: (optional) if true, show plots</li><li><code>save_plot</code>: (optional) if true, save plots with default file names</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: flight paths</li><li><code>p2</code>: latitudes  vs time</li><li><code>p3</code>: longitudes vs time</li><li><code>p4</code>: if <code>plot_vel = true</code>, north velocities vs time</li><li><code>p5</code>: if <code>plot_vel = true</code>, east  velocities vs time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L588-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_filt-Tuple{Plots.Plot, MagNav.Traj, MagNav.INS, MagNav.FILTout}" href="#MagNav.plot_filt-Tuple{Plots.Plot, MagNav.Traj, MagNav.INS, MagNav.FILTout}"><code>MagNav.plot_filt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_filt(p1::Plot, traj::Traj, ins::INS, filt_out::FILTout;
          dpi::Int        = 200,
          Nmax::Int       = 5000,
          plot_vel::Bool  = false,
          show_plot::Bool = true,
          save_plot::Bool = false)</code></pre><p>Plot flights paths on an existing plot and latitudes &amp; longitudes vs time.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:        plot (i.e., map)</li><li><code>traj</code>:      <code>Traj</code> trajectory struct</li><li><code>ins</code>:       <code>INS</code> inertial navigation system struct</li><li><code>filt_out</code>:  <code>FILTout</code> filter extracted output struct</li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:      (optional) maximum number of data points plotted</li><li><code>plot_vel</code>:  (optional) if true, plot velocities</li><li><code>show_plot</code>: (optional) if true, show plots</li><li><code>save_plot</code>: (optional) if true, save plots with default file names</li></ul><p><strong>Returns:</strong></p><ul><li><code>p2</code>: <code>p1</code> with flight paths</li><li><code>p3</code>: latitudes  vs time</li><li><code>p4</code>: longitudes vs time</li><li><code>p5</code>: if <code>plot_vel = true</code>, north velocities vs time</li><li><code>p6</code>: if <code>plot_vel = true</code>, east  velocities vs time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L465-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_filt_err-Tuple{MagNav.Traj, MagNav.FILTout, MagNav.CRLBout}" href="#MagNav.plot_filt_err-Tuple{MagNav.Traj, MagNav.FILTout, MagNav.CRLBout}"><code>MagNav.plot_filt_err</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_filt_err(traj::Traj, filt_out::FILTout, crlb_out::CRLBout;
              dpi::Int        = 200,
              Nmax::Int       = 5000,
              plot_vel::Bool  = false,
              show_plot::Bool = true,
              save_plot::Bool = false)</code></pre><p>Plot northing &amp; easting errors vs time.</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:      <code>Traj</code> trajectory struct</li><li><code>filt_out</code>:  <code>FILTout</code> filter extracted output struct</li><li><code>crlb_out</code>:  <code>CRLBout</code> Cramér–Rao lower bound extracted output struct</li><li><code>dpi</code>:       (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:      (optional) maximum number of data points plotted</li><li><code>plot_vel</code>:  (optional) if true, plot velocity errors</li><li><code>show_plot</code>: (optional) if true, show plots</li><li><code>save_plot</code>: (optional) if true, save plots with default file names</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: northing errors vs time</li><li><code>p2</code>: easting  errors vs time</li><li><code>p3</code>: if <code>plot_vel = true</code>, north velocity errors vs time</li><li><code>p4</code>: if <code>plot_vel = true</code>, east  velocity errors vs time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L630-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_frequency-Tuple{MagNav.XYZ}" href="#MagNav.plot_frequency-Tuple{MagNav.XYZ}"><code>MagNav.plot_frequency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_frequency(xyz::XYZ;
               ind                = trues(xyz.traj.N),
               field::Symbol      = :mag_1_uc,
               freq_type::Symbol  = :PSD,
               detrend_data::Bool = true,
               window::Function   = hamming,
               dpi::Int           = 200,
               show_plot::Bool    = true,
               save_plot::Bool    = false,
               plot_png::String   = &quot;PSD.png&quot;)</code></pre><p>Plot frequency data, either Welch power spectral density (PSD) or spectrogram.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:          <code>XYZ</code> flight data struct</li><li><code>ind</code>:          (optional) selected data indices</li><li><code>field</code>:        (optional) data field in <code>xyz</code> to plot</li><li><code>freq_type</code>:    (optional) frequency plot type {<code>:PSD</code>,<code>:psd</code>,<code>:spectrogram</code>,<code>:spec</code>}</li><li><code>detrend_data</code>: (optional) if true, detrend plot data</li><li><code>window</code>:       (optional) type of window used</li><li><code>dpi</code>:          (optional) dots per inch (image resolution)</li><li><code>show_plot</code>:    (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:    (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:     (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of Welch power spectral density (PSD) or spectrogram</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L478-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_mag-Tuple{MagNav.XYZ}" href="#MagNav.plot_mag-Tuple{MagNav.XYZ}"><code>MagNav.plot_mag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mag(xyz::XYZ;
         ind                       = trues(xyz.traj.N),
         detrend_data::Bool        = false,
         use_mags::Vector{Symbol}  = [:all_mags],
         vec_terms::Vector{Symbol} = [:all],
         ylim::Tuple               = (),
         dpi::Int                  = 200,
         show_plot::Bool           = true,
         save_plot::Bool           = false,
         plot_png::String          = &quot;scalar_mags.png&quot;)</code></pre><p>Plot scalar or vector (fluxgate) magnetometer data from a given flight test.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:          <code>XYZ</code> flight data struct</li><li><code>ind</code>:          (optional) selected data indices</li><li><code>detrend_data</code>: (optional) if true, detrend plot data</li><li><code>use_mags</code>:     (optional) scalar or vector (fluxgate) magnetometers to plot {<code>:all_mags</code>, <code>:comp_mags</code> or <code>:mag_1_c</code>, <code>:mag_1_uc</code>, <code>:flux_a</code>, etc.}<ul><li><code>:all_mags</code>  = all provided scalar magnetometer fields (e.g., <code>:mag_1_c</code>, <code>:mag_1_uc</code>, etc.)</li><li><code>:comp_mags</code> = provided compensation(s) between <code>:mag_1_uc</code> &amp; <code>:mag_1_c</code>, etc.</li></ul></li><li><code>vec_terms</code>:    (optional) vector magnetometer (fluxgate) terms to plot {<code>:all</code> or <code>:x</code>,<code>:y</code>,<code>:z</code>,<code>:t</code>}</li><li><code>ylim</code>:         (optional) length-<code>2</code> plot <code>y</code> limits (<code>ymin</code>,<code>ymax</code>) [nT]</li><li><code>dpi</code>:          (optional) dots per inch (image resolution)</li><li><code>show_plot</code>:    (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:    (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:     (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of scalar or vector (fluxgate) magnetometer data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L107-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_mag_c-Tuple{MagNav.XYZ, MagNav.XYZ}" href="#MagNav.plot_mag_c-Tuple{MagNav.XYZ, MagNav.XYZ}"><code>MagNav.plot_mag_c</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mag_c(xyz::XYZ,xyz_comp::XYZ;
           ind                      = trues(xyz.traj.N),
           ind_comp                 = trues(xyz_comp.traj.N),
           detrend_data::Bool       = true,
           λ                        = 0.025,
           terms                    = [:permanent,:induced,:eddy],
           pass1                    = 0.1,
           pass2                    = 0.9,
           fs                       = 10.0,
           use_mags::Vector{Symbol} = [:all_mags],
           use_vec::Symbol          = :flux_a,
           plot_diff::Bool          = false,
           plot_mag_1_uc::Bool      = true,
           plot_mag_1_c::Bool       = true,
           ylim                     = (),
           dpi::Int                 = 200,
           show_plot::Bool          = true,
           save_plot::Bool          = false,
           plot_png::String         = &quot;scalar_mags_comp.png&quot;)</code></pre><p>Plot compensated magnetometer(s) data from a given flight test. Assumes Mag 1 (i.e., <code>:mag_1_uc</code> &amp; <code>:mag_1_c</code>) is the best magnetometer (i.e., stinger).</p><p><strong>Arguments:</strong></p><ul><li><code>xyz</code>:           <code>XYZ</code> flight data struct</li><li><code>xyz_comp</code>:      <code>XYZ</code> flight data struct to use for compensation</li><li><code>ind</code>:           (optional) selected data indices</li><li><code>ind_comp</code>:      (optional) selected data indices to use for compensation</li><li><code>detrend_data</code>:  (optional) if true, detrend plot data</li><li><code>λ</code>:             (optional) ridge parameter</li><li><code>terms</code>:         (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>pass1</code>:         (optional) filter first passband frequency [Hz]</li><li><code>pass2</code>:         (optional) filter second passband frequency [Hz]</li><li><code>fs</code>:            (optional) filter sampling frequency [Hz]</li><li><code>use_mags</code>:      (optional) scalar or vector (fluxgate) magnetometers to plot {<code>:all_mags</code>, or <code>:mag_1_uc</code>, etc.}<ul><li><code>:all_mags</code> = all uncompensated scalar magnetometer fields (e.g., <code>:mag_1_uc</code>, etc.)</li></ul></li><li><code>use_vec</code>:       (optional) vector magnetometer (fluxgate) to use for Tolles-Lawson <code>A</code> matrix {<code>:flux_a</code>, etc.}</li><li><code>plot_diff</code>:     (optional) if true, plot difference between <code>provided</code> compensated data &amp; compensated mags <code>as performed here</code></li><li><code>plot_mag_1_uc</code>: (optional) if true, plot mag<em>1</em>uc (uncompensated mag_1)</li><li><code>plot_mag_1_c</code>:  (optional) if true, plot mag<em>1</em>c (compensated mag_1)</li><li><code>ylim</code>:          (optional) length-<code>2</code> plot <code>y</code> limits (<code>ymin</code>,<code>ymax</code>) [nT]</li><li><code>dpi</code>:           (optional) dots per inch (image resolution)</li><li><code>show_plot</code>:     (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:     (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:      (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of compensated magnetometer data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/baseline_plots.jl#L249-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_mag_map-Tuple{MagNav.Path, Any, Any}" href="#MagNav.plot_mag_map-Tuple{MagNav.Path, Any, Any}"><code>MagNav.plot_mag_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mag_map(path::Path, mag, itp_mapS;
             lab::String        = &quot;magnetometer&quot;,
             order::Symbol      = :magmap,
             dpi::Int           = 200,
             Nmax::Int          = 5000,
             detrend_data::Bool = true,
             show_plot::Bool    = true,
             save_plot::Bool    = false,
             plot_png::String   = &quot;mag_vs_map.png&quot;)</code></pre><p>Plot scalar magnetometer measurements vs map values.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:         <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>mag</code>:          scalar magnetometer measurements [nT]</li><li><code>itp_mapS</code>:     scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>lab</code>:          (optional) magnetometer data (legend) label</li><li><code>order</code>:        (optional) plotting order {<code>:magmap</code>,<code>:mapmag</code>}</li><li><code>dpi</code>:          (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:         (optional) maximum number of data points plotted</li><li><code>detrend_data</code>: (optional) if true, detrend plot data</li><li><code>show_plot</code>:    (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:    (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:     (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: scalar magnetometer measurements vs map values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L768-L796">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_mag_map_err-Tuple{MagNav.Path, Any, Any}" href="#MagNav.plot_mag_map_err-Tuple{MagNav.Path, Any, Any}"><code>MagNav.plot_mag_map_err</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_mag_map_err(path::Path, mag, itp_mapS;
                 lab::String        = &quot;&quot;,
                 dpi::Int           = 200,
                 Nmax::Int          = 5000,
                 detrend_data::Bool = true,
                 show_plot::Bool    = true,
                 save_plot::Bool    = false,
                 plot_png::String   = &quot;mag_map_err.png&quot;)</code></pre><p>Plot scalar magnetometer measurement vs map value errors.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:         <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>mag</code>:          scalar magnetometer measurements [nT]</li><li><code>itp_mapS</code>:     scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>lab</code>:          (optional) data (legend) label</li><li><code>dpi</code>:          (optional) dots per inch (image resolution)</li><li><code>Nmax</code>:         (optional) maximum number of data points plotted</li><li><code>detrend_data</code>: (optional) if true, detrend plot data</li><li><code>show_plot</code>:    (optional) if true, show <code>p1</code></li><li><code>save_plot</code>:    (optional) if true, save <code>p1</code> as <code>plot_png</code></li><li><code>plot_png</code>:     (optional) plot file name to save (<code>.png</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: scalar magnetometer measurement vs map value errors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L831-L857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_map" href="#MagNav.plot_map"><code>MagNav.plot_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_map(map_map::Matrix,
         map_xx::Vector       = [],
         map_yy::Vector       = [];
         clims::Tuple         = (),
         dpi::Int             = 200,
         margin::Int          = 2,
         Nmax::Int            = 6*dpi,
         legend::Bool         = true,
         axis::Bool           = true,
         map_color::Symbol    = :usgs,
         bg_color::Symbol     = :white,
         map_units::Symbol    = :rad,
         plot_units::Symbol   = :deg,
         b_e::AbstractBackend = gr())</code></pre><p>Plot map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:     <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg]</li><li><code>map_yy</code>:     <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg]</li><li><code>clims</code>:      (optional) length-<code>2</code> colorbar limits <code>(cmin,cmax)</code></li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted (per axis)</li><li><code>legend</code>:     (optional) if true, show legend</li><li><code>axis</code>:       (optional) if true, show axes</li><li><code>map_color</code>:  (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>bg_color</code>:   (optional) background color</li><li><code>map_units</code>:  (optional) map  xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_units</code>: (optional) plot xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:m</code>}</li><li><code>b_e</code>:        (optional) plotting backend</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of map</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1757-L1793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_map!" href="#MagNav.plot_map!"><code>MagNav.plot_map!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_map!(p1::Plot, map_map::Matrix,
          map_xx::Vector       = [],
          map_yy::Vector       = [];
          clims::Tuple         = (),
          dpi::Int             = 200,
          margin::Int          = 2,
          Nmax::Int            = 6*dpi,
          legend::Bool         = true,
          axis::Bool           = true,
          map_color::Symbol    = :usgs,
          bg_color::Symbol     = :white,
          map_units::Symbol    = :rad,
          plot_units::Symbol   = :deg,
          b_e::AbstractBackend = gr())</code></pre><p>Plot map on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot</li><li><code>map_map</code>:    <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>map_xx</code>:     <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg]</li><li><code>map_yy</code>:     <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg]</li><li><code>clims</code>:      (optional) length-<code>2</code> colorbar limits <code>(cmin,cmax)</code></li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted (per axis)</li><li><code>legend</code>:     (optional) if true, show legend</li><li><code>axis</code>:       (optional) if true, show axes</li><li><code>map_color</code>:  (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>bg_color</code>:   (optional) background color</li><li><code>map_units</code>:  (optional) map  xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_units</code>: (optional) plot xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:m</code>}</li><li><code>b_e</code>:        (optional) plotting backend</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: map is plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1495-L1532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_map!-Tuple{Plots.Plot, Plots.Plot, Plots.Plot, MagNav.MapV}" href="#MagNav.plot_map!-Tuple{Plots.Plot, Plots.Plot, Plots.Plot, MagNav.MapV}"><code>MagNav.plot_map!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_map!(p1::Plot, p2::Plot, p3::Plot, mapV::MapV;
          use_mask::Bool       = true,
          clims::Tuple         = (),
          dpi::Int             = 200,
          margin::Int          = 2,
          Nmax::Int            = 6*dpi,
          legend::Bool         = true,
          axis::Bool           = true,
          map_color::Symbol    = :usgs,
          bg_color::Symbol     = :white,
          map_units::Symbol    = :rad,
          plot_units::Symbol   = :deg
          b_e::AbstractBackend = gr())</code></pre><p>Plot map on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot</li><li><code>p2</code>:         plot</li><li><code>p3</code>:         plot</li><li><code>mapV</code>:       <code>MapV</code> vector magnetic anomaly map struct</li><li><code>use_mask</code>:   (optional) if true, apply <code>mapV</code> mask to map</li><li><code>clims</code>:      (optional) length-<code>2</code> colorbar limits <code>(cmin,cmax)</code></li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted (per axis)</li><li><code>legend</code>:     (optional) if true, show legend</li><li><code>axis</code>:       (optional) if true, show axes</li><li><code>map_color</code>:  (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>bg_color</code>:   (optional) background color</li><li><code>map_units</code>:  (optional) map  xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_units</code>: (optional) plot xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:m</code>}</li><li><code>b_e</code>:        (optional) plotting backend</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>mapX</code> is plotted on <code>p1</code></li><li><code>nothing</code>: <code>mapY</code> is plotted on <code>p2</code></li><li><code>nothing</code>: <code>mapZ</code> is plotted on <code>p3</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1686-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_map!-Tuple{Plots.Plot, Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.plot_map!-Tuple{Plots.Plot, Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.plot_map!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_map!(p1::Plot, mapS::Union{MapS,MapSd,MapS3D};
          use_mask::Bool       = true,
          clims::Tuple         = (),
          dpi::Int             = 200,
          margin::Int          = 2,
          Nmax::Int            = 6*dpi,
          legend::Bool         = true,
          axis::Bool           = true,
          map_color::Symbol    = :usgs,
          bg_color::Symbol     = :white,
          map_units::Symbol    = :rad,
          plot_units::Symbol   = :deg
          b_e::AbstractBackend = gr())</code></pre><p>Plot map on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot</li><li><code>mapS</code>:       <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li><li><code>use_mask</code>:   (optional) if true, apply <code>mapS</code> mask to map</li><li><code>clims</code>:      (optional) length-<code>2</code> colorbar limits <code>(cmin,cmax)</code></li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted (per axis)</li><li><code>legend</code>:     (optional) if true, show legend</li><li><code>axis</code>:       (optional) if true, show axes</li><li><code>map_color</code>:  (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>bg_color</code>:   (optional) background color</li><li><code>map_units</code>:  (optional) map  xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_units</code>: (optional) plot xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:m</code>}</li><li><code>b_e</code>:        (optional) plotting backend</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: map is plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1620-L1655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_map-Tuple{MagNav.Map}" href="#MagNav.plot_map-Tuple{MagNav.Map}"><code>MagNav.plot_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_map(map_map::Map;
         use_mask::Bool       = true,
         clims::Tuple         = (),
         dpi::Int             = 200,
         margin::Int          = 2,
         Nmax::Int            = 6*dpi,
         legend::Bool         = true,
         axis::Bool           = true,
         map_color::Symbol    = :usgs,
         bg_color::Symbol     = :white,
         map_units::Symbol    = :rad,
         plot_units::Symbol   = :deg,
         b_e::AbstractBackend = gr())</code></pre><p>Plot map.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>Map</code> magnetic anomaly map struct</li><li><code>use_mask</code>:   (optional) if true, apply <code>map_map</code> mask to map</li><li><code>clims</code>:      (optional) length-<code>2</code> colorbar limits <code>(cmin,cmax)</code></li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted (per axis)</li><li><code>legend</code>:     (optional) if true, show legend</li><li><code>axis</code>:       (optional) if true, show axes</li><li><code>map_color</code>:  (optional) filled contour color scheme {<code>:usgs</code>,<code>:gray</code>,<code>:gray1</code>,<code>:gray2</code>,<code>:plasma</code>,<code>:magma</code>}</li><li><code>bg_color</code>:   (optional) background color</li><li><code>map_units</code>:  (optional) map  xx/yy units {<code>:rad</code>,<code>:deg</code>}</li><li><code>plot_units</code>: (optional) plot xx/yy units {<code>:rad</code>,<code>:deg</code>,<code>:m</code>}</li><li><code>b_e</code>:        (optional) plotting backend</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of map (if <code>map_map isa MapV</code>, <code>mapX</code>)</li><li><code>p2</code>: if <code>map_map isa MapV</code>, <code>mapY</code></li><li><code>p3</code>: if <code>map_map isa MapV</code>, <code>mapZ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1825-L1861">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path" href="#MagNav.plot_path"><code>MagNav.plot_path</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path(p1::Plot, path::Path, ind = trues(path.N);
          lab::String        = &quot;&quot;,
          Nmax::Int          = 5000,
          show_plot::Bool    = true,
          zoom_plot::Bool    = false,
          path_color::Symbol = :ignore)</code></pre><p>Plot flight path on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot (i.e., map)</li><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:        (optional) selected data indices</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>p2</code>: <code>p1</code> with flight path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2103-L2125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path" href="#MagNav.plot_path"><code>MagNav.plot_path</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path(path::Path, ind = trues(path.N);
          lab::String        = &quot;&quot;,
          dpi::Int           = 200,
          margin::Int        = 2,
          Nmax::Int          = 5000,
          show_plot::Bool    = true,
          zoom_plot::Bool    = true,
          path_color::Symbol = :ignore)</code></pre><p>Plot flight path.</p><p><strong>Arguments:</strong></p><ul><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:        (optional) selected data indices</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of flight path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2187-L2212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path!" href="#MagNav.plot_path!"><code>MagNav.plot_path!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path!(p1::Plot, path::Path, ind = trues(path.N);
           lab::String        = &quot;&quot;,
           Nmax::Int          = 5000,
           show_plot::Bool    = true,
           zoom_plot::Bool    = false,
           path_color::Symbol = :ignore)</code></pre><p>Plot flight path on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot (i.e., map)</li><li><code>path</code>:       <code>Path</code> struct, i.e., <code>Traj</code> trajectory struct, <code>INS</code> inertial navigation system struct, or <code>FILTout</code> filter extracted output struct</li><li><code>ind</code>:        (optional) selected data indices</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: flight path is plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2026-L2048">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path!-Tuple{Plots.Plot, Any, Any}" href="#MagNav.plot_path!-Tuple{Plots.Plot, Any, Any}"><code>MagNav.plot_path!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path!(p1::Plot, lat, lon;
           lab::String        = &quot;&quot;,
           Nmax::Int          = 5000,
           show_plot::Bool    = true,
           zoom_plot::Bool    = false,
           path_color::Symbol = :ignore)</code></pre><p>Plot flight path on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot (i.e., map)</li><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: flight path is plotted on <code>p1</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L1976-L1998">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path-Tuple{Any, Any}" href="#MagNav.plot_path-Tuple{Any, Any}"><code>MagNav.plot_path</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path(lat, lon;
          lab::String        = &quot;&quot;,
          dpi::Int           = 200,
          margin::Int        = 2,
          Nmax::Int          = 5000,
          show_plot::Bool    = true,
          zoom_plot::Bool    = true,
          path_color::Symbol = :ignore)</code></pre><p>Plot flight path.</p><p><strong>Arguments:</strong></p><ul><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>dpi</code>:        (optional) dots per inch (image resolution)</li><li><code>margin</code>:     (optional) margin around plot [mm]</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of flight path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2142-L2167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_path-Tuple{Plots.Plot, Any, Any}" href="#MagNav.plot_path-Tuple{Plots.Plot, Any, Any}"><code>MagNav.plot_path</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_path(p1::Plot, lat, lon;
          lab::String        = &quot;&quot;,
          Nmax::Int          = 5000,
          show_plot::Bool    = true,
          zoom_plot::Bool    = false,
          path_color::Symbol = :ignore)</code></pre><p>Plot flight path on an existing plot.</p><p><strong>Arguments:</strong></p><ul><li><code>p1</code>:         plot (i.e., map)</li><li><code>lat</code>:        latitude  [rad]</li><li><code>lon</code>:        longitude [rad]</li><li><code>lab</code>:        (optional) data (legend) label</li><li><code>Nmax</code>:       (optional) maximum number of data points plotted</li><li><code>show_plot</code>:  (optional) if true, show plot</li><li><code>zoom_plot</code>:  (optional) if true, zoom plot onto flight path</li><li><code>path_color</code>: (optional) path color {<code>:ignore</code>,<code>:black</code>,<code>:gray</code>,<code>:red</code>,<code>:orange</code>,<code>:yellow</code>,<code>:green</code>,<code>:cyan</code>,<code>:blue</code>,<code>:purple</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>p2</code>: <code>p1</code> with flight path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_functions.jl#L2064-L2086">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plot_shapley" href="#MagNav.plot_shapley"><code>MagNav.plot_shapley</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_shapley(df_shap, baseline_shap,
             range_shap::UnitRange = UnitRange(axes(df_shap,1));
             title::String         = &quot;features $range_shap&quot;,
             dpi::Int              = 200)</code></pre><p>Plot horizontal bar graph of feature importance (Shapley effects).</p><p><strong>Arguments:</strong></p><ul><li><code>df_shap</code>:       DataFrame of Shapley effects</li></ul><table><tr><th style="text-align: left"><strong>Field</strong></th><th style="text-align: left"><strong>Type</strong></th><th style="text-align: left"><strong>Description</strong></th></tr><tr><td style="text-align: left"><code>feature_name</code></td><td style="text-align: left"><code>Symbol</code></td><td style="text-align: left">feature name</td></tr><tr><td style="text-align: left"><code>mean_effect</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">mean Shapley effect</td></tr></table><ul><li><code>baseline_shap</code>: intercept of Shapley effects</li><li><code>range_shap</code>:    (optional) range of Shapley effects to plot (limit to length ~20)</li><li><code>dpi</code>:           (optional) dots per inch (image resolution)</li><li><code>title</code>:         (optional) plot title</li></ul><p><strong>Returns:</strong></p><ul><li><code>p1</code>: plot of Shapley effects</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2033-L2054">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.plsr_fit" href="#MagNav.plsr_fit"><code>MagNav.plsr_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plsr_fit(x, y, k::Int = size(x,2), no_norm = falses(size(x,2));
         data_norms::Tuple = (zeros(1,1),zeros(1,1),[0.0],[0.0]),
         l_segs::Vector    = [length(y)],
         return_set::Bool  = false,
         silent::Bool      = false)</code></pre><p>Fit a multi-input, multi-output (MIMO) partial least squares regression (PLSR) model to data with a specified output dimension. PLSR is a type of regularized linear regression where the number of components controls the strength of the regularization.</p><p><strong>Arguments:</strong></p><ul><li><code>x</code>:          <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>y</code>:          length-<code>N</code> target vector</li><li><code>k</code>:          (optional) number of components</li><li><code>no_norm</code>:    (optional) length-<code>Nf</code> Boolean indices of features to not be normalized</li><li><code>data_norms</code>: (optional) length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>l_segs</code>:     (optional) length-<code>N_lines</code> vector of lengths of <code>lines</code>, sum(l_segs) = <code>N</code></li><li><code>return_set</code>: (optional) if true, return <code>coef_set</code> instead of other outputs</li><li><code>silent</code>:     (optional) if true, no print outs</li></ul><p><strong>Returns:</strong></p><ul><li><code>model</code>:      length-<code>2</code> tuple of PLSR-based model, (length-<code>Nf</code> coefficients, bias=<code>0</code>)</li><li><code>data_norms</code>: length-<code>4</code> tuple of data normalizations, <code>(x_bias,x_scale,y_bias,y_scale)</code></li><li><code>y_hat</code>:      length-<code>N</code> prediction vector</li><li><code>err</code>:        length-<code>N</code> mean-corrected (per line) error</li><li><code>coef_set</code>:   if <code>return_set = true</code>, set of coefficients (size <code>Nf</code> x <code>Ny</code> x <code>k</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/compensation.jl#L1721-L1749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.predict_rnn_full-Tuple{Any, Any}" href="#MagNav.predict_rnn_full-Tuple{Any, Any}"><code>MagNav.predict_rnn_full</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_rnn_full(m, x)</code></pre><p>Apply model <code>m</code> to data matrix <code>x</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>: recurrent neural network model</li><li><code>x</code>: <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_hat</code>: length-<code>N</code> prediction vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1810-L1821">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.predict_rnn_windowed-Tuple{Any, Any, Int64}" href="#MagNav.predict_rnn_windowed-Tuple{Any, Any, Int64}"><code>MagNav.predict_rnn_windowed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_rnn_windowed(m, x, l_window::Int)</code></pre><p>Apply model <code>m</code> to data matrix <code>x</code> with sliding window of length-<code>l_window</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>:        recurrent neural network model</li><li><code>x</code>:        <code>N</code> x <code>Nf</code> data matrix (<code>Nf</code> is number of features)</li><li><code>l_window</code>: temporal window length</li></ul><p><strong>Returns:</strong></p><ul><li><code>y_hat</code>: length-<code>N</code> prediction vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1830-L1842">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.project_body_field_to_2d_igrf-Tuple{Any, Any, Any}" href="#MagNav.project_body_field_to_2d_igrf-Tuple{Any, Any, Any}"><code>MagNav.project_body_field_to_2d_igrf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">project_body_field_to_2d_igrf(vec_body, igrf_nav, Cnb)</code></pre><p>Project a body frame vector onto a 2D plane defined by the direction of the IGRF and a tangent vector to the Earth ellipsoid, which is computed by taking the cross product of the IGRF with the upward direction. Returns a 2D vector whose components describe the amount of the body field that is in alignment with the Earth field and an orthogonal direction to the Earth field (roughly to the east).</p><p><strong>Arguments:</strong></p><ul><li><code>vec_body</code>: vector in body frame (e.g., aircraft induced field)</li><li><code>igrf_nav</code>: IGRF unit vector in navigation frame</li><li><code>Cnb</code>:      <code>3</code> x <code>3</code> x <code>N</code> direction cosine matrix (body to navigation) [-]</li></ul><p><strong>Returns:</strong></p><ul><li><code>v_out</code>: 2D vector whose components illustrate projection onto the Earth field and an orthogonal component</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L2192-L2209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.psd-Tuple{Matrix, Any, Any}" href="#MagNav.psd-Tuple{Matrix, Any, Any}"><code>MagNav.psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psd(map_map::Matrix, dx, dy)</code></pre><p>Power spectral density of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform to determine the spectral energy distribution across the radial wavenumbers (spatial frequencies) in the Fourier transform.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>dx</code>:      x-direction map step size [m]</li><li><code>dy</code>:      y-direction map step size [m]</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_psd</code>: <code>ny</code> x <code>nx</code> power spectral density of 2D gridded map data</li><li><code>kx</code>:      <code>ny</code> x <code>nx</code> x-direction radial wavenumber</li><li><code>ky</code>:      <code>ny</code> x <code>nx</code> y-direction radial wavenumber</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L370-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.psd-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}" href="#MagNav.psd-Tuple{Union{MagNav.MapS, MagNav.MapS3D, MagNav.MapSd}}"><code>MagNav.psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psd(mapS::Union{MapS,MapSd,MapS3D})</code></pre><p>Power spectral density of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform to determine the spectral energy distribution across the radial wavenumbers (spatial frequencies) in the Fourier transform.</p><p><strong>Arguments:</strong></p><ul><li><code>mapS</code>: <code>MapS</code>, <code>MapSd</code>, or <code>MapS3D</code> scalar magnetic anomaly map struct</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_psd</code>: <code>ny</code> x <code>nx</code> power spectral density of 2D gridded map data</li><li><code>kx</code>:      <code>ny</code> x <code>nx</code> x-direction radial wavenumber</li><li><code>ky</code>:      <code>ny</code> x <code>nx</code> y-direction radial wavenumber</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L394-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.run_filt" href="#MagNav.run_filt"><code>MagNav.run_filt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_filt(traj::Traj, ins::INS, meas, itp_mapS, filt_type::Symbol = :ekf;
         P0             = create_P0(),
         Qd             = create_Qd(),
         R              = 1.0,
         num_part       = 1000,
         thresh         = 0.8,
         baro_tau       = 3600.0,
         acc_tau        = 3600.0,
         gyro_tau       = 3600.0,
         fogm_tau       = 600.0,
         date           = get_years(2020,185),
         core::Bool     = false,
         map_alt        = 0,
         x_nn           = nothing,
         m              = nothing,
         y_norms        = nothing,
         terms          = [:permanent,:induced,:eddy,:bias],
         flux::MagV     = MagV([0.0],[0.0],[0.0],[0.0]),
         x0_TL          = ones(eltype(P0),19),
         extract::Bool  = true,
         run_crlb::Bool = true)</code></pre><p>Run navigation filter and optionally compute Cramér–Rao lower bound (CRLB).</p><p><strong>Arguments:</strong></p><ul><li><code>traj</code>:      <code>Traj</code> trajectory struct</li><li><code>ins</code>:       <code>INS</code> inertial navigation system struct</li><li><code>meas</code>:      scalar magnetometer measurement [nT]</li><li><code>itp_mapS</code>:  scalar map interpolation function (<code>f(lat,lon)</code> or <code>f(lat,lon,alt)</code>)</li><li><code>filt_type</code>: (optional) filter type {<code>:ekf</code>,<code>:mpf</code>}</li><li><code>P0</code>:        (optional) initial covariance matrix</li><li><code>Qd</code>:        (optional) discrete time process/system noise matrix</li><li><code>R</code>:         (optional) measurement (white) noise variance</li><li><code>num_part</code>:  (optional) number of particles, only used for <code>filt_type = :mpf</code></li><li><code>thresh</code>:    (optional) resampling threshold fraction {0:1}, only used for <code>filt_type = :mpf</code></li><li><code>baro_tau</code>:  (optional) barometer time constant [s]</li><li><code>acc_tau</code>:   (optional) accelerometer time constant [s]</li><li><code>gyro_tau</code>:  (optional) gyroscope time constant [s]</li><li><code>fogm_tau</code>:  (optional) FOGM catch-all time constant [s]</li><li><code>date</code>:      (optional) measurement date (decimal year) for IGRF [yr]</li><li><code>core</code>:      (optional) if true, include core magnetic field in measurement</li><li><code>map_alt</code>:   (optional) map altitude [m]</li><li><code>x_nn</code>:      (optional) <code>N</code> x <code>Nf</code> data matrix for neural network (<code>Nf</code> is number of features)</li><li><code>m</code>:         (optional) neural network model</li><li><code>y_norms</code>:   (optional) tuple of <code>y</code> normalizations, i.e., <code>(y_bias,y_scale)</code></li><li><code>terms</code>:     (optional) Tolles-Lawson terms to use {<code>:permanent</code>,<code>:induced</code>,<code>:eddy</code>,<code>:bias</code>}</li><li><code>flux</code>:      (optional) <code>MagV</code> vector magnetometer measurement struct</li><li><code>x0_TL</code>:     (optional) initial Tolles-Lawson coefficient states</li><li><code>extract</code>:   (optional) if true, extract output structs</li><li><code>run_crlb</code>:  (optional) if true, compute the Cramér–Rao lower bound (CRLB)</li></ul><p><strong>Returns:</strong></p><ul><li>if <code>extract = true</code>  &amp; <code>run_crlb = true</code><ul><li><code>crlb_out</code>: <code>CRLBout</code> Cramér–Rao lower bound extracted output struct</li><li><code>ins_out</code>:  <code>INSout</code>  inertial navigation system extracted output struct</li><li><code>filt_out</code>: <code>FILTout</code> filter extracted output struct</li></ul></li><li>if <code>extract = true</code>  &amp; <code>run_crlb = false</code><ul><li><code>filt_out</code>: <code>FILTout</code> filter extracted output struct</li></ul></li><li>if <code>extract = false</code> &amp; <code>run_crlb = true</code><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li><li><code>crlb_P</code>:   Cramér–Rao lower bound non-linear covariance matrix</li></ul></li><li>if <code>extract = false</code> &amp; <code>run_crlb = false</code><ul><li><code>filt_res</code>: <code>FILTres</code> filter results struct</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L1-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.run_filt-Tuple{MagNav.Traj, MagNav.INS, Any, Any, Vector{Symbol}}" href="#MagNav.run_filt-Tuple{MagNav.Traj, MagNav.INS, Any, Any, Vector{Symbol}}"><code>MagNav.run_filt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_filt(traj::Traj, ins::INS, meas, itp_mapS,
         filt_type::Vector{Symbol}; ...)</code></pre><p>Run multiple filter models and print results (nothing returned).</p><p><strong>Arguments:</strong></p><ul><li><code>filt_type</code>: multiple filter types, e.g., [<code>:ekf</code>,<code>:ekf_online_nn</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/eval_filt.jl#L170-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.save_comp_params" href="#MagNav.save_comp_params"><code>MagNav.save_comp_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_comp_params(comp_params::CompParams,
                 comp_params_bson::String = &quot;comp_params.bson&quot;)</code></pre><p>Save aeromagnetic compensation parameters to BSON file.</p><p><strong>Arguments:</strong></p><ul><li><code>comp_params</code>: <code>CompParams</code> aeromagnetic compensation parameters struct, either:<ul><li><code>NNCompParams</code>:  neural network-based aeromagnetic compensation parameters struct</li><li><code>LinCompParams</code>: linear aeromagnetic compensation parameters struct</li></ul></li><li><code>comp_params_bson</code>: (optional) path/name of aeromagnetic compensation parameters BSON file to save (<code>.bson</code> extension optional)</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>comp_params_bson</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L456-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.save_map" href="#MagNav.save_map"><code>MagNav.save_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_map(map_map, map_xx, map_yy, map_alt, map_h5::String = &quot;map_data.h5&quot;;
         map_info::String   = &quot;Map&quot;,
         map_mask::BitArray = falses(1,1),
         map_border::Matrix = zeros(eltype(map_alt),1,1),
         map_units::Symbol  = :rad,
         file_units::Symbol = :deg)</code></pre><p>Save map data to HDF5 file. Maps are typically saved in <code>:deg</code> units, while <code>:rad</code> is used internally.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:   <code>ny</code> x <code>nx</code> (x <code>nz</code>) 2D or 3D gridded map data</li><li><code>map_xx</code>:    <code>nx</code> map x-direction (longitude) coordinates [rad] or [deg]</li><li><code>map_yy</code>:    <code>ny</code> map y-direction (latitude)  coordinates [rad] or [deg]</li><li><code>map_alt</code>:    map altitude(s) or <code>ny</code> x <code>nx</code> 2D gridded altitude map data [m]</li><li><code>map_h5</code>:     (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li><li><code>map_info</code>:   (optional) map information</li><li><code>map_mask</code>:   (optional) <code>ny</code> x <code>nx</code> (x <code>nz</code>) mask for valid (not filled-in) map data</li><li><code>map_border</code>: (optional) [xx yy] border for valid (not filled-in) map data [rad] or [deg]</li><li><code>map_units</code>:  (optional) map xx/yy units used in <code>map_xx</code> &amp; <code>map_yy</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>file_units</code>: (optional) map xx/yy units to use in <code>map_h5</code> {<code>:rad</code>,<code>:deg</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_h5</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L217-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.save_map" href="#MagNav.save_map"><code>MagNav.save_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_map(map_map::Map, map_h5::String = &quot;map_data.h5&quot;;
         map_border::Matrix = zeros(eltype(map_map.alt),1,1),
         map_units::Symbol  = :rad,
         file_units::Symbol = :deg)</code></pre><p>Save map data to HDF5 file. Maps are typically saved in <code>:deg</code> units, while <code>:rad</code> is used internally.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>:    <code>Map</code> magnetic anomaly map struct</li><li><code>map_h5</code>:     (optional) path/name of map data HDF5 file to save (<code>.h5</code> extension optional)</li><li><code>map_border</code>: (optional) [xx yy] border for valid (not filled-in) map data [rad] or [deg]</li><li><code>map_units</code>:  (optional) map xx/yy units used in <code>map_map</code> {<code>:rad</code>,<code>:deg</code>}</li><li><code>file_units</code>: (optional) map xx/yy units to use in <code>map_h5</code> {<code>:rad</code>,<code>:deg</code>}</li></ul><p><strong>Returns:</strong></p><ul><li><code>nothing</code>: <code>map_h5</code> is created</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/get_map.jl#L293-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.sgl_2020_train-Tuple{}" href="#MagNav.sgl_2020_train-Tuple{}"><code>MagNav.sgl_2020_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sgl_2020_train()</code></pre><p>Flight data from the 2020 SGL flight data collection - training portion. Collected from 20-Jun-2020 to 07-Jul-2020 near Ottawa, Ontario, Canada by Sander Geophysics Ltd. (SGL) using a Cessna Grand Caravan. Contains:</p><ul><li><code>Flt1002_train.h5</code></li><li><code>Flt1003_train.h5</code></li><li><code>Flt1004_train.h5</code></li><li><code>Flt1005_train.h5</code></li><li><code>Flt1006_train.h5</code></li><li><code>Flt1007_train.h5</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/MagNav.jl#L118-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.sgl_2021_train-Tuple{}" href="#MagNav.sgl_2021_train-Tuple{}"><code>MagNav.sgl_2021_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sgl_2021_train()</code></pre><p>Flight data from the 2021 SGL flight data collection - training portion. Collected from 13-Dec-2021 to 05-Jan-2022 near Ottawa, Ontario, Canada by Sander Geophysics Ltd. (SGL) using a Cessna Grand Caravan. Contains:</p><ul><li><code>Flt2001_train.h5</code></li><li><code>Flt2002_train.h5</code></li><li><code>Flt2004_train.h5</code></li><li><code>Flt2005_train.h5</code></li><li><code>Flt2006_train.h5</code></li><li><code>Flt2007_train.h5</code></li><li><code>Flt2008_train.h5</code></li><li><code>Flt2015_train.h5</code></li><li><code>Flt2016_train.h5</code></li><li><code>Flt2017_train.h5</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/MagNav.jl#L133-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.sparse_group_lasso" href="#MagNav.sparse_group_lasso"><code>MagNav.sparse_group_lasso</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_group_lasso(weights::Params, α=1)</code></pre><p>Get the sparse group Lasso term for sparse-input regularization, which is the combined L1 &amp; L2 norm of the first-layer neural network weights corresponding to each input feature.</p><p>Reference: Feng &amp; Simon, Sparse-Input Neural Networks for High-dimensional Nonparametric Regression and Classification, 2017 (pg. 4).</p><p><strong>Arguments:</strong></p><ul><li><code>weights</code>: neural network model weights</li><li><code>α</code>:       (optional) Lasso (<code>α=0</code>) vs group Lasso (<code>α=1</code>) balancing parameter {0:1}</li></ul><p><strong>Returns:</strong></p><ul><li><code>w_norm</code>: sparse group Lasso term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1255-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.sparse_group_lasso" href="#MagNav.sparse_group_lasso"><code>MagNav.sparse_group_lasso</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_group_lasso(m::Chain, α=1)</code></pre><p>Get the sparse group Lasso term for sparse-input regularization, which is the combined L1 &amp; L2 norm of the first-layer neural network weights corresponding to each input feature.</p><p>Reference: Feng &amp; Simon, Sparse-Input Neural Networks for High-dimensional Nonparametric Regression and Classification, 2017 (pg. 4).</p><p><strong>Arguments:</strong></p><ul><li><code>m</code>: neural network model</li><li><code>α</code>: (optional) Lasso (<code>α=0</code>) vs group Lasso (<code>α=1</code>) balancing parameter {0:1}</li></ul><p><strong>Returns:</strong></p><ul><li><code>w_norm</code>: sparse group Lasso term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/analysis_util.jl#L1277-L1293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.upward_fft-Tuple{MagNav.Map, Any}" href="#MagNav.upward_fft-Tuple{MagNav.Map, Any}"><code>MagNav.upward_fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">upward_fft(map_map::Map, alt; expand::Bool = true, α = 0)</code></pre><p>Upward continuation of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform (FFT) to convert the map to the frequency domain, applies an upward continuation filter, and uses the inverse FFT to convert the map back to the spatial domain. Optionally expands the map temporarily with periodic padding. Downward continuation may be performed to a limited degree as well, but be careful, as this is generally unstable and amplifies high frequencies (i.e., noise).</p><p>Reference: Blakely, Potential Theory in Gravity and Magnetic Applications, 2009, Chapter 12 &amp; Appendix B (pg. 315-317 &amp; 402).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct</li><li><code>alt</code>:     target upward continuation altitude(s) [m]</li><li><code>expand</code>:  (optional) if true, expand map temporarily to reduce edge effects</li><li><code>α</code>:       (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>Map</code> magnetic anomaly map struct, upward/downward continued (<code>MapS</code> with <code>alt</code> vector =&gt; <code>MapS3D</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L54-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.upward_fft-Tuple{Matrix, Any, Any, Any}" href="#MagNav.upward_fft-Tuple{Matrix, Any, Any, Any}"><code>MagNav.upward_fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">upward_fft(map_map::Matrix, dx, dy, dz; expand::Bool = true, α = 0)</code></pre><p>Upward continuation of a potential field (i.e., magnetic anomaly field) map. Uses the Fast Fourier Transform (FFT) to convert the map to the frequency domain, applies an upward continuation filter, and uses the inverse FFT to convert the map back to the spatial domain. Optionally expands the map temporarily with periodic padding. Downward continuation may be performed to a limited degree as well, but be careful, as this is generally unstable and amplifies high frequencies (i.e., noise).</p><p>Reference: Blakely, Potential Theory in Gravity and Magnetic Applications, 2009, Chapter 12 &amp; Appendix B (pg. 315-317 &amp; 402).</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>dx</code>:      x-direction map step size [m]</li><li><code>dy</code>:      y-direction map step size [m]</li><li><code>dz</code>:      <code>nz</code> z-direction upward/downward continuation distance(s) [m]</li><li><code>expand</code>:  (optional) if true, expand map temporarily to reduce edge effects</li><li><code>α</code>:       (optional) regularization parameter for downward continuation</li></ul><p><strong>Returns:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> (x <code>nz</code>) 2D or 3D gridded map data, upward/downward continued</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.vector_fft-Tuple{Matrix, Vararg{Any, 4}}" href="#MagNav.vector_fft-Tuple{Matrix, Vararg{Any, 4}}"><code>MagNav.vector_fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_fft(map_map::Matrix, dx, dy, D, I)</code></pre><p>Get potential field (i.e., magnetic anomaly field) map vector components using declination and inclination.</p><p><strong>Arguments:</strong></p><ul><li><code>map_map</code>: <code>ny</code> x <code>nx</code> 2D gridded map data</li><li><code>dx</code>:      x-direction map step size [m]</li><li><code>dy</code>:      y-direction map step size [m]</li><li><code>D</code>:       map declination (Earth core field) [rad]</li><li><code>I</code>:       map inclination (Earth core field) [rad]</li></ul><p><strong>Returns:</strong></p><ul><li><code>Bx, By, Bz</code>: map vector components</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/map_fft.jl#L152-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.xyz2h5-Tuple{Array, String, Symbol}" href="#MagNav.xyz2h5-Tuple{Array, String, Symbol}"><code>MagNav.xyz2h5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xyz2h5(data::Array, xyz_h5::String, flight::Symbol;
       tt_sort::Bool      = true,
       lines::Vector      = [()],
       lines_type::Symbol = :exclude)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/xyz2h5.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MagNav.xyz2h5-Tuple{String, String, Symbol}" href="#MagNav.xyz2h5-Tuple{String, String, Symbol}"><code>MagNav.xyz2h5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xyz2h5(xyz_xyz::String, xyz_h5::String, flight::Symbol;
       lines::Vector        = [()],
       lines_type::Symbol   = :exclude,
       tt_sort::Bool        = true,
       downsample_160::Bool = true,
       return_data::Bool    = false)</code></pre><p>Convert SGL flight data file from .xyz to HDF5.</p><ul><li>Valid for SGL flights:<ul><li><code>:Flt1001</code></li><li><code>:Flt1002</code></li><li><code>:Flt1003</code></li><li><code>:Flt1004_1005</code></li><li><code>:Flt1004</code></li><li><code>:Flt1005</code></li><li><code>:Flt1006</code></li><li><code>:Flt1007</code></li><li><code>:Flt1008</code></li><li><code>:Flt1009</code></li><li><code>:Flt1001_160Hz</code></li><li><code>:Flt1002_160Hz</code></li><li><code>:Flt2001_2017</code></li></ul></li></ul><p>May take 1+ hr for 1+ GB files. For reference, a 1.23 GB file took 46.8 min to process using a 64 GB MacBook Pro.</p><p><strong>Arguments:</strong></p><ul><li><code>xyz_xyz</code>:        path/name of flight data .xyz file (<code>.xyz</code> extension optional)</li><li><code>xyz_h5</code>:         path/name of flight data HDF5 file to save (<code>.h5</code> extension optional)</li><li><code>flight</code>:         flight name (e.g., <code>:Flt1001</code>)</li><li><code>lines</code>:          (optional) selected line number(s) to ONLY include or exclude, must be a vector of 3-element (<code>line</code>,<code>start_time</code>,<code>end_time</code>) tuple(s)</li><li><code>lines_type</code>:     (optional) whether to ONLY <code>:include</code> (i.e., to generate testing data) or <code>:exclude</code> (i.e., to generate training data) <code>lines</code></li><li><code>tt_sort</code>:        (optional) if true, sort data by time (instead of line)</li><li><code>downsample_160</code>: (optional) if true, downsample 160 Hz data to 10 Hz (only for 160 Hz data files)</li><li><code>return_data</code>:    (optional) if true, return <code>data</code> instead of creating <code>xyz_h5</code></li></ul><p><strong>Returns:</strong></p><ul><li><code>data</code>: if <code>return_data = true</code>, internal data matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MIT-AI-Accelerator/MagNav.jl/blob/43be42613ca6fa22195f89bd63c88b4289cdf295/src/xyz2h5.jl#L1-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api_structs/">API: Structs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Wednesday 30 April 2025 04:19">Wednesday 30 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
